FR.Chart = FR.Chart || {};
FR.Chart.chartDivCache = FR.Chart.chartDivCache || {};
var DIV_CONTAINER;
FR.Chart.ChartJsInit = function (a) {
    this.initConstants(a)
};
$.extend(FR.Chart.ChartJsInit.prototype, {
    initConstants: function (a) {
    }
});
FR.Chart.DivCon = {
    addDiv: function (c, b) {
        if (!c) {
            c = FR.Chart.currentDivKey
        }
        var a = FR.Chart.chartDivCache[c.id];
        if (a) {
            var e = a.div;
            if (e) {
                e.appendChild(b)
            }
            var d = a.labelList;
            if (d) {
                d[d.length] = b
            }
        }
    }, clearDiv: function (e) {
        if (e) {
            var c = e.id;
            var a = FR.Chart.chartDivCache[c];
            if (a) {
                var f = a.div;
                var d = a.labelList;
                if (f && d) {
                    for (var b = 0; b < d.length; b++) {
                        if (f.contains(d[b])) {
                            f.removeChild(d[b])
                        }
                    }
                    a.labelList = []
                }
            } else {
                f = e;
                d = [];
                FR.Chart.chartDivCache[c] = {"div": f, "labelList": d}
            }
        }
        FR.Chart.currentDivKey = e
    }
};
FR.Chart.MapShapeValue = function (c, b, a) {
    this.markType = FR.pick(a, 1);
    this.areaName = FR.pick(c, "");
    this.shapePath = FR.pick(b, new FR.Chart.GeneralPath())
};
FR.Chart.MapAttr = function (b, f, g) {
    this.imageBounds = FR.pick(f, new FR.Chart.Bounds());
    this.imageSrc = FR.pick(g, {});
    this.shapeValues = {};
    this.cacheImage = null;
    if (b) {
        for (var e = 0;
             e < b.length; e++) {
            var h = b[e];
            var d = new FR.Chart.GeneralPath(h.path);
            if (d.x && d.x.length > 1) {
                d.closePath()
            }
            var i = h.markType;
            var c = h.key;
            var a = new FR.Chart.MapShapeValue(i, d, c);
            this.shapeValues[c] = a
        }
    }
};
$.extend(FR.Chart.MapAttr.prototype, {
    getPathByName: function (a) {
        if (this.shapeValues[a]) {
            return this.shapeValues[a].shapePath
        }
        return new FR.Chart.GeneralPath()
    }, drawBackgroundImage: function (m, d, h) {
        if (!m) {
            return
        }
        m.save();
        if (!this.imageBounds.width || !this.imageBounds.height) {
            return
        }
        var j = h.x;
        var i = h.y;
        var g = this.imageBounds.width;
        var f = this.imageBounds.height;
        var b = h.width;
        var k = h.height;
        var a = b / g;
        var n = k / f;
        var e = b;
        var c = k;
        if (a > n) {
            e = (b * n / a);
            j += (b - e) / 2
        } else {
            c = (k * a / n);
            i += (k - c) / 2
        }
        if (this.cacheImage) {
            m.drawImage(this.cacheImage, j, i, e, c)
        } else {
            this.cacheImage = new Image();
            var l = this;
            this.cacheImage.onload = function () {
                setTimeout(function () {
                    m.drawImage(l.cacheImage, j, i, e, c)
                }, 100)
            };
            if (FR.Browser.isIE()) {
                this.cacheImage.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.imageSrc.onie
            } else {
                this.cacheImage.src = this.imageSrc.onsrc
            }
        }
        m.restore()
    }
});
FR.Chart.MapSvgAttr = function (a) {
    this.svgRoot = a;
    this.layerTo = {};
    this.nameTo = {};
    this.namedNodes = [];
    this.names = [];
    this.imageBounds = FR.Chart.SVGExtension.getImageBounds(a);
    this.nodeList = FR.Chart.SVGExtension.svgResolve(a, this.namedNodes, this.nameTo, this.layerTo, this.names)
};
$.extend(FR.Chart.MapSvgAttr.prototype, {
    getPathByName: function (d) {
        var c = new FR.Chart.GeneralPath();
        for (var b = 0; b < this.namedNodes.length; b++) {
            var a = this.namedNodes[b].name;
            var e = this.namedNodes[b].path;
            if (FR.equals(a, d)) {
                c.append(FR.Chart.SVGExtension.getPath4Shape(e))
            }
        }
        return c
    }, drawBackgroundImage: function (b, c) {
        if (!this.nodeList) {
            return
        }
        for (var a = 0; a < this.nodeList.length; a++) {
            var d = this.nodeList[a];
            FR.Chart.SVGExtension.drawNodeShape(b, d, c)
        }
    }, _findFirstNodeByName: function (d) {
        for (var b = 0; b < this.namedNodes.length; b++) {
            var a = this.namedNodes[b].name;
            var c = this.namedNodes[b].path;
            if (FR.equals(a, d)) {
                return c
            }
        }
    }, drawBorder: function (a, b, d) {
        var c = this._findFirstNodeByName(b);
        if (c && d) {
            a.globalAlpha = c.opacity ? c.opacity : 1;
            a.lineWidth = c.lineWidth ? c.lineWidth : 0;
            a.strokeStyle = c.strokeColor ? c.strokeColor : "rgba(255,255,255,0)";
            d.draw(a)
        }
    }, getLayerTo: function (a) {
        return this.layerTo[a]
    }, getNameToValue: function (a) {
        return this.nameTo[a] ? this.nameTo[a] : a
    }
});
FR.Chart.MapHelper = {
    bitMapAttr: {}, svgMapAttr: {}, containsBitMap: function (a) {
        return !FR.isEmpty(this.bitMapAttr[a])
    }, containsSvgMap: function (a) {
        return !FR.isEmpty(this.svgMapAttr[a])
    }, addBitMapAttr: function (a, b) {
        this.bitMapAttr[a] = b
    }, addSvgMapAttr: function (a, b) {
        this.svgMapAttr[a] = b
    }, getBitMapAttr: function (a) {
        return this.bitMapAttr[a]
    }, getSvgMapAttr: function (a) {
        return this.svgMapAttr[a]
    }, getMapAttr: function (a, b) {
        return b ? this.getSvgMapAttr(a) : this.getBitMapAttr(a)
    }
};
FR.Chart.BoundsManager = function () {
    this.allBounds = []
};
$.extend(FR.Chart.BoundsManager.prototype, {
    addBounds: function (a) {
        this.allBounds.push(a)
    }, isInteract: function (c) {
        var b = this.allBounds.length;
        for (var a = 0; a < b; a++) {
            if (FR.Chart.ChartUtils.rectangleOverlapped(c, this.allBounds[a])) {
                return true
            }
        }
        return false
    }, isEmpty: function () {
        return this.allBounds.length === 0
    }
});
$.extend(FR.Chart, {
    ChartUtils: {
        compareDouble: function (c, b, a) {
            switch (a) {
                case FR.Chart.Compare.EQUALS:
                    return c === b;
                case FR.Chart.Compare.NOT_EQUAL:
                    return c !== b;
                case FR.Chart.Compare.GREATER_THAN:
                    return c > b - 1e-15;
                case FR.Chart.Compare.GREATER_THAN_OR_EQUAL:
                    return c >= b - 1e-15;
                case FR.Chart.Compare.LESS_THAN:
                    return c < b + 1e-15;
                case FR.Chart.Compare.LESS_THAN_OR_EQUAL:
                    return c <= b + 1e-15;
                default:
                    return false
            }
        }, retinaOptimization: function (d, c, g, b) {
            var a = window.devicePixelRatio || 1;
            var e = c.webkitBackingStorePixelRatio || c.mozBackingStorePixelRatio || c.msBackingStorePixelRatio || c.oBackingStorePixelRatio || c.backingStorePixelRatio || 1;
            var f = a / e;
            d.style.width = g + "px";
            d.style.height = b + "px";
            d.setAttribute("width", g * f);
            d.setAttribute("height", b * f);
            if (f !== 1) {
                c.scale(f, f)
            }
            c.clearRect(0, 0, g * f, b * f)
        }, inArray: function (c, b) {
            if (!c || (b == null || b == undefined)) {
                return false
            }
            for (var a = 0; a < c.length; a++) {
                if (c[a] == b) {
                    return true
                }
            }
            return false
        }, isIE11: function () {
            return FR.Browser.isIE11()
        }, isIE6Before: function () {
            return FR.Browser.isIE6Before()
        }, isIE9Later: function () {
            return FR.Browser.isIE9Later() || FR.Chart.ChartUtils.isIE11()
        }, isExcanvas: function () {
            return FR.Browser.isIE8Before()
        }, rectangle2RoundRectangle: function (d, a) {
            var c = 10;
            var b = new FR.Chart.RoundBounds(d.x, d.y, d.width, d.height, c, c);
            return a ? b : d
        }, date2Int: function (b, a) {
            if (b == null) {
                b = new Date()
            }
            var c = new Date("1970/01/01");
            return FR.Chart.ChartUtils.getTwoDay(b, c, a)
        }, int2Date: function (c, a) {
            var b = new Date("1970/01/01");
            var e = 24 * 60 * 60 * 1000;
            if (a == FR.Chart.Constants.Second) {
                e = 1000
            } else {
                if (a == FR.Chart.Constants.Minute) {
                    e = 60 * 1000
                } else {
                    if (a == FR.Chart.Constants.Hour) {
                        e = 60 * 60 * 1000
                    }
                }
            }
            var d = c * e + b.getTime();
            return new Date(d)
        }, getTwoDay: function (d, c, b) {
            var e = 24 * 60 * 60 * 1000;
            if (b == FR.Chart.Constants.Second) {
                e = 1000
            } else {
                if (b == FR.Chart.Constants.Minute) {
                    e = 60 * 1000
                } else {
                    if (b == FR.Chart.Constants.Hour) {
                        e = 60 * 60 * 1000
                    }
                }
            }
            var a = (d.getTime() - c.getTime()) / e;
            return Math.floor(a)
        }, isBelongToSameYear: function (b, a) {
            return b.getFullYear() === a.getFullYear()
        }, isBelongToSameMonth: function (b, a) {
            return FR.Chart.ChartUtils.isBelongToSameYear(b, a) && (b.getMonth() === a.getMonth())
        }, isBelongToSameDay: function (b, a) {
            return FR.Chart.ChartUtils.isBelongToSameMonth(b, a) && (b.getDate() === a.getDate())
        }, isBelongToSameHour: function (b, a) {
            return FR.Chart.ChartUtils.isBelongToSameDay(b, a) && (b.getHours() === a.getHours())
        }, isBelongToSameMinute: function (b, a) {
            return FR.Chart.ChartUtils.isBelongToSameHour(b, a) && (b.getMinutes() === a.getMinutes())
        }, isBelongToSameSecond: function (b, a) {
            return FR.Chart.ChartUtils.isBelongToSameMinute(b, a) && (b.getSeconds() === a.getSeconds())
        }, isBelongToSameUnit: function (c, b, a) {
            if (a == FR.Chart.Constants.DAY) {
                return FR.Chart.ChartUtils.isBelongToSameDay(c, b)
            } else {
                if (a == FR.Chart.Constants.MONTH) {
                    return FR.Chart.ChartUtils.isBelongToSameMonth(c, b)
                } else {
                    if (a == FR.Chart.Constants.Minute) {
                        return FR.Chart.ChartUtils.isBelongToSameMinute(c, b)
                    } else {
                        if (a == FR.Chart.Constants.Hour) {
                            return FR.Chart.ChartUtils.isBelongToSameHour(c, b)
                        } else {
                            if (a == FR.Chart.Constants.Second) {
                                return FR.Chart.ChartUtils.isBelongToSameSecond(c, b)
                            } else {
                                return FR.Chart.ChartUtils.isBelongToSameYear(c, b)
                            }
                        }
                    }
                }
            }
        }, getMiddleDate: function (a, b) {
            if (b === FR.Chart.Constants.DAY) {
                return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " 12:00:00")
            } else {
                if (b === FR.Chart.Constants.MONTH) {
                    return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + parseInt(a.getMonthDays() / 2) + " 00:00:00")
                } else {
                    if (b === FR.Chart.Constants.Minute) {
                        return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " " + a.getHours() + ":" + a.getMinutes() + ":30")
                    } else {
                        if (b === FR.Chart.Constants.Hour) {
                            return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " " + a.getHours() + ":30:00")
                        } else {
                            if (b === FR.Chart.Constants.Second) {
                                return a
                            } else {
                                return new Date(a.getFullYear() + "-06-30 00:00:00")
                            }
                        }
                    }
                }
            }
        }, getStartDate4Type: function (a, b) {
            if (b === FR.Chart.Constants.DAY) {
                return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " 00:00:00")
            } else {
                if (b === FR.Chart.Constants.MONTH) {
                    return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-01 00:00:00")
                } else {
                    if (b === FR.Chart.Constants.Minute) {
                        return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " " + a.getHours() + ":" + a.getMinutes() + ":00")
                    } else {
                        if (b === FR.Chart.Constants.Hour) {
                            return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " " + a.getHours() + ":00:00")
                        } else {
                            if (b === FR.Chart.Constants.Second) {
                                return a
                            } else {
                                return new Date(a.getFullYear() + "-01-01 00:00:00")
                            }
                        }
                    }
                }
            }
        }, getEndDate4Type: function (a, b) {
            if (b === FR.Chart.Constants.DAY) {
                return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " 23:59:59")
            } else {
                if (b === FR.Chart.Constants.MONTH) {
                    return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getMonthDays() + " 23:59:59")
                } else {
                    if (b === FR.Chart.Constants.Minute) {
                        return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " " + a.getHours() + ":" + a.getMinutes() + ":59")
                    } else {
                        if (b === FR.Chart.Constants.Hour) {
                            return new Date(a.getFullYear() + "-" + (a.getMonth() + 1) + "-" + a.getDate() + " " + a.getHours() + ":59:59")
                        } else {
                            if (b === FR.Chart.Constants.Second) {
                                return a
                            } else {
                                return new Date(a.getFullYear() + "-12-31 23:59:59")
                            }
                        }
                    }
                }
            }
        }, calculateAdjustDateRange: function (a, b) {
            if (b === FR.Chart.Constants.DAY) {
                return FR.contentFormat(a, "Dyyyy-MM-dd")
            } else {
                if (b === FR.Chart.Constants.MONTH) {
                    return FR.contentFormat(a, "Dyyyy-MM")
                } else {
                    if (b === FR.Chart.Constants.Minute) {
                        return FR.contentFormat(a, "Dyyyy-MM-dd hh:mm")
                    } else {
                        if (b === FR.Chart.Constants.Hour) {
                            return FR.contentFormat(a, "Dyyyy-MM-dd hh")
                        } else {
                            if (b === FR.Chart.Constants.Second) {
                                return FR.contentFormat(a, "Dyyyy-MM-dd hh:mm:ss")
                            } else {
                                return FR.contentFormat(a, "Dyyyy")
                            }
                        }
                    }
                }
            }
        }, object2Date: function (c, a) {
            var b = null;
            if (c instanceof Date) {
                b = c
            } else {
                if (typeof(c) == typeof("")) {
                    if (c.indexOf(".0") == c.length - 2) {
                        c = c.substring(0, c.length - 2)
                    }
                    b = new Date(Date.parse(c.replace(/-|\./g, "/")))
                } else {
                    if (typeof(c) == typeof(0)) {
                        b = FR.Chart.ChartUtils.int2Date(c, a)
                    }
                }
            }
            return b
        }, string2Date: function (f) {
            f = f.replace(/-/g, "/");
            var n = new Date(f);
            if (!isNaN(n)) {
                return n
            }
            var e = 1970;
            var p = 0;
            var h = 1;
            var d = 0;
            var g = 0;
            var q = 0;
            var m = new Date();
            var c = m.getTimezoneOffset();
            var l = f.split(" ");
            var r = l[0];
            var s = r.split("/");
            for (var j = 0, o = s.length; j < o;
                 j++) {
                if (j === 0) {
                    e = s[0]
                } else {
                    if (j === 1) {
                        p = s[1]
                    } else {
                        if (j === 2) {
                            h = s[2]
                        }
                    }
                }
            }
            if (l.length === 2) {
                var b = l[1];
                var a = b.split(":");
                for (var j = 0, k = a.length; j < k; j++) {
                    if (j === 0) {
                        d = a[0]
                    } else {
                        if (j === 1) {
                            g = a[1]
                        } else {
                            if (j === 2) {
                                q = a[2]
                            } else {
                                if (j === 3) {
                                    c = a[3]
                                }
                            }
                        }
                    }
                }
            }
            e = e || m.getFullYear();
            p = (p - 1) || m.getMonth();
            h = h || m.getDay();
            d = d ? d : 0;
            g = g ? g : 0;
            q = q ? q : 0;
            c = c ? c : m.getTimezoneOffset();
            return new Date(e, p, h, d, g, q, c)
        }, accDateFormat: function (d, f) {
            var i = "Dyyyy-MM-dd HH:mm:ss";
            var c = "Dyyyy-MM-dd HH:mm";
            var a = "Dyyyy-MM-dd HH";
            var h = "Dyyyy-MM-dd";
            var g = "Dyyyy-MM";
            var e = "Dyyyy";
            var b = f > 1 ? false : true;
            if (d == FR.Chart.Constants.Second) {
                return i
            } else {
                if (d == FR.Chart.Constants.Minute) {
                    if (b) {
                        return i
                    } else {
                        return c
                    }
                } else {
                    if (d == FR.Chart.Constants.Hour) {
                        if (b) {
                            return c
                        } else {
                            return a
                        }
                    } else {
                        if (d == FR.Chart.Constants.DAY) {
                            if (b) {
                                return a
                            } else {
                                return h
                            }
                        } else {
                            if (d == FR.Chart.Constants.MONTH) {
                                if (b) {
                                    return h
                                } else {
                                    return g
                                }
                            } else {
                                if (d == FR.Chart.Constants.YEAR) {
                                    if (b) {
                                        return g
                                    } else {
                                        return e
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }, accFormat: function (a) {
            if (a == null) {
                return "#0.00"
            }
            a += "";
            if (a.indexOf(".") < 0) {
                return a + ".0"
            } else {
                return a.replace(/\./, ".0")
            }
        }, generalFormat: function (a) {
            return "" + parseFloat(a)
        }, accNumber: function (value) {
            var sv = "" + parseFloat(value);
            var ev = "";
            if (sv.indexOf(".") < 0) {
                return value
            }
            if (sv.indexOf("e") >= 0 || sv.indexOf("E") >= 0) {
                var e = sv.indexOf("e") >= 0 ? sv.indexOf("e") : sv.indexOf("E");
                ev = sv.substring(e);
                sv = sv.substring(0, e)
            }
            var s = sv.substring(sv.indexOf("."));
            var l = s.length;
            var start = 1;
            while (start < l) {
                if (s.substr(start, 3) == "999") {
                    s = s.substring(0, start);
                    var d = ".000000000000000000000000000000000".substring(0, s.length - 1) + "1";
                    s = "0" + s.substring(1);
                    if (d.indexOf(".") >= 0) {
                        d = "0" + d.substring(1)
                    }
                    var w = sv.substring(0, sv.indexOf("."));
                    if (w == "") {
                        w = "0"
                    }
                    for (var i = 0; i < start - 1; i++) {
                        w += "0"
                    }
                    var op = "+";
                    if (value < 0) {
                        op = "-"
                    }
                    var tmp = eval(+s + "+" + +d);
                    var res = eval(+w + op + tmp).toString();
                    if (value < 0 && res.length < w.length) {
                        while (res.length < w.length) {
                            res = res.substr(0, 1) + "0" + res.substr(1)
                        }
                    } else {
                        if (value > 0 && res.length < w.length) {
                            while (res.length < w.length) {
                                res = "0" + res
                            }
                        }
                    }
                    res = res.substr(0, res.length - start + 1) + "." + res.substr(res.length - start + 1);
                    return res + ev
                } else {
                    if (s.substr(start, 3) == "000") {
                        if (value < 0.001) {
                            while (s.charAt(start) == "0") {
                                start++
                            }
                            while (start < s.length && s.charAt(start) != "0") {
                                start++
                            }
                        }
                        return sv.substring(0, sv.indexOf(".") + start) + ev
                    }
                }
                start++
            }
            return value
        }, dealLabelStringAutoWrap: function (c, b, f) {
            var g = "";
            var a = "";
            for (var d = 0; d < c.length; d++) {
                var e = c.charAt(d);
                a += e;
                var h = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a + " ", b);
                if (h.width > f && e != "\\") {
                    g += (a + "\n");
                    a = ""
                }
            }
            g += a;
            return g
        }, dealTitleStringAutoWrap: function (c, b, f) {
            var g = "";
            var a = "";
            for (var d = 0; d < c.length; d++) {
                var e = c.charAt(d);
                a += e;
                var h = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, b);
                if (h.width > f && e != "\\") {
                    g += (a.substring(0, a.length - 1) + "\n");
                    a = a.charAt(a.length - 1)
                }
            }
            g += a;
            return g
        }, createFillColorArray: function (b, e) {
            var a = [e];
            if (b == null || !b.colorStyle || b.colorStyle == FR.Chart.Constants.Color_DEFAULT) {
                var c = FR.Chart.CurrentPreStyle;
                if (!c || c.colorStyle == FR.Chart.Constants.Color_DEFAULT) {
                    for (var d = 0; d < e; d++) {
                        a[d] = FR.Chart.ChartCoreConstants.CHART_Color_ARRAY[d % FR.Chart.ChartCoreConstants.CHART_Color_ARRAY.length]
                    }
                } else {
                    return FR.Chart.ChartUtils.createFillColorArray(c, e)
                }
            } else {
                if (b.colorStyle === FR.Chart.Constants.Color_ACC) {
                    for (var d = 0; d < e; d++) {
                        a[d] = b.getColorIndex(d)
                    }
                } else {
                    if (b.colorStyle === FR.Chart.Constants.Color_GRADIENT && b.getColorSize() === 2) {
                        for (var d = 0; d < e; d++) {
                            a[d] = FR.Chart.ChartUtils.getSeriesColor(b.getColorIndex(0), b.getColorIndex(1), d, e)
                        }
                    }
                }
            }
            return a
        }, getSaturationSeriesColor: function (b, c, e) {
            if (e <= 1) {
                return b
            }
            var d = FR.Chart.Color.getColorArray(b);
            var a = FR.Chart.Color.RGB2HSB(d[0], d[1], d[2]);
            if (d[0] == d[1] && d[1] == d[2]) {
                a[2] = 0.9 - (0.8 / (e - 1)) * c
            } else {
                a[1] = 1 - (0.9 / (e - 1)) * c
            }
            return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], a[1], a[2]))
        }, getSeriesColor: function (g, b, f, e) {
            if (e <= 1) {
                return g
            }
            var h = FR.Chart.Color.getColorArray(g);
            var a = FR.Chart.Color.RGB2HSB(h[0], h[1], h[2]);
            h = FR.Chart.Color.getColorArray(b);
            var c = FR.Chart.Color.RGB2HSB(h[0], h[1], h[2]);
            var j = [3];
            for (var d = 0; d < 3; d++) {
                j[d] = (a[d] - ((a[d] - c[d]) / (e - 1)) * f)
            }
            return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(j[0] - Math.floor(j[0]), j[1], j[2]))
        }, rectangleOverlapped: function (f, c) {
            if (f == null || c == null) {
                return false
            }
            var b = Math.max(f.x, c.x);
            var a = Math.max(f.y, c.y);
            var e = Math.min(f.x + f.width, c.x + c.width);
            var d = Math.min(f.y + f.height, c.y + c.height);
            return (b <= e && a <= d)
        }, getPosition: function (a) {
            if (isNaN(parseInt(a))) {
                return FR.Chart.Position[a]
            }
            return a
        }, getFillColorStyle: function (a) {
            if (isNaN(parseInt(a))) {
                return FR.Chart.FillStyle[a]
            }
            return a
        }, sortPie3DSide: function (e, d) {
            if (!e || !d) {
                return 1
            }
            var g = e.isStart ? e.cylinder.start : e.cylinder.start + e.cylinder.extent;
            var c = d.isStart ? d.cylinder.start : d.cylinder.start + d.cylinder.extent;
            var h = Math.abs(g - 180 / 2) % 360;
            var f = Math.abs(c - 180 / 2) % 360;
            h = h > 180 ? 360 - h : h;
            f = f > 180 ? 360 - f : f;
            if (Math.abs(h - f) < 0.05) {
                if (e.cylinder.extent !== 0) {
                    if (e.isStart) {
                        g = e.cylinder.start + e.cylinder.extent / Math.abs(e.cylinder.extent)
                    } else {
                        g = e.cylinder.start + e.cylinder.extent - e.cylinder.extent / Math.abs(e.cylinder.extent)
                    }
                }
                if (d.cylinder.extent !== 0) {
                    if (d.isStart) {
                        c = d.cylinder.start + d.cylinder.extent / Math.abs(d.cylinder.extent)
                    } else {
                        c = d.cylinder.start + d.cylinder.extent - d.cylinder.extent / Math.abs(d.cylinder.extent)
                    }
                }
                h = Math.abs(g - 180 / 2) % 360;
                f = Math.abs(c - 180 / 2) % 360;
                h = h > 180 ? 360 - h : h;
                f = f > 180 ? 360 - f : f
            }
            if (h < f) {
                return -1
            } else {
                if (h > f) {
                    return 1
                } else {
                    return 0
                }
            }
        }
    }, ChartEase: {
        easeInBack: function (e, a, h, g) {
            var f = 1.70158;
            return h * (e /= g) * e * ((f + 1) * e - f) + a
        }, easeInCirc: function (e, a, g, f) {
            return -g * (Math.sqrt(1 - (e /= f) * e) - 1) + a
        }, easeOutExpo: function (e, a, g, f) {
            return (e == f) ? a + g : g * (-Math.pow(2, -10 * e / f) + 1) + a
        }, easeOutCirc: function (e, a, g, f) {
            return g * Math.sqrt(1 - (e = e / f - 1) * e) + a
        }, easeOutBounce: function (e, a, g, f) {
            if ((e /= f) < (1 / 2.75)) {
                return g * (7.5625 * e * e) + a
            } else {
                if (e < (2 / 2.75)) {
                    return g * (7.5625 * (e -= (1.5 / 2.75)) * e + 0.75) + a
                } else {
                    if (e < (2.5 / 2.75)) {
                        return g * (7.5625 * (e -= (2.25 / 2.75)) * e + 0.9375) + a
                    } else {
                        return g * (7.5625 * (e -= (2.625 / 2.75)) * e + 0.984375) + a
                    }
                }
            }
        }, easeOutQuint: function (e, a, g, f) {
            return g * ((e = e / f - 1) * e * e * e * e + 1) + a
        }
    }, Color: {
        FACTOR: 0.7, rgb2hex: function (b) {
            if (b.charAt(0) == "#") {
                return b
            }
            var e = "0" + b;
            var d = e.split(/\D+/);
            var a = Number(d[1]) * 65536 + Number(d[2]) * 256 + Number(d[3]);
            var c = a.toString(16);
            while (c.length < 6) {
                c = "0" + c
            }
            return "#" + c
        }, getColorArray: function (a) {
            if (/^#[0-9a-f]{6}$/i.test(a)) {
                return FR.Chart.Color.Map([a.substr(1, 2), a.substr(3, 2), a.substr(5, 2)], function (c) {
                    return parseInt(c, 16)
                })
            } else {
                if (/^#[0-9a-f]{3}$/i.test(a)) {
                    return FR.Chart.Color.Map([a.substr(1, 1), a.substr(2, 1), a.substr(3, 1)], function (c) {
                        return parseInt(c + c, 16)
                    })
                } else {
                    if (/^rgb(.*)$/i.test(a)) {
                        return FR.Chart.Color.Map(a.match(/\d+(\.\d+)?\%?/g), function (c) {
                            return parseInt(c.indexOf("%") > 0 ? parseFloat(c, 10) * 2.55 : c, 10)
                        })
                    } else {
                        var b = {
                            "red": "#FF0000",
                            "white": "#FFFFFF",
                            "black": "#000000",
                            "gray": "#D0D0D0",
                            "green": "#00EC00",
                            "blue": "#0000C6"
                        };
                        a = b[a.toLowerCase()];
                        if (a) {
                            return FR.Chart.Color.Map([a.substr(1, 2), a.substr(3, 2), a.substr(5, 2)], function (c) {
                                return parseInt(c, 16)
                            })
                        }
                    }
                }
            }
        }, getHex: function (a) {
            var b = FR.Chart.Color.getColorArray(a);
            return ~~(b[0]) << 16 ^ ~~(b[1]) << 8 ^ ~~(b[2])
        }, Map: function (f, e, b) {
            if (f.map) {
                return f.map(e, b)
            } else {
                var d = [];
                for (var c = 0, a = f.length; c < a; c++) {
                    d.push(e.call(b, f[c], c, f))
                }
                return d
            }
        }, getColor: function (b) {
            for (var a = 0; a < b.length; a++) {
                b[a] = parseInt(b[a])
            }
            if (b.length === 4) {
                return "rgba(" + b + ")"
            } else {
                return "rgb(" + b + ")"
            }
        }, getColorWithAlpha: function (b, c) {
            for (var a = 0; a < b.length; a++) {
                b[a] = parseInt(b[a])
            }
            return "rgba(" + b + "," + c + ")"
        }, darker: function (a) {
            var b = FR.Chart.Color.getColorArray(a);
            b[0] = Math.max(Math.round(b[0] * FR.Chart.Color.FACTOR), 0);
            b[1] = Math.max(Math.round(b[1] * FR.Chart.Color.FACTOR), 0);
            b[2] = Math.max(Math.round(b[2] * FR.Chart.Color.FACTOR), 0);
            return FR.Chart.Color.getColor(b)
        }, saturationDown: function (b) {
            var c = FR.Chart.Color.getColorArray(b);
            var a = FR.Chart.Color.RGB2HSB(c[0], c[1], c[2]);
            a[1] *= 0.3;
            return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], a[1], a[2]))
        }, RGB2HSB: function (a, e, i) {
            var j = [3];
            var k = (a > e) ? a : e;
            if (i > k) {
                k = i
            }
            var f = (a < e) ? a : e;
            if (i < f) {
                f = i
            }
            brightness = k / 255;
            if (k !== 0) {
                saturation = (k - f) / k
            } else {
                saturation = 0
            }
            if (saturation === 0) {
                hue = 0
            } else {
                var c = (k - a) / (k - f);
                var h = (k - e) / (k - f);
                var d = (k - i) / (k - f);
                if (a == k) {
                    hue = d - h
                } else {
                    if (e == k) {
                        hue = 2 + c - d
                    } else {
                        hue = 4 + h - c
                    }
                }
                hue = hue / 6;
                if (hue < 0) {
                    hue = hue + 1
                }
            }
            j[0] = hue;
            j[1] = saturation;
            j[2] = brightness;
            return j
        }, HSB2RGB: function (k, e, n) {
            if (e < 0) {
                e = 0
            } else {
                if (e > 1) {
                    e = 1
                }
            }
            if (n < 0) {
                n = 0
            } else {
                if (n > 1) {
                    n = 1
                }
            }
            var a = 0, j = 0, o = 0;
            if (e === 0) {
                a = j = o = n * 255 + 0.5
            } else {
                var i = (k - Math.floor(k)) * 6;
                var l = i - Math.floor(i);
                var d = n * (1 - e);
                var c = n * (1 - e * l);
                var s = n * (1 - (e * (1 - l)));
                switch (Math.floor(i)) {
                    case 0:
                        a = n * 255 + 0.5;
                        j = s * 255 + 0.5;
                        o = d * 255 + 0.5;
                        break;
                    case 1:
                        a = c * 255 + 0.5;
                        j = n * 255 + 0.5;
                        o = d * 255 + 0.5;
                        break;
                    case 2:
                        a = d * 255 + 0.5;
                        j = n * 255 + 0.5;
                        o = s * 255 + 0.5;
                        break;
                    case 3:
                        a = d * 255 + 0.5;
                        j = c * 255 + 0.5;
                        o = n * 255 + 0.5;
                        break;
                    case 4:
                        a = s * 255 + 0.5;
                        j = d * 255 + 0.5;
                        o = n * 255 + 0.5;
                        break;
                    case 5:
                        a = n * 255 + 0.5;
                        j = d * 255 + 0.5;
                        o = c * 255 + 0.5;
                        break
                }
            }
            var m = [];
            m.push(a);
            m.push(j);
            m.push(o);
            return m
        }, Hex2RGB: function (c) {
            var d = [];
            if (!!c) {
                if (c.charAt(0) == "#") {
                    var f = parseInt(c.substr(1, 2), 16);
                    var e = parseInt(c.substr(3, 2), 16);
                    var a = parseInt(c.substr(5, 2), 16);
                    d.push(f);
                    d.push(e);
                    d.push(a);
                    return d
                } else {
                    return FR.Chart.Color.getColorArray(c)
                }
            }
        }, Hex2fRGB: function (c) {
            var d = [];
            if (c && c.length === 7 && c.charAt(0) == "#") {
                var f = parseInt(c.substr(1, 2), 16);
                var e = parseInt(c.substr(3, 2), 16);
                var a = parseInt(c.substr(5, 2), 16);
                d.push(f / 255);
                d.push(e / 255);
                d.push(a / 255);
                return d
            }
        }, rgb2Hex: function (f) {
            var e = /rgba?\((\d{1,3}),(\d{1,3}),(\d{1,3})(,([.\d]+))?\)/, j, i, c, d,
                h = f.replace(/\s+/g, "").match(e);
            if (h) {
                j = (+h[1]).toString(16);
                j = j.length === 1 ? "0" + j : j;
                i = (+h[2]).toString(16);
                i = i.length === 1 ? "0" + i : i;
                c = (+h[3]).toString(16);
                c = c.length === 1 ? "0" + c : c;
                d = (+(h[5] ? h[5] : 1)) * 100;
                return {hex: "#" + j + i + c, alpha: Math.ceil(d)}
            } else {
                return {hex: f, alpha: 100}
            }
        }, getShadeStartColor: function (g, f) {
            var b = [];
            if (g.charAt(0) == "#") {
                b = FR.Chart.Color.Hex2fRGB(g)
            } else {
                b = FR.Chart.Color.getColorArray(g);
                for (var d = 0; d < b.length; d++) {
                    b[d] /= 255
                }
            }
            var a = [];
            for (var e = 0; e < b.length; e++) {
                var c = b[e];
                if (c <= 0.5) {
                    a.push(2 * c * (1 - f))
                } else {
                    a.push(1 - 2 * (1 - c) * f)
                }
            }
            for (var d = 0; d < a.length; d++) {
                a[d] = parseInt(a[d] * 255)
            }
            return FR.Chart.Color.getColor(a)
        }, getShadeEndColor: function (g, f) {
            var b = [];
            if (g.charAt(0) == "#") {
                b = FR.Chart.Color.Hex2fRGB(g)
            } else {
                b = FR.Chart.Color.getColorArray(g);
                for (var d = 0; d < b.length; d++) {
                    b[d] /= 255
                }
            }
            var a = [];
            for (var e = 0; e < b.length; e++) {
                var c = b[e];
                if (c <= 0.5) {
                    a[e] = 2 * c * f
                } else {
                    a[e] = 1 - 2 * (1 - c) * (1 - f)
                }
            }
            for (var d = 0; d < a.length; d++) {
                a[d] = parseInt(a[d] * 255)
            }
            return FR.Chart.Color.getColor(a)
        }, brighter: function (a) {
            return FR.Chart.Color.brighterWithFactor(a, FR.Chart.Color.FACTOR)
        }, brighterWithFactor: function (c, e) {
            var j = FR.Chart.Color.getColorArray(c);
            var h = j[0];
            var f = j[1];
            var a = j[2];
            var d = 1 / (1 - e);
            if (h === 0 && f === 0 && a === 0) {
                d = Math.round(d);
                j[0] = d;
                j[1] = d;
                j[2] = d;
                return FR.Chart.Color.getColor(j)
            }
            if (h > 0 && h < d) {
                h = d
            }
            if (f > 0 && f < d) {
                f = d
            }
            if (a > 0 && a < d) {
                a = d
            }
            var k = [];
            k.push(Math.min(Math.round(h / e), 255));
            k.push(Math.min(Math.round(f / e), 255));
            k.push(Math.min(Math.round(a / e), 255));
            return FR.Chart.Color.getColor(k)
        }, getIntValue: function (c) {
            var f = FR.Chart.Color.getColorArray(c);
            var e = f[0];
            var d = f[1];
            var a = f[2];
            return ((255 & 255) << 24) | ((e & 255) << 16) | ((d & 255) << 8) | ((a & 255) << 0)
        }, getRint: function (a) {
            return (a >> 16) & 255
        }, getGint: function (a) {
            return (a >> 8) & 255
        }, getBint: function (a) {
            return (a >> 0) & 255
        }, getAint: function (a) {
            return (a >> 24 & 255)
        }, getR: function (a) {
            return (FR.Chart.Color.getIntValue(a) >> 16) & 255
        }, getG: function (a) {
            return (FR.Chart.Color.getIntValue(a) >> 8) & 255
        }, getB: function (a) {
            return (FR.Chart.Color.getIntValue(a) >> 0) & 255
        }, getA: function (a) {
            return (FR.Chart.Color.getIntValue(a) >> 24 & 255)
        }
    }, PaintUtils: {
        paintContent: function (f, h, e, d, c, g, b, a) {
            f.save();
            this.setContextFont(f, e);
            this.setContextBaseLine(f, e);
            if (e.alignText == FR.Chart.Style.VERTICALTEXT) {
                this.paintVerticalString(f, h, e, d, c, g, b, a)
            } else {
                if (e.rotation !== 0) {
                    this.paintRotationString(f, h, e, d, c, g, b, a)
                } else {
                    this.paintNormalString(f, h, e, d, c, g, b, a)
                }
            }
            f.restore()
        }, paintNormalString: function (b, i, g, e, d, a, j, m) {
            var h = this.isOffSetY4SomeFont(b, g.frFont);
            if (b.useRight) {
                var c = b.textAlign || "left";
                b.textAlign = "right";
                b.fillText(i, e + a, d + h);
                b.textAlign = c
            } else {
                if (b.notUseDivText) {
                    b.fillText(i, e, d + h)
                } else {
                    var l = false;
                    if (typeof(i) == "string") {
                        l = i.indexOf("%") !== -1
                    }
                    var f = ((FR.Chart.ChartUtils.isIE9Later()) || l) ? 2 : 0;
                    var k = $("<div>" + i + "</div>").css("position", "absolute").css("font", b.font).css("color", b.fillStyle).css("white-space", "nowrap").css("left", e).css("top", d + h).css("width", a + f).css("height", j);
                    FR.Chart.DivCon.addDiv(m, k[0])
                }
            }
        }, paintRotationString: function (c, k, i, g, e, b, l, n) {
            var d = i.rotation;
            var a = Math.PI / 180;
            var j = this.isOffSetY4SomeFont(c, i.frFont);
            c.translate(g, e);
            var h = FR.Chart.GraphHelper.stringDimension(k, i.frFont, 0);
            var m = h.width * Math.sin(d * a);
            if (d > 0) {
                c.translate(0, m)
            }
            var f = -d * a;
            c.rotate(f);
            c.fillText(k, 0, j);
            c.fillText(k, 0, j);
            c.rotate(-f);
            if (d > 0) {
                c.translate(0, -m)
            }
            c.translate(-g, -e)
        }, paintVerticalString: function (b, l, h, f, e, a, m, o) {
            var k = this.isOffSetY4SomeFont(b, h.frFont);
            var j = 0;
            b.save();
            var n = 90 * Math.PI / 180;
            for (var d = 0; d < l.length; d++) {
                var c = l.charAt(d);
                var g = FR.Chart.GraphHelper.stringDimension(c, h.frFont, 0);
                if (l.charCodeAt(d) > 127 && c != FR.Chart.Constants.ESP) {
                    b.fillText(c, f, e + j);
                    j += g.height
                } else {
                    b.rotate(n);
                    b.fillText(c, e + j, -f - h.frFont.size + k);
                    j += g.width;
                    b.rotate(-n)
                }
            }
            b.restore()
        }, isOffSetY4SomeFont: function (a, c) {
            if (FR.Browser.r.webkit || FR.Browser.r.gecko || FR.Browser.isIE()) {
                var b = a.font;
                if (b && (b.indexOf("Microsoft YaHei") !== -1 || b.indexOf(FR.i18nText("Chart-Use_MSBold")) !== -1 || b.indexOf("Century Gothic") != -1)) {
                    var d = 12 / 5;
                    if (c && c.size) {
                        d = c.size / 5
                    }
                    return -d
                }
            }
            return 0
        }, setContextFont: function (c, b) {
            if (b.frFont == null) {
                c.font = "12px Simsun";
                c.fillStyle = "black"
            } else {
                var a = b.frFont;
                c.font = a.style + " " + parseInt(a.size) + "px  " + a.fontName;
                c.fillStyle = a.color
            }
        }, isNeedToolTip4AxisLabel: function (e, a, b, f) {
            var c = FR.Chart.TextUtils.calculateTextDimensionWithRotation(e, a);
            var d = 0;
            if (f) {
                return parseFloat(Number(c.height).toFixed(2)) > parseFloat(Number(b.height + d).toFixed(2))
            } else {
                return parseFloat(Number(c.width).toFixed(2)) > parseFloat(Number(b.width + d).toFixed(2))
            }
        }, paintTooltip: function (c, p, g, f, n) {
            var b = 6;
            var a = 5;
            c.save();
            var d = "black";
            if (n == "black") {
                d = "white"
            }
            c.fillStyle = d;
            c.textBaseline = "top";
            var k = g;
            var j = f + b;
            var m = 0;
            for (var e = 0; e < p.length; e++) {
                var l = p[e];
                c.font = l.font.style + " " + l.font.size + "px " + l.font.fontName;
                var o = this.isOffSetY4SomeFont(c, l.font);
                if (l.rightAlign) {
                    var h = (l.width - l.realWidth) > 0 ? l.width - l.realWidth : 0;
                    c.fillText(l.value, k + h, j + o)
                } else {
                    c.fillText(l.value, k, j + o)
                }
                k += l.width;
                m = Math.max(m, l.height);
                if (l.newLine) {
                    k = g;
                    j += m + a
                }
            }
            c.restore()
        }, paintTooltip4Series: function (b, e, r, q, f, k) {
            var d = 6;
            var s = 5;
            b.save();
            var n = "black";
            if (f == "black") {
                n = "white"
            }
            b.fillStyle = n;
            b.textBaseline = "top";
            var l = r;
            var j = q + d;
            var c = 0;
            var g = k.length;
            for (var o = 0; o < e.length; o++) {
                var m = e[o];
                b.font = m.font.style + " " + m.font.size + "px " + m.font.fontName;
                var p = this.isOffSetY4SomeFont(b, m.font);
                if (m.rightAlign) {
                    var a = (m.width - m.realWidth) > 0 ? m.width - m.realWidth : 0;
                    b.fillText(m.value, l + a, j + p)
                } else {
                    b.fillText(m.value, l, j + p)
                }
                l += m.width;
                c = Math.max(c, m.height);
                if (m.newLine) {
                    l = r + 6;
                    j += c + s;
                    var h = new FR.Chart.Arc2D(l, j + c / 3, 3, 0, 360, FR.Chart.Arc2D.CHORD);
                    g--;
                    if (g >= 0) {
                        b.fillStyle = k[g]
                    }
                    h.paint(b);
                    l += 5;
                    b.fillStyle = n
                }
            }
            b.restore()
        }, setContextBaseLine: function (c, b) {
            if (navigator.userAgent.indexOf("Opera") != -1) {
                c.canvas.__rgraph_valign__ = b.verticalAlignment;
                c.canvas.__rgraph_halign__ = b.horizontalAlignment
            }
            c.textBaseline = "top";
            var a = b.horizontalAlignment;
            if (a == FR.Chart.Constants.LEFT) {
                c.textAlign = "left"
            } else {
                if (a == FR.Chart.Constants.CENTER) {
                    c.textAlign = "center"
                } else {
                    if (a == FR.Chart.Constants.RIGHT) {
                        c.textAlign = "right"
                    }
                }
            }
        }
    }, GraphHelper: {
        ctx: null, isDrawingEnd: true, isBoundsNaN: function (a) {
            return !a || isNaN(a.x) || isNaN(a.y) || isNaN(a.width) || isNaN(a.height)
        }, draw: function (a, c, b) {
            if (!a) {
                return
            }
            a.save();
            a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(b);
            c.draw(a);
            a.restore()
        }, dealRectShape4JSDraw: function (a) {
            if (a) {
                var b = new FR.Chart.Bounds();
                b.x = Math.round(a.x) + 0.5;
                b.y = Math.round(a.y) + 0.5;
                b.width = Math.round(a.width - 0.5);
                b.height = Math.round(a.height - 0.5);
                return b
            }
            return a
        }, dealRectShape4JSPaint: function (a) {
            if (a) {
                var b = new FR.Chart.Bounds();
                b.x = Math.round(a.x);
                b.y = Math.round(a.y);
                b.width = Math.round(a.width);
                b.height = Math.round(a.height);
                return b
            }
            return a
        }, dealLine4JSDraw: function (c) {
            if (c) {
                var b = c.startPoint;
                var a = c.endPoint;
                if (b) {
                    b.x = Math.round(b.x) + 0.5;
                    b.y = Math.round(b.y) + 0.5
                }
                if (a) {
                    a.x = Math.round(a.x) + 0.5;
                    a.y = Math.round(a.y) + 0.5
                }
            }
        }, stringDimension: function (e, a, k) {
            if (e && a) {
                var b = e.length * a.size;
                if (FR.Chart.GraphHelper.ctx) {
                    var h = FR.Chart.GraphHelper.ctx.font;
                    var j = a.style + " " + a.size + "px " + a.fontName;
                    FR.Chart.GraphHelper.ctx.font = j;
                    if (FR.Chart.GraphHelper.ctx.measureText) {
                        var g = FR.Chart.GraphHelper.ctx.measureText(e).width;
                        if (!isNaN(g)) {
                            b = g
                        }
                    }
                    FR.Chart.GraphHelper.ctx.font = h;
                    if (b === 0 && !FR.isEmpty(e)) {
                        b = FR.Chart.GraphHelper.stringDimensionWidthDiv(e, a).width
                    }
                } else {
                    var i = this.getNumberInt(e);
                    if (!isNaN(i)) {
                        b = b - i * a.size * 0.3
                    }
                }
                var d = k * Math.PI / 180;
                var c = new FR.Chart.Dimension2D();
                c.width = b * Math.abs(Math.cos(d)) + a.size * Math.abs(Math.sin(d));
                c.height = b * Math.abs(Math.sin(d)) + a.size * Math.abs(Math.cos(d));
                return c
            }
            return new FR.Chart.Dimension2D()
        }, stringDimensionWidthDiv: function (e, b) {
            if (!DIV_CONTAINER) {
                DIV_CONTAINER = document.createElement("div");
                document.body.appendChild(DIV_CONTAINER)
            }
            DIV_CONTAINER.style.cssText = "";
            DIV_CONTAINER.style.visibility = "hidden";
            DIV_CONTAINER.style.whiteSpace = "nowrap";
            DIV_CONTAINER.style.position = "absolute";
            DIV_CONTAINER.style.display = "";
            DIV_CONTAINER.style.fontFamily = b.fontName;
            DIV_CONTAINER.style.fontSize = b.size + "px";
            DIV_CONTAINER.style.fontWeight = b.style;
            DIV_CONTAINER.innerHTML = e;
            var d = DIV_CONTAINER.offsetWidth || 0;
            var a = DIV_CONTAINER.offsetHeight || 0;
            var c = {width: d, height: a};
            DIV_CONTAINER.style.display = "none";
            return c
        }, getNumberInt: function (c) {
            var e = 0;
            for (var d = 0, a = c.length; d < a; d++) {
                var b = c.charAt(d);
                if (!isNaN(b) || b == "," || b == "." || b == ";" || b == "  " || b == "_" || (b >= "a" && b <= "z" || (b >= "A" && b <= "Z"))) {
                    e++
                }
            }
            return e
        }, calculateTooltipDimension: function (l) {
            var c = new FR.Chart.Dimension2D();
            var j = -1;
            for (var d = 0; d < l.length; d++) {
                var f = this.stringDimension(l[d].value, l[d].font, 0);
                l[d].width = f.width;
                l[d].height = f.height;
                if (l[d].rightAlign) {
                    j = Math.max(l[d].width, j)
                }
                if (FR.Browser.isIE8Before()) {
                    if (l[d].value.indexOf(",") != -1) {
                        if (l[d].width < l[d].font.size - 1) {
                            l[d].width = l[d].font.size - 1
                        }
                    } else {
                        if (l[d].value.indexOf(":") != -1) {
                            if (l[d].width < l[d].font.size - 1) {
                                l[d].width = l[d].font.size - 1
                            }
                        }
                    }
                }
            }
            var a = 4;
            var k = 0;
            var b = 0;
            var e = 0;
            var h = 0;
            if (j != -1) {
                for (var d = 0; d < l.length; d++) {
                    if (l[d].rightAlign) {
                        l[d].realWidth = l[d].width;
                        l[d].width = j
                    }
                }
            }
            for (var d = 0; d < l.length; d++) {
                var g = l[d];
                h = Math.max(h, g.height);
                e += g.width;
                if (g.newLine) {
                    b = Math.max(b, e);
                    e = 0;
                    k += h + a
                } else {
                    if (d == l.length - 1) {
                        k += h
                    }
                    b = Math.max(b, e)
                }
            }
            c.width = b;
            c.height = k;
            return c
        }, calculateTooltipDimension4Series: function (l) {
            var c = new FR.Chart.Dimension2D();
            var j = -1;
            for (var d = 0; d < l.length; d++) {
                var f = this.stringDimension(l[d].value, l[d].font, 0);
                l[d].width = f.width;
                l[d].height = f.height;
                if (l[d].rightAlign) {
                    j = Math.max(l[d].width, j)
                }
                if (FR.Browser.isIE8Before()) {
                    if (l[d].value.indexOf(",") != -1) {
                        if (l[d].width < l[d].font.size - 1) {
                            l[d].width = l[d].font.size - 1
                        }
                    } else {
                        if (l[d].value.indexOf(":") != -1) {
                            if (l[d].width < l[d].font.size - 1) {
                                l[d].width = l[d].font.size - 1
                            }
                        }
                    }
                }
            }
            var a = 4;
            var k = 0;
            var b = 0;
            var e = 0;
            var h = 0;
            if (j != -1) {
                for (var d = 0; d < l.length; d++) {
                    if (l[d].rightAlign) {
                        l[d].realWidth = l[d].width;
                        l[d].width = j
                    }
                }
            }
            for (var d = 0; d < l.length; d++) {
                var g = l[d];
                h = Math.max(h, g.height);
                e += g.width;
                if (g.newLine) {
                    b = Math.max(b, e);
                    e = 0;
                    k += h + a
                } else {
                    if (d == l.length - 1) {
                        k += h
                    }
                    b = Math.max(b, e)
                }
            }
            c.width = b + 11;
            c.height = k;
            return c
        }, getLineStyleSize: function (a) {
            if (a == FR.Chart.Constants.LINE_NONE) {
                return 0
            } else {
                if (a == FR.Chart.Constants.LINE_MEDIUM || a == FR.Chart.Constants.LINE_CHART_MED_ARROW || a == FR.Chart.Constants.LINE_DOUBLE || a == FR.Chart.Constants.LINE_MEDIUM_DASH || a == FR.Chart.Constants.LINE_MEDIUM_DASH_DOT || a == FR.Chart.Constants.LINE_MEDIUM_DASH_DOT_DOT || a == FR.Chart.Constants.LINE_SLANTED_DASH_DOT) {
                    return 2
                } else {
                    if (a == FR.Chart.Constants.LINE_THICK || a == FR.Chart.Constants.LINE_CHART_THICK_ARROW) {
                        return 3
                    }
                }
            }
            return 1
        }
    }, TextUtils: {
        calculateTextDimensionWithRotation: function (c, a) {
            var b = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, a);
            return this._calDimWithRotation(b, a)
        }, getTextWhenNotEnoughWidth: function (g, b, h) {
            if (!g) {
                return FR.Chart.Constants.ESP
            }
            var a = FR.Chart.GraphHelper.stringDimension("…", h, 0);
            if (a.width > b) {
                return FR.Chart.Constants.ESP
            }
            var j = b - a.width;
            var k = "";
            for (var e = 0; e < g.length; e++) {
                var f = g.charAt(e);
                var c = FR.Chart.GraphHelper.stringDimension(k, h, 0);
                var d = FR.Chart.GraphHelper.stringDimension(f, h, 0);
                if (c.width + d.width > j) {
                    break
                }
                k += f
            }
            return k + FR.Chart.Constants.ESP
        }, _calDimWithRotation: function (e, b) {
            if (b && b.rotation !== 0) {
                var c = b.rotation;
                var f = c * Math.PI / 180;
                var d = Math.abs(Math.cos(f) * e.width) + Math.abs(Math.sin(f) * e.height);
                var a = Math.abs(Math.cos(f) * e.height) + Math.abs(Math.sin(f) * e.width);
                return new FR.Chart.Dimension2D(d, a)
            }
            return e
        }, calOriginalDimWidthRotation: function (f, b) {
            if (b && b.rotation !== 0) {
                var c = b.rotation;
                var g = c * Math.PI / 180;
                var a = Math.abs(Math.sin(g));
                var e = Math.abs(Math.cos(g));
                var h = (f.width * e - f.height * a) / (e * e - a * a);
                var d = (f.width * a - f.height * e) / (a * a - e * e);
                return new FR.Chart.Dimension2D(h, d)
            }
            return nowLength
        }, calculateTextDimensionWithNoRotation: function (h, b) {
            if (FR.isEmpty(h)) {
                return new FR.Chart.Dimension2D()
            }
            h += "";
            if (b == null) {
                b = new FR.Chart.TextAttr()
            }
            var a = b.frFont;
            if (a == null) {
                a = new FR.Chart.FRFont()
            }
            h = FR.Chart.TextUtils.changeAllReline2Normal(h);
            var e = h.split("\n");
            var f = new FR.Chart.Dimension2D();
            for (var c = 0; c < e.length; c++) {
                if (b.alignText == FR.Chart.Style.VERTICALTEXT) {
                    var g = this._calculateVerticalTextDimension(e[c], b);
                    f.width += g.width;
                    f.height = Math.max(f.height, g.height)
                } else {
                    var g = FR.Chart.GraphHelper.stringDimension(e[c], a, 0);
                    f.width = Math.max(f.width, g.width);
                    f.height += g.height
                }
            }
            return f
        }, _calculateVerticalTextDimension: function (c, b) {
            var a = 0;
            var e = 0;
            for (var d = 0; d < c.length; d++) {
                var f = c.charAt(d);
                var g = FR.Chart.GraphHelper.stringDimension(f, b.frFont, 0);
                if (c.charCodeAt(d) > 127 && f != FR.Chart.Constants.ESP) {
                    e = Math.max(g.width, e);
                    a += g.height
                } else {
                    e = Math.max(g.height, e);
                    a += g.width
                }
            }
            return new FR.Chart.Dimension2D(e, a)
        }, drawLabelWithRotation: function (a, d, b, c) {
            if (!d || c == null) {
                return
            }
            this._drawStringWithTextAttr(a, d, b, c)
        }, changeAllReline2Normal: function (c) {
            if (!c) {
                return c
            }
            c = c.toString();
            var a = "";
            for (var b = 0; b < c.length; b++) {
                if (c.charAt(b) == "\\" && b < c.length && c.charAt(b + 1) == "n") {
                    b++;
                    a += "\n"
                } else {
                    a += c.charAt(b)
                }
            }
            return a.toString()
        }, drawLabelWithNoRotation: function (b, f, d, e, a) {
            if (!f || e == null) {
                return
            }
            var c = this._createNoRotationTextAttr(d);
            this._drawStringWithTextAttr(b, f, c, e, a)
        }, _drawStringWithTextAttr: function (j, g, d, a, k) {
            g = FR.Chart.TextUtils.changeAllReline2Normal(g);
            var h = g.split("\n");
            var e = a.y;
            var f = a.x;
            for (var b = 0; b < h.length; b++) {
                var c = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(h[b], d);
                if (d.alignText == FR.Chart.Style.VERTICALTEXT) {
                    FR.Chart.PaintUtils.paintContent(j, h[b], d, f, e, a.width, a.height, k);
                    f += c.width
                } else {
                    FR.Chart.PaintUtils.paintContent(j, h[b], d, f, e, a.width, a.height, k);
                    e += c.height
                }
            }
        }, _createNoRotationTextAttr: function (b) {
            if (b == null) {
                b = new FR.Chart.TextAttr()
            }
            if (b.frFont == null) {
                b.frFont = new FR.Chart.FRFont()
            }
            var a = b.clone();
            a.rotation = 0;
            return a
        }
    }, MarkerFactory: {
        createTypeArray: function () {
            if (FR.Chart.MarkerFactory.type && FR.Chart.MarkerFactory.index) {
                return
            }
            var b = [];
            var a = [];
            FR.Chart.MarkerFactory.type = b;
            FR.Chart.MarkerFactory.index = a;
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.RoundMarker, new FR.Chart.RoundMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.RoundFilledMarker, new FR.Chart.RoundFilledMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.SquareFilledMarker, new FR.Chart.SquareFilledMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.TriangleFilledMarker, new FR.Chart.TriangleFilledMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.DiamondFilledMarker, new FR.Chart.DiamondFilledMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.DiamondMarker, new FR.Chart.DiamondMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.SquareMarker, new FR.Chart.SquareMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.TriangleMarker, new FR.Chart.TriangleMarker());
            FR.Chart.MarkerFactory.addNewMarker(b, a, FR.Chart.Marker.NullMarker, new FR.Chart.NullMarker())
        }, addNewMarker: function (d, c, a, b) {
            d[a] = b;
            c.push(a)
        }, createMarker: function (a) {
            FR.Chart.MarkerFactory.createTypeArray();
            if (FR.Chart.MarkerFactory.type[a]) {
                return FR.Chart.MarkerFactory.type[a].clone()
            }
            return new FR.Chart.DiamondFilledMarker()
        }, markerIndex2String: function (a) {
            FR.Chart.MarkerFactory.createTypeArray();
            return FR.Chart.MarkerFactory.index[a % (FR.Chart.MarkerFactory.index.length - 1)]
        }
    }, ConditionAttrFactory: {
        createConditionAttr: function (c, f, a) {
            var g = -1;
            var i = null;
            if (f && f.seriesIndex != undefined && (f.jsType == "DataPoint" || f.jsType == "DataSeries")) {
                g = f.seriesIndex
            } else {
                if (!isNaN(f)) {
                    g = f
                }
            }
            if (c instanceof FR.Chart.AttrColor) {
                var b = new FR.Chart.AttrColor();
                b.seriesColor = a[g % a.length];
                i = b
            } else {
                if (c instanceof FR.Chart.AttrBackground) {
                    var k = new FR.Chart.AttrBackground();
                    var h = FR.Chart.ColorBackground.getInstance(a[g % a.length]);
                    h.isSimulation3D = true;
                    k.seriesBackground = h;
                    i = k
                } else {
                    if (c instanceof FR.Chart.AttrLine) {
                        var j = new FR.Chart.AttrLine();
                        var d = a[g % a.length];
                        j.seriesLineColor = d;
                        j.seriesLineStyle = FR.Chart.Constants.LINE_THIN;
                        i = j
                    } else {
                        if (c instanceof FR.Chart.AttrLineStyle) {
                            return new FR.Chart.AttrLineStyle()
                        } else {
                            if (c instanceof FR.Chart.AttrMarkerType) {
                                var e = new FR.Chart.AttrMarkerType();
                                e.markerType = FR.Chart.MarkerFactory.markerIndex2String(g);
                                i = e
                            } else {
                                if (c instanceof FR.Chart.AttrTrendLine) {
                                    i = null
                                } else {
                                    i = c
                                }
                            }
                        }
                    }
                }
            }
            return i
        }
    }, WebUtils: {
        getChart: function (b) {
            if (b.indexOf("__index__") >= 0) {
                b = b.substring(0, b.indexOf("__index__"))
            }
            var c = this._getChartCollection(b);
            if (c && c.Widget) {
                var a = c.Widget.curChart.idxNumber;
                if (c[a]) {
                    return c[a]
                }
            }
        }, getChartWidget: function (a) {
            if (a.indexOf("__index__") >= 0) {
                a = a.substring(0, a.indexOf("__index__"))
            }
            var b = this._getChartCollection(a);
            if (b && b.Widget) {
                return b.Widget
            }
        }, changeParameter: function () {
            if (arguments.length !== 2) {
                return
            }
            var b = this._getChartCollection(arguments[0]);
            var a = arguments[1];
            if (b) {
                $.each(b, function (d, c) {
                    if (c != b.Widget) {
                        c.dealChartAjax(a)
                    }
                })
            }
        }, clearCharts: function () {
            if (FR.ChartManager) {
                for (var d in FR.ChartManager) {
                    var c = FR.ChartManager[d] || {};
                    for (var a in c) {
                        var b = c[a];
                        b && b.clearAll && b.clearAll()
                    }
                }
            }
            FR.ChartManager = {}
        }, chartDelete: function () {
            if (FR.ChartManager && FR.ChartManager.length > 0) {
                $.each(FR.ChartManager, function (b, a) {
                    if (FR.ChartManager[b]) {
                        FR.ChartManager[b] = null
                    }
                })
            }
            FR.ChartManager = null
        }, mapHasNextLayer: function (a) {
            var b = this.getChart(a);
            return b ? b.hasNextLayer() : false
        }, chart_Change_Parameter: function () {
            if (arguments.length !== 3) {
                return
            }
            var a = arguments[0] + "__" + arguments[1];
            if (a.startWith("Elems")) {
                a = arguments[1]
            }
            a += "__";
            this.changeParameter(a, arguments[2])
        }, _getChartCollection: function (a) {
            var b = {};
            if (!FR.ChartManager) {
                return b
            }
            $.each(FR.ChartManager, function (d, c) {
                if (a.indexOf("__") != -1) {
                    if (d.indexOf(a) !== -1) {
                        b = c
                    }
                } else {
                    if ($.inArray(a, d.split("__")) !== -1) {
                        b = c
                    }
                }
            });
            return b
        }, _installChart: function (b, d) {
            FR.ChartManager = FR.ChartManager || {};
            var a = FR.Chart.WebUtils._getChartIDAndIndex(d);
            if ((FR.Widget && b instanceof FR.Widget)) {
                if (FR.ChartManager[a[0]]) {
                    delete FR.ChartManager[a[0]]
                }
                var c = FR.ChartManager[a[0]] = {};
                c = c || {};
                c.Widget = b
            } else {
                var c = FR.ChartManager[a[0]] = FR.ChartManager[a[0]] || {};
                c[a[1]] = b;
                b.inits()
            }
        }, _getChartIDAndIndex: function (c) {
            var b = c;
            var a = "";
            if (b.indexOf("__index__") >= 0) {
                a = b.substring(b.indexOf("__index__") + 9, b.length);
                b = b.substring(0, b.indexOf("__index__"))
            }
            if (b.indexOf("Chart") === 0 && b.indexOf("__") >= 0) {
                b = b.substring(b.indexOf("__") + 2, b.length)
            }
            return [b, a]
        }
    }, SVGExtension: {
        _toFloat: function (a) {
            return parseFloat(a || 0)
        },
        _trim: function (a) {
            return a.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
        },
        _parsePoints: function (e) {
            var d = this._trim(e).replace(/,/g, " ").split(/\s+/);
            var c = [];
            for (var b = 0; b < d.length;) {
                var a = parseFloat(d[b++]);
                var f = parseFloat(d[b++]);
                c.push([a, f])
            }
            return c
        },
        styleList: ["fill", "stroke", "stroke-width", "opacity", "stroke-dasharray", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "font-style", "font-weight", "font-size", "font-family"],
        _parseStyleAttribute: function (b) {
            var c = b.getAttribute("style");
            var a = /(\S*?):(.*?);/g;
            if (c) {
                var d = {};
                c = c.replace(/\s*([;:])\s*/g, "$1");
                c.replace(a, function (g, e, f) {
                    d[e] = f
                });
                return d
            }
            return {}
        },
        _parseAttributes: function (e) {
            var f = {};
            for (var d = 0; d < this.styleList.length; d++) {
                var c = this.styleList[d];
                var a = e.getAttribute(c);
                if (a) {
                    f[c] = a
                }
            }
            var g = this._parseStyleAttribute(e);
            for (var b in g) {
                f[b] = g[b]
            }
            return f
        },
        _extendCommonAttributes: function (f, d) {
            var g = this._parseAttributes(d);
            var b = g.fill;
            var e = g.stroke;
            var a = g["stroke-width"];
            var c = g.opacity;
            if (b && b != "none") {
                f.color = b;
                if (e) {
                    f.brushType = "both";
                    f.strokeColor = e
                } else {
                    f.brushType = "fill"
                }
            } else {
                if (e && e != "none") {
                    f.strokeColor = e;
                    f.brushType = "stroke"
                }
            }
            if (a && a != "none") {
                f.lineWidth = parseFloat(a)
            }
            if (c && c != "none") {
                f.opacity = parseFloat(c)
            }
        },
        getImageBounds: function (d) {
            if (!d) {
                return
            }
            var f = d.firstChild;
            while (!(f.nodeName.toLowerCase() == "svg" && f.nodeType === 1)) {
                f = f.nextSibling
            }
            var b = this._toFloat(f.getAttribute("x"));
            var h = this._toFloat(f.getAttribute("y"));
            var e = this._toFloat(f.getAttribute("width"));
            var a = this._toFloat(f.getAttribute("height"));
            if (FR.isEmpty(f.getAttribute("width")) || FR.isEmpty(f.getAttribute("height"))) {
                var g = f.getAttribute("viewBox");
                var c = g.split(" ");
                if (c.length === 4) {
                    b = parseFloat(c[0]);
                    h = parseFloat(c[1]);
                    e = parseFloat(c[2]) - b;
                    a = parseFloat(c[3]) - h
                }
            }
            return {x: b, y: h, width: e, height: a}
        },
        getPath4Shape: function (c) {
            if (c.shapePath) {
                return c.shapePath
            }
            var g;
            switch (c.shapeType) {
                case"path":
                    g = new FR.Chart.GeneralPath();
                    FR.Chart.SVGPathUtils.buildPath(g, c);
                    break;
                case"rectangle":
                    g = new FR.Chart.Bounds(c.x, c.y, c.width, c.height);
                    break;
                case"line":
                    var f = new FR.Chart.Point2D(c.xStart, c.yStart);
                    var e = new FR.Chart.Point2D(c.xEnd, c.yEnd);
                    g = new FR.Chart.Line2D(f, e);
                    break;
                case"circle":
                    g = new FR.Chart.Arc2D(c.x, c.y, c.r, 0, 360);
                    break;
                case"polygon":
                    g = new FR.Chart.GeneralPath();
                    var b = c.pointList;
                    for (var d = 0; d < b.length; d++) {
                        var a = b[d];
                        if (d === 0) {
                            g.moveTo(a[0], a[1])
                        } else {
                            if (d == b.length - 1) {
                                g.closePath()
                            } else {
                                g.lineTo(a[0], a[1])
                            }
                        }
                    }
                    break;
                default:
                    g = new FR.Chart.GeneralPath()
            }
            c.shapePath = g;
            return g
        },
        drawNodeShape: function (a, b, c) {
            var d = this.getPath4Shape(b).transform(c);
            a.globalAlpha = b.opacity ? b.opacity : 1;
            a.lineWidth = b.lineWidth ? b.lineWidth : 0;
            a.strokeStyle = b.strokeColor ? b.strokeColor : "rgba(255,255,255,0)";
            a.fillStyle = b.color ? b.color : "rgba(255,255,255,0)";
            switch (b.brushType) {
                case"both":
                    d.paint(a);
                    d.draw(a);
                    break;
                case"stroke":
                    d.draw(a);
                    break;
                case"fill":
                    d.paint(a);
                    break
            }
        },
        svgResolve: function (c, b, g, a, f) {
            if (!c) {
                return
            }
            var e = [];
            var d = this;

            function h(r) {
                var l = r.tagName;
                if (d.shapeBuilders[l]) {
                    var n = d.shapeBuilders[l](r);
                    if (n) {
                        d._extendCommonAttributes(n, r);
                        var j = r.getAttribute("name") || "";
                        var m = r.getAttribute("nameTo") || "";
                        var p = r.getAttribute("layerTo") || "";
                        if (!FR.isEmpty(j)) {
                            b.push({name: j, path: n});
                            g[j] = m;
                            a[j] = p;
                            f.push(j)
                        }
                        e.push(n)
                    }
                }
                var k = r.childNodes;
                for (var o = 0, q = k.length; o < q; o++) {
                    h(k[o])
                }
            }

            h(c);
            return e
        },
        shapeBuilders: {
            path: function (a) {
                var b = a.getAttribute("d");
                return {shapeType: "path", path: b}
            }, rect: function (c) {
                var b = FR.Chart.SVGExtension._toFloat(c.getAttribute("x"));
                var e = FR.Chart.SVGExtension._toFloat(c.getAttribute("y"));
                var d = FR.Chart.SVGExtension._toFloat(c.getAttribute("width"));
                var a = FR.Chart.SVGExtension._toFloat(c.getAttribute("height"));
                return {shapeType: "rectangle", x: b, y: e, width: d, height: a}
            }, line: function (d) {
                var b = FR.Chart.SVGExtension._toFloat(d.getAttribute("x1"));
                var e = FR.Chart.SVGExtension._toFloat(d.getAttribute("y1"));
                var a = FR.Chart.SVGExtension._toFloat(d.getAttribute("x2"));
                var c = FR.Chart.SVGExtension._toFloat(d.getAttribute("y2"));
                return {shapeType: "line", xStart: b, yStart: e, xEnd: a, yEnd: c}
            }, circle: function (b) {
                var a = FR.Chart.SVGExtension._toFloat(b.getAttribute("cx"));
                var d = FR.Chart.SVGExtension._toFloat(b.getAttribute("cy"));
                var c = FR.Chart.SVGExtension._toFloat(b.getAttribute("r"));
                return {shapeType: "circle", x: a, y: d, r: c}
            }, ellipse: function (b) {
                var a = FR.Chart.SVGExtension._toFloat(b.getAttribute("cx"));
                var e = FR.Chart.SVGExtension._toFloat(b.getAttribute("cy"));
                var d = FR.Chart.SVGExtension._toFloat(b.getAttribute("rx"));
                var c = FR.Chart.SVGExtension._toFloat(b.getAttribute("ry"));
                return {shapeType: "ellipse", x: a, y: e, a: d, b: c}
            }, polygon: function (d) {
                var e = d.getAttribute("points");
                var c = [Infinity, Infinity];
                var a = [-Infinity, -Infinity];
                if (e) {
                    e = FR.Chart.SVGExtension._parsePoints(e);
                    for (var b = 0; b < e.length; b++) {
                        var f = e[b];
                        c[0] = Math.min(f[0], c[0]);
                        c[1] = Math.min(f[1], c[1]);
                        a[0] = Math.max(f[0], a[0]);
                        a[1] = Math.max(f[1], a[1])
                    }
                    return {shapeType: "polygon", pointList: e}
                }
            }, polyline: function (a) {
                var b = this.polygon(a);
                return b
            }
        }
    }, SVGPathUtils: {
        _convertPoint: function (s, c, r, b, q, j, i, h, e) {
            var y = e * (Math.PI / 180);
            var l = Math.cos(y) * (s - r) / 2 + Math.sin(y) * (c - b) / 2;
            var t = -1 * Math.sin(y) * (s - r) / 2 + Math.cos(y) * (c - b) / 2;
            var o = (l * l) / (i * i) + (t * t) / (h * h);
            if (o > 1) {
                i *= Math.sqrt(o);
                h *= Math.sqrt(o)
            }
            var x = Math.sqrt((((i * i) * (h * h)) - ((i * i) * (t * t)) - ((h * h) * (l * l))) / ((i * i) * (t * t) + (h * h) * (l * l)));
            if (q === j) {
                x *= -1
            }
            if (isNaN(x)) {
                x = 0
            }
            var g = x * i * t / h;
            var p = x * -h * l / i;
            var d = (s + r) / 2 + Math.cos(y) * g - Math.sin(y) * p;
            var a = (c + b) / 2 + Math.sin(y) * g + Math.cos(y) * p;
            var k = this.vAngle([1, 0], [(l - g) / i, (t - p) / h]);
            var n = [(l - g) / i, (t - p) / h];
            var m = [(-1 * l - g) / i, (-1 * t - p) / h];
            var w = this.vAngle(n, m);
            if (this.vRatio(n, m) <= -1) {
                w = Math.PI
            }
            if (this.vRatio(n, m) >= 1) {
                w = 0
            }
            if (j === 0 && w > 0) {
                w = w - 2 * Math.PI
            }
            if (j === 1 && w < 0) {
                w = w + 2 * Math.PI
            }
            return [d, a, i, h, k, w, y, j]
        }, vMag: function (a) {
            return Math.sqrt(a[0] * a[0] + a[1] * a[1])
        }, vRatio: function (b, a) {
            return (b[0] * a[0] + b[1] * a[1]) / (this.vMag(b) * this.vMag(a))
        }, vAngle: function (b, a) {
            return (b[0] * a[1] < b[1] * a[0] ? -1 : 1) * Math.acos(this.vRatio(b, a))
        }, PathSegment: function (b, a) {
            this.command = b;
            this.points = a || null
        }, buildPathArray: function (J, o, m) {
            if (!J) {
                return []
            }
            o = o || 0;
            m = m || 0;
            var f = J;
            var q = ["m", "M", "l", "L", "v", "V", "h", "H", "z", "Z", "c", "C", "q", "Q", "t", "T", "s", "S", "a", "A"];
            f = f.replace(/-/g, " -");
            f = f.replace(/  /g, " ");
            f = f.replace(/ /g, ",");
            f = f.replace(/,,/g, ",");
            var u;
            for (u = 0; u < q.length; u++) {
                f = f.replace(new RegExp(q[u], "g"), "|" + q[u])
            }
            var a = f.split("|");
            var s = [];
            var k = 0;
            var h = 0;
            for (u = 1; u < a.length; u++) {
                var v = a[u];
                var G = v.charAt(0);
                v = v.slice(1);
                v = v.replace(new RegExp("e,-", "g"), "e-");
                var r = v.split(",");
                if (r.length > 0 && r[0] === "") {
                    r.shift()
                }
                for (var D = 0; D < r.length; D++) {
                    r[D] = parseFloat(r[D])
                }
                while (r.length > 0) {
                    if (isNaN(r[0])) {
                        break
                    }
                    var B = null;
                    var C = [];
                    var I;
                    var H;
                    var z;
                    var e;
                    var d;
                    var F;
                    var t;
                    var g;
                    var E = k;
                    var b = h;
                    switch (G) {
                        case"l":
                            k += r.shift();
                            h += r.shift();
                            B = "L";
                            C.push(k, h);
                            break;
                        case"L":
                            k = r.shift();
                            h = r.shift();
                            C.push(k, h);
                            break;
                        case"m":
                            k += r.shift();
                            h += r.shift();
                            B = "M";
                            C.push(k, h);
                            G = "l";
                            break;
                        case"M":
                            k = r.shift();
                            h = r.shift();
                            B = "M";
                            C.push(k, h);
                            G = "L";
                            break;
                        case"h":
                            k += r.shift();
                            B = "L";
                            C.push(k, h);
                            break;
                        case"H":
                            k = r.shift();
                            B = "L";
                            C.push(k, h);
                            break;
                        case"v":
                            h += r.shift();
                            B = "L";
                            C.push(k, h);
                            break;
                        case"V":
                            h = r.shift();
                            B = "L";
                            C.push(k, h);
                            break;
                        case"C":
                            C.push(r.shift(), r.shift(), r.shift(), r.shift());
                            k = r.shift();
                            h = r.shift();
                            C.push(k, h);
                            break;
                        case"c":
                            C.push(k + r.shift(), h + r.shift(), k + r.shift(), h + r.shift());
                            k += r.shift();
                            h += r.shift();
                            B = "C";
                            C.push(k, h);
                            break;
                        case"S":
                            I = k;
                            H = h;
                            z = s[s.length - 1];
                            if (z.command === "C") {
                                I = k + (k - z.points[2]);
                                H = h + (h - z.points[3])
                            }
                            C.push(I, H, r.shift(), r.shift());
                            k = r.shift();
                            h = r.shift();
                            B = "C";
                            C.push(k, h);
                            break;
                        case"s":
                            I = k, H = h;
                            z = s[s.length - 1];
                            if (z.command === "C") {
                                I = k + (k - z.points[2]);
                                H = h + (h - z.points[3])
                            }
                            C.push(I, H, k + r.shift(), h + r.shift());
                            k += r.shift();
                            h += r.shift();
                            B = "C";
                            C.push(k, h);
                            break;
                        case"Q":
                            C.push(r.shift(), r.shift());
                            k = r.shift();
                            h = r.shift();
                            C.push(k, h);
                            break;
                        case"q":
                            C.push(k + r.shift(), h + r.shift());
                            k += r.shift();
                            h += r.shift();
                            B = "Q";
                            C.push(k, h);
                            break;
                        case"T":
                            I = k, H = h;
                            z = s[s.length - 1];
                            if (z.command === "Q") {
                                I = k + (k - z.points[0]);
                                H = h + (h - z.points[1])
                            }
                            k = r.shift();
                            h = r.shift();
                            B = "Q";
                            C.push(I, H, k, h);
                            break;
                        case"t":
                            I = k, H = h;
                            z = s[s.length - 1];
                            if (z.command === "Q") {
                                I = k + (k - z.points[0]);
                                H = h + (h - z.points[1])
                            }
                            k += r.shift();
                            h += r.shift();
                            B = "Q";
                            C.push(I, H, k, h);
                            break;
                        case"A":
                            e = r.shift();
                            d = r.shift();
                            F = r.shift();
                            t = r.shift();
                            g = r.shift();
                            E = k, b = h;
                            k = r.shift(), h = r.shift();
                            B = "A";
                            C = this._convertPoint(E, b, k, h, t, g, e, d, F);
                            break;
                        case"a":
                            e = r.shift();
                            d = r.shift();
                            F = r.shift();
                            t = r.shift();
                            g = r.shift();
                            E = k, b = h;
                            k += r.shift();
                            h += r.shift();
                            B = "A";
                            C = this._convertPoint(E, b, k, h, t, g, e, d, F);
                            break
                    }
                    for (var A = 0, w = C.length; A < w; A += 2) {
                        C[A] += o;
                        C[A + 1] += m
                    }
                    s.push(new FR.Chart.SVGPathUtils.PathSegment(B || G, C))
                }
                if (G === "z" || G === "Z") {
                    s.push(new FR.Chart.SVGPathUtils.PathSegment("z", []))
                }
            }
            return s
        }, buildPath: function (s, b) {
            var t = b.path;
            var r = b.x || 0;
            var q = b.y || 0;
            b.pathArray = b.pathArray || this.buildPathArray(t, r, q);
            var e = b.pathArray;
            var a = b.pointList = [];
            var f = [];
            for (var n = 0, g = e.length; n < g; n++) {
                if (e[n].command.toUpperCase() == "M") {
                    f.length > 0 && a.push(f);
                    f = []
                }
                var d = e[n].points;
                for (var m = 0, h = d.length; m < h; m += 2) {
                    f.push([d[m], d[m + 1]])
                }
            }
            f.length > 0 && a.push(f);
            for (var n = 0, g = e.length;
                 n < g; n++) {
                var o = e[n].command;
                var d = e[n].points;
                switch (o) {
                    case"L":
                        s.lineTo(d[0], d[1]);
                        break;
                    case"M":
                        s.moveTo(d[0], d[1]);
                        break;
                    case"C":
                        s.curveTo(d[0], d[1], d[2], d[3], d[4], d[5]);
                        break;
                    case"Q":
                        s.quadTo(d[0], d[1], d[2], d[3]);
                        break;
                    case"z":
                        s.closePath();
                        break
                }
            }
            return
        }, getRect: function (c) {
            if (c.__rect) {
                return c.__rect
            }
            var l;
            if (c.brushType == "stroke" || c.brushType == "fill") {
                l = c.lineWidth || 1
            } else {
                l = 0
            }
            var g = Number.MAX_VALUE;
            var b = Number.MIN_VALUE;
            var f = Number.MAX_VALUE;
            var a = Number.MIN_VALUE;
            var o = c.x || 0;
            var n = c.y || 0;
            var e = c.pathArray || this.buildPathArray(c.path);
            for (var k = 0; k < e.length; k++) {
                var d = e[k].points;
                for (var h = 0; h < d.length; h++) {
                    if (h % 2 === 0) {
                        if (d[h] + o < g) {
                            g = d[h]
                        }
                        if (d[h] + o > b) {
                            b = d[h]
                        }
                    } else {
                        if (d[h] + n < f) {
                            f = d[h]
                        }
                        if (d[h] + n > a) {
                            a = d[h]
                        }
                    }
                }
            }
            var m;
            if (g === Number.MAX_VALUE || b === Number.MIN_VALUE || f === Number.MAX_VALUE || a === Number.MIN_VALUE) {
                m = {x: 0, y: 0, width: 0, height: 0}
            } else {
                m = {x: Math.round(g - l / 2), y: Math.round(f - l / 2), width: b - g + l, height: a - f + l}
            }
            c.__rect = m;
            return m
        }
    }, HighUtils: {
        doFocus: function (c, a, b) {
            if (!FR.Chart.GraphHelper.isDrawingEnd) {
                return
            }
            if (c && a) {
                if (c.isFade && b) {
                    b.save();
                    b.translate(0, -4);
                    b.shadowBlur = 20;
                    b.shadowOffsetX = 2;
                    b.shadowOffsetY = 2;
                    b.shadowColor = "rgba(0,0,0,0.3)";
                    if (c.getFillStyleColor() && c.shape) {
                        b.fillStyle = c.getFillStyleColor();
                        c.shape.paint(b)
                    }
                    b.translate(0, 4);
                    b.restore()
                } else {
                    this.doBorder(c, a);
                    this.doHighlight(c, a)
                }
            }
        }, doBorder: function (c, a) {
            if (!a) {
                return
            }
            a.save();
            if (c) {
                var b = c.getShape();
                if (b) {
                    a.lineWidth = 2;
                    if (c.toolTipBackground) {
                        c.toolTipBackground.draw(a, b)
                    } else {
                        FR.Chart.ColorBackground.getInstance("rgb(128,128,128)").draw(a, b)
                    }
                }
            }
            a.restore()
        }, doSeriesDragBorder: function (d, b) {
            if (!b) {
                return
            }
            b.save();
            if (d) {
                if (d instanceof FR.Chart.MarkerGlyph) {
                    var a = d.marker;
                    if (a) {
                        b.lineWidth = 1;
                        b.strokeStyle = a.background.color;
                        a.drawDragBorder(b)
                    }
                } else {
                    var c = d.getShape();
                    if (c) {
                        if (c instanceof FR.Chart.Ring) {
                            FR.Chart.HighUtils.doFocus(d, b)
                        } else {
                            if (d.toolTipBackground && c.drawDragBorder) {
                                b.lineWidth = 1;
                                b.strokeStyle = d.toolTipBackground.color;
                                c.drawDragBorder(b)
                            }
                        }
                    }
                }
            }
            b.restore()
        }, doHighlight: function (c, a) {
            if (c instanceof FR.Chart.GeneralGlyph) {
                var d = c.info;
                var b = new FR.Chart.GeneralInfo();
                b.seriesAttrBackground.seriesBackground = FR.Chart.ColorBackground.getInstance("white");
                b.seriesAttrAlpha.alpha = 0.15;
                c.info = b;
                c.draw(a);
                c.info = d
            }
        }
    }
});
FR.Chart.FRFont = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.size = a.size || 12;
        this.color = a.color || "black";
        this.fontName = a.fontName || "SimSun";
        this.style = a.style || ""
    }, getStringFont: function () {
        return this.style + " " + parseInt(this.size) + "px " + this.fontName
    }
});
FR.Chart.AffineTransform = function (d, f, b, e, a, c) {
    this.m00 = d;
    this.m10 = f;
    this.m01 = b;
    this.m11 = e;
    this.m02 = a;
    this.m12 = c;
    this.updateState()
};
$.extend(FR.Chart.AffineTransform, {APPLY_IDENTITY: 0, APPLY_TRANSLATE: 1, APPLY_SCALE: 2, APPLY_SHEAR: 4});
$.extend(FR.Chart.AffineTransform.prototype, {
    updateState: function () {
        if (this.m01 === 0 && this.m10 === 0) {
            if (this.m00 === 1 && this.m11 === 1) {
                if (this.m02 === 0 && this.m12 === 0) {
                    this.state = FR.Chart.AffineTransform.APPLY_IDENTITY
                } else {
                    this.state = FR.Chart.AffineTransform.APPLY_TRANSLATE
                }
            } else {
                if (this.m02 === 0 && this.m12 === 0) {
                    this.state = FR.Chart.AffineTransform.APPLY_SCALE
                } else {
                    this.state = (FR.Chart.AffineTransform.APPLY_SCALE | FR.Chart.AffineTransform.APPLY_TRANSLATE)
                }
            }
        } else {
            if (this.m00 === 0 && this.m11 === 0) {
                if (this.m02 === 0 && this.m12 === 0) {
                    this.state = FR.Chart.AffineTransform.APPLY_SHEAR
                } else {
                    this.state = (FR.Chart.AffineTransform.APPLY_SHEAR | FR.Chart.AffineTransform.APPLY_TRANSLATE)
                }
            } else {
                if (this.m02 === 0 && this.m12 === 0) {
                    this.state = (FR.Chart.AffineTransform.APPLY_SHEAR | FR.Chart.AffineTransform.APPLY_SCALE)
                } else {
                    this.state = (FR.Chart.AffineTransform.APPLY_SHEAR | FR.Chart.AffineTransform.APPLY_SCALE | FR.Chart.AffineTransform.APPLY_TRANSLATE)
                }
            }
        }
    }, transform: function (d, b) {
        d = d || {x: 0, y: 0};
        b = b || {x: 0, y: 0};
        var a = d.x || 0;
        var c = d.y || 0;
        switch (this.state) {
            default:
                return b;
            case (FR.Chart.AffineTransform.APPLY_SHEAR | FR.Chart.AffineTransform.APPLY_SCALE | FR.Chart.AffineTransform.APPLY_TRANSLATE):
                b.x = a * this.m00 + c * this.m01 + this.m02;
                b.y = a * this.m10 + c * this.m11 + this.m12;
                return b;
            case (FR.Chart.AffineTransform.APPLY_SHEAR | FR.Chart.AffineTransform.APPLY_SCALE):
                b.x = a * this.m00 + c * this.m01;
                b.y = a * this.m10 + c * this.m11;
                return b;
            case (FR.Chart.AffineTransform.APPLY_SHEAR | FR.Chart.AffineTransform.APPLY_TRANSLATE):
                b.x = c * this.m01 + this.m02;
                b.y = a * this.m10 + this.m12;
                return b;
            case (FR.Chart.AffineTransform.APPLY_SHEAR):
                b.x = c * this.m01;
                b.y = a * this.m10;
                return b;
            case (FR.Chart.AffineTransform.APPLY_SCALE | FR.Chart.AffineTransform.APPLY_TRANSLATE):
                b.x = a * this.m00 + this.m02;
                b.y = c * this.m11 + this.m12;
                return b;
            case (FR.Chart.AffineTransform.APPLY_SCALE):
                b.x = a * this.m00;
                b.y = c * this.m11;
                return b;
            case (FR.Chart.AffineTransform.APPLY_TRANSLATE):
                b.x = a + this.m02;
                b.y = c + this.m12;
                return b;
            case (FR.Chart.AffineTransform.APPLY_IDENTITY):
                b.x = a;
                b.y = c;
                return b
        }
        return b
    }
});
FR.Chart.HashMap = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (b) {
        this.length = 0;
        b = b || {};
        if (b.length > 0) {
            for (var a = 0; a < b.length; a++) {
                this.add(new FR.Chart[b[a].conditionAttrType](b[a]))
            }
        }
    }, add: function (a) {
        this[this.length] = a;
        this.length++
    }, put: function (a, b) {
        this[a] = b;
        this.length++
    }, get: function (a) {
        return this[a]
    }, containsKey: function (a) {
        if (this[a] === undefined) {
            return false
        }
        return true
    }
});
FR.Chart = FR.Chart || {};
FR.Chart.Constants = {
    MarkerDefaultSize: 10,
    ESP: "…",
    BubbleType_Width: 1,
    BubbleType_Area: 2,
    RangeAxisHeight: 50,
    MeterTickColor: "rgb(47, 46, 46)",
    MeterNeedleColor: "rgb(47, 46, 46)",
    AxisTickWidth: 1,
    Color_DEFAULT: 0,
    Color_ACC: 1,
    Color_GRADIENT: 2,
    STYLE_NONE: 0,
    STYLE_3D: 1,
    STYLE_OUTER: 2,
    STYLE_DEFAULT: 3,
    STYLE_SHADE: 4,
    STYLE_TRANSPARENT: 5,
    DAY: 1,
    MONTH: 2,
    YEAR: 3,
    Hour: 4,
    Minute: 5,
    Second: 6,
    CENTER: 0,
    TOP: 1,
    LEFT: 2,
    BOTTOM: 3,
    RIGHT: 4,
    RIGHT_TOP: 8,
    TICK_MARK_NONE: 0,
    TICK_MARK_INSIDE: 1,
    TICK_MARK_OUTSIDE: 2,
    TICK_MARK_CROSS: 3,
    LINE_NONE: 0,
    LINE_THIN: 1,
    LINE_MEDIUM: 2,
    LINE_DASH: 3,
    LINE_HAIR: 4,
    LINE_HAIR2: 14,
    LINE_THICK: 5,
    LINE_DOT: 7,
    LINE_MEDIUM_DASH: 8,
    LINE_DASH_DOT: 9,
    LINE_MEDIUM_DASH_DOT: 10,
    LINE_DASH_DOT_DOT: 11,
    LINE_MEDIUM_DASH_DOT_DOT: 12,
    LINE_SLANTED_DASH_DOT: 13,
    LINE_CHART_THIN_ARROW: 21,
    LINE_CHART_MED_ARROW: 22,
    LINE_CHART_THICK_ARROW: 23,
    LABEL_AROUND: 3,
    LABEL_TOP: 2,
    LABEL_BOTTOM: 1,
    LABEL_NONE: 0,
    IMAGE_TILED: 0,
    IMAGE_CENTER: 1,
    IMAGE_EXTEND: 2,
    IMAGE_DEFAULT: 3,
    IMAGE_ADJUST: 4,
    INSIDE: 5,
    OUTSIDE: 6,
    AXISINSIDE: 7,
    TRENDLINE_LINEAR: 0,
    TRENDLINE_POLYNOMIAL: 1,
    TRENDLINE_LOG: 2,
    TRENDLINE_EXPONENT: 3,
    TRENDLINE_POWER: 4,
    TRENDLINE_MA: 5
};
FR.Chart.ChartPaintConstants = {
    ACTION_MODEL_DEFAULT: 0,
    ACTION_MODEL_NULL: 1,
    ACTION_MODEL_CHANGE: 2,
    ACTION_STEP_Number: [36, 1, 36],
    ACTION_TIME: [1000, 1, 500],
    STATE_DISAPPEAR: 0,
    STATE_UNENABLE: 1,
    STATE_ENABLE: 2,
    STATE_APPEAR: 3,
    STATE_TRANSPARENT: 4
};
FR.Chart.ChartIconState = {STATE_NORMAL: 0, STATE_OVER: 1, STATE_SELECT: 2};
FR.Chart.MapType = {Map_Normal: 0, Map_Bubble: 1, Map_Pie: 2, Map_Column: 3};
FR.Chart.ChartCoreConstants = {
    CHART_Color_ARRAY: ["rgb(25,79,151)", "rgb(85,85,85)", "rgb(189,107,8)", "rgb(0,104,107)", "rgb(200,45,49)", "rgb(98,91,161)", "rgb(137,137,137)", "rgb(156,152,0)", "rgb(0,127,84)", "rgb(161,149,197)", "rgb(16,54,103)", "rgb(241,146,114)", "rgb(193,140,0)", "rgb(54,54,54)", "rgb(66,111,179)", "rgb(102,191,127)", "rgb(249,205,118)", "rgb(57,40,132)", "rgb(0,174,113)", "rgb(147,170,214)", "rgb(73,7,97)", "rgb(250,241,75)", "rgb(149,83,5)", "rgb(1,98,65)", "rgb(115,136,193)", "rgb(143,30,32)", "rgb(249,205,118)", "rgb(214,155,1)", "rgb(183,183,183)", "rgb(81,31,144)", "rgb(153,208,185)", "rgb(199,195,0)"],
    BRIGHT_COLOR_ARRAY: ["rgb(14,114,204)", "rgb(108,163,15)", "rgb(245,147,17)", "rgb(250,67,67)", "rgb(22,175,204)", "rgb(133,192,33)", "rgb(209,42,106)", "rgb(14,114,204)", "rgb(108,163,15)", "rgb(245,147,17)", "rgb(250,67,67)", "rgb(22,175,204)", "rgb(133,192,33)", "rgb(209,42,106)", "rgb(14,114,204)", "rgb(108,163,15)", "rgb(245,147,17)", "rgb(250,67,67)", "rgb(22,175,204)", "rgb(133,192,33)", "rgb(209,42,106)", "rgb(14,114,204)", "rgb(108,163,15)", "rgb(245,147,17)", "rgb(250,67,67)", "rgb(22,175,204)", "rgb(133,192,33)", "rgb(209,42,106)", "rgb(14,114,204)", "rgb(108,163,15)", "rgb(245,147,17)", "rgb(250,67,67)"],
    ELEGANT_COLOR_ARRAY: ["rgb(54,130,190)", "rgb(69,167,118)", "rgb(240,83,38)", "rgb(238,215,119)", "rgb(51,79,101)", "rgb(179,151,78)", "rgb(56,203,125)", "rgb(221,174,51)", "rgb(132,75,179)", "rgb(147,197,85)", "rgb(95,102,148)", "rgb(223,56,129)", "rgb(46,146,150)", "rgb(54,130,190)", "rgb(69,167,118)", "rgb(240,83,38)", "rgb(238,215,119)", "rgb(51,79,101)", "rgb(179,151,78)", "rgb(56,203,125)", "rgb(221,174,51)", "rgb(132,75,179)", "rgb(147,197,85)", "rgb(95,102,148)", "rgb(223,56,129)", "rgb(46,146,150)", "rgb(54,130,190)", "rgb(69,167,118)", "rgb(240,83,38)", "rgb(238,215,119)", "rgb(51,79,101)", "rgb(179,151,78)"],
    SOFT_COLOR_ARRAY: ["rgb(91,155,213)", "rgb(237,125,49)", "rgb(112,173,71)", "rgb(255,192,0)", "rgb(68,114,196)", "rgb(145,208,36)", "rgb(178,53,230)", "rgb(2,174,117)", "rgb(91,155,213)", "rgb(237,125,49)", "rgb(112,173,71)", "rgb(255,192,0)", "rgb(68,114,196)", "rgb(145,208,36)", "rgb(178,53,230)", "rgb(2,174,117)", "rgb(91,155,213)", "rgb(237,125,49)", "rgb(112,173,71)", "rgb(255,192,0)", "rgb(68,114,196)", "rgb(145,208,36)", "rgb(178,53,230)", "rgb(2,174,117)", "rgb(91,155,213)", "rgb(237,125,49)", "rgb(112,173,71)", "rgb(255,192,0)", "rgb(68,114,196)", "rgb(145,208,36)", "rgb(178,53,230)", "rgb(2,174,117)"],
    SIMPLE_COLOR_ARRAY: ["rgb(124,181,236)", "rgb(67,67,72)", "rgb(144,237,125)", "rgb(247,163,92)", "rgb(128,133,233)", "rgb(241,92,128)", "rgb(228,211,84)", "rgb(124,181,236)", "rgb(67,67,72)", "rgb(144,237,125)", "rgb(247,163,92)", "rgb(128,133,233)", "rgb(241,92,128)", "rgb(228,211,84)", "rgb(124,181,236)", "rgb(67,67,72)", "rgb(144,237,125)", "rgb(247,163,92)", "rgb(128,133,233)", "rgb(241,92,128)", "rgb(228,211,84)", "rgb(124,181,236)", "rgb(67,67,72)", "rgb(144,237,125)", "rgb(247,163,92)", "rgb(128,133,233)", "rgb(241,92,128)", "rgb(228,211,84)", "rgb(124,181,236)", "rgb(67,67,72)", "rgb(144,237,125)", "rgb(247,163,92)"],
    RETRO_COLOR_ARRAY: ["rgb(7,128,207)", "rgb(118,80,5)", "rgb(250,109,29)", "rgb(14,44,130)", "rgb(182,181,31)", "rgb(218,31,24)", "rgb(112,24,102)", "rgb(244,122,117)", "rgb(0,157,178)", "rgb(2,75,81)", "rgb(7,128,207)", "rgb(118,80,5)", "rgb(250,109,29)", "rgb(14,44,130)", "rgb(182,181,31)", "rgb(218,31,24)", "rgb(112,24,102)", "rgb(244,122,117)", "rgb(0,157,178)", "rgb(2,75,81)", "rgb(7,128,207)", "rgb(118,80,5)", "rgb(250,109,29)", "rgb(14,44,130)", "rgb(182,181,31)", "rgb(218,31,24)", "rgb(112,24,102)", "rgb(244,122,117)", "rgb(0,157,178)", "rgb(2,75,81)", "rgb(7,128,207)", "rgb(118,80,5)"],
    BUSINESS_COLOR_ARRAY: ["rgb(25,79,151)", "rgb(85,85,85)", "rgb(189,107,8)", "rgb(0,104,107)", "rgb(200,45,49)", "rgb(98,91,161)", "rgb(137,137,137)", "rgb(156,152,0)", "rgb(0,127,84)", "rgb(161,149,197)", "rgb(16,54,103)", "rgb(241,146,114)", "rgb(193,140,0)", "rgb(54,54,54)", "rgb(66,111,179)", "rgb(102,191,127)", "rgb(249,205,118)", "rgb(57,40,132)", "rgb(0,174,113)", "rgb(147,170,214)", "rgb(73,7,97)", "rgb(250,241,75)", "rgb(149,83,5)", "rgb(1,98,65)", "rgb(115,136,193)", "rgb(143,30,32)", "rgb(249,205,118)", "rgb(214,155,1)", "rgb(183,183,183)", "rgb(81,31,144)", "rgb(153,208,185)", "rgb(199,195,0)"],
    FRESH_COLOR_ARRAY: ["rgb(0,168,225)", "rgb(153,204,0)", "rgb(227,0,57)", "rgb(252,211,0)", "rgb(128,0,128)", "rgb(0,153,78)", "rgb(255,102,0)", "rgb(128,128,0)", "rgb(219,0,194)", "rgb(0,128,128)", "rgb(0,0,255)", "rgb(200,204,0)", "rgb(0,18,133)", "rgb(0,202,204)", "rgb(224,56,0)", "rgb(250,155,0)", "rgb(133,10,0)", "rgb(153,0,137)", "rgb(191,102,0)", "rgb(0,191,94)", "rgb(141,0,220)", "rgb(250,241,0)", "rgb(149,83,0)", "rgb(0,98,65)", "rgb(115,136,193)", "rgb(143,30,32)", "rgb(249,205,118)", "rgb(214,155,1)", "rgb(183,183,183)", "rgb(81,31,144)", "rgb(153,208,185)", "rgb(199,195,0)"],
    CLASSIC_COLOR_ARRAY: ["rgb(0,44,83)", "rgb(255,165,16)", "rgb(12,132,198)", "rgb(255,189,102)", "rgb(247,77,77)", "rgb(36,85,164)", "rgb(65,183,172)", "rgb(0,44,83)", "rgb(255,165,16)", "rgb(12,132,198)", "rgb(255,189,102)", "rgb(247,77,77)", "rgb(36,85,164)", "rgb(65,183,172)", "rgb(0,44,83)", "rgb(255,165,16)", "rgb(12,132,198)", "rgb(255,189,102)", "rgb(247,77,77)", "rgb(36,85,164)", "rgb(65,183,172)", "rgb(0,44,83)", "rgb(255,165,16)", "rgb(12,132,198)", "rgb(255,189,102)", "rgb(247,77,77)", "rgb(36,85,164)", "rgb(65,183,172)", "rgb(0,44,83)", "rgb(255,165,16)", "rgb(12,132,198)", "rgb(255,189,102)"],
    GRADUAL_COLOR_ARRAY: ["rgb(113,174,70)", "rgb(150,183,68)", "rgb(196,204,56)", "rgb(235,225,42)", "rgb(234,176,38)", "rgb(227,133,43)", "rgb(216,93,42)", "rgb(206,38,38)", "rgb(172,32,38)", "rgb(113,174,70)", "rgb(150,183,68)", "rgb(196,204,56)", "rgb(235,225,42)", "rgb(234,176,38)", "rgb(227,133,43)", "rgb(216,93,42)", "rgb(206,38,38)", "rgb(172,32,38)", "rgb(113,174,70)", "rgb(150,183,68)", "rgb(196,204,56)", "rgb(235,225,42)", "rgb(234,176,38)", "rgb(227,133,43)", "rgb(216,93,42)", "rgb(206,38,38)", "rgb(172,32,38)", "rgb(113,174,70)", "rgb(150,183,68)", "rgb(196,204,56)", "rgb(235,225,42)", "rgb(234,176,38)"],
    NOSTALGIA_COLOR_ARRAY: ["rgb(59,98,145)", "rgb(148,60,57)", "rgb(119,144,67)", "rgb(98,76,124)", "rgb(56,132,152)", "rgb(191,115,52)", "rgb(63,104,153)", "rgb(156,64,61)", "rgb(125,152,71)", "rgb(103,80,131)", "rgb(59,139,161)", "rgb(201,121,55)", "rgb(66,109,161)", "rgb(164,67,64)", "rgb(132,159,75)", "rgb(108,84,138)", "rgb(63,146,169)", "rgb(211,127,58)", "rgb(69,114,167)", "rgb(170,70,67)", "rgb(137,165,78)", "rgb(113,88,143)", "rgb(65,152,175)", "rgb(219,132,61)", "rgb(72,118,174)", "rgb(177,73,70)", "rgb(142,172,81)", "rgb(117,91,149)", "rgb(68,158,182)", "rgb(228,138,64)", "rgb(75,123,180)", "rgb(183,76,73)"],
    CHART_FILL_Color_ARRAY: []
};
FR.Chart.DefinedColors = {
    bright: FR.Chart.ChartCoreConstants.BRIGHT_COLOR_ARRAY,
    elegant: FR.Chart.ChartCoreConstants.ELEGANT_COLOR_ARRAY,
    soft: FR.Chart.ChartCoreConstants.SOFT_COLOR_ARRAY,
    simple: FR.Chart.ChartCoreConstants.SIMPLE_COLOR_ARRAY,
    retro: FR.Chart.ChartCoreConstants.RETRO_COLOR_ARRAY,
    business: FR.Chart.ChartCoreConstants.BUSINESS_COLOR_ARRAY,
    fresh: FR.Chart.ChartCoreConstants.FRESH_COLOR_ARRAY,
    classic: FR.Chart.ChartCoreConstants.CLASSIC_COLOR_ARRAY,
    gradual: FR.Chart.ChartCoreConstants.GRADUAL_COLOR_ARRAY,
    nostalgia: FR.Chart.ChartCoreConstants.NOSTALGIA_COLOR_ARRAY
};
FR.Chart.Type = {
    Bar: {
        plotType: "Bar2DPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        xAxisGlyph: "CategoryAxisGlyph",
        yAxisGlyph: "ValueAxisGlyph",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Column"
    },
    Bar3D: {
        plotType: "Bar3DPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        xAxisGlyph: "CategoryAxisGlyph",
        yAxisGlyph: "ValueAxisGlyph",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Column"
    },
    Line: {
        plotType: "LinePlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        xAxisGlyph: "CategoryAxisGlyph",
        yAxisGlyph: "ValueAxisGlyph",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Line"
    },
    Area: {
        plotType: "AreaPlotGlyph",
        dataSeries: "DataSeries4Area",
        dataPoint: "DataPoint",
        xAxisGlyph: "CategoryAxisGlyph",
        yAxisGlyph: "ValueAxisGlyph",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Area"
    },
    Area3D: {
        plotType: "Area3DPlotGlyph",
        dataSeries: "DataSeries4Area",
        dataPoint: "DataPoint",
        xAxisGlyph: "CategoryAxisGlyph",
        yAxisGlyph: "ValueAxisGlyph",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Area"
    },
    Pie: {
        plotType: "PiePlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Pie",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Pie"
    },
    CompositePie: {
        plotType: "CompositePiePlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Pie",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Pie"
    },
    Pie3D: {
        plotType: "Pie3DPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Pie",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Pie"
    },
    Custom: {
        plotType: "CustomPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        xAxisGlyph: "CategoryAxisGlyph",
        yAxisGlyph: "ValueAxisGlyph",
        secondAxisGlyph: "ValueAxisGlyph",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Custom"
    },
    Scatter: {
        plotType: "XYScatterPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4XY",
        dataDefinition: "ScatterDefinition",
        simpleIconType: "Scatter"
    },
    Bubble: {
        plotType: "BubblePlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Bubble",
        dataDefinition: "BubbleDefinition",
        simpleIconType: "Bubble"
    },
    Radar: {
        plotType: "RadarPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Radar"
    },
    Stock: {
        plotType: "StockPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Stock",
        dataDefinition: "StockDefinition",
        simpleIconType: "Stock"
    },
    Meter: {
        plotType: "MeterPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        dataDefinition: "MeterDefinition",
        simpleIconType: "Meter"
    },
    Range: {
        plotType: "RangePlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Range"
    },
    Gantt: {
        plotType: "GanttPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Gantt",
        dataDefinition: "GanttDefinition",
        simpleIconType: "Gantt"
    },
    Donut: {
        plotType: "Donut2DPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Donut"
    },
    Donut3D: {
        plotType: "Donut3DPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint",
        dataDefinition: "NormalDataDefinition",
        simpleIconType: "Donut"
    },
    Map: {
        plotType: "MapPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4Map",
        dataDefinition: "MapSingleLayerDefinition",
        simpleIconType: "Map"
    },
    GisMap: {
        plotType: "GisMapPlotGlyph",
        dataSeries: "DataSeries",
        dataPoint: "DataPoint4GisMap",
        dataDefinition: "GisMapDefinition",
        simpleIconType: "GisMap"
    },
    getSimpleIconType: function (b) {
        if (!b.chartType || !FR.Chart.Type[b.chartType]) {
            return "Column"
        } else {
            var a = FR.Chart.Type[b.chartType].simpleIconType;
            if (a == "Column" && b.plot) {
                a = b.plot.isHorizontal ? "Bar" : "Column"
            }
            return a
        }
    }
};
FR.Chart.AxisConfig = {ValueAxis: "ValueAxisGlyph", CategoryAxis: "CategoryAxisGlyph", DateAxis: "DateAxisGlyph"};
FR.Chart.Position = {
    "center": 0,
    "top": 1,
    "left": 2,
    "bottom": 3,
    "right": 4,
    "right-top": 8,
    "inside": 5,
    "outside": 6
};
FR.Chart.PlotStyle = {"3D": 1, "highlight": 2, "gradient": 4, "transparent": 5};
FR.Chart.HyperlinkType = {JS: 0, WEB: 1, RELATE: 2};
FR.Chart.FillStyle = {"fill": 1, "gradient": 2};
FR.Chart.Separator = [",", ".", ";", " ", "${BR}"];
FR.Chart.Compare = {
    EQUALS: 0,
    NOT_EQUAL: 1,
    GREATER_THAN: 2,
    GREATER_THAN_OR_EQUAL: 3,
    LESS_THAN: 4,
    LESS_THAN_OR_EQUAL: 5
};
FR.Chart.Style = {
    HORIZONTALTEXT: 0,
    VERTICALTEXT: 1,
    RIGHT_TO_LEFT: 0,
    LEFT_TO_RIGHT: 1,
    format: null,
    frFont: null,
    background: null,
    horizontal_alignment: FR.Chart.Constants.LEFT,
    vertical_alignment: FR.Chart.Constants.CENTER,
    textStyle: 0,
    verticalText: 0,
    textDirection: 0,
    rotation: 0,
    imageLayout: FR.Chart.Constants.IMAGE_DEFAULT
};
FR.Chart = FR.Chart || {};
FR.Chart.Point2D = function (a, b) {
    this.x = a;
    this.y = b
};
$.extend(FR.Chart.Point2D.prototype, {
    x: 0, y: 0, equals: function (a) {
        if (a instanceof FR.Chart.Point2D) {
            return (this.x == a.x) && (this.y == a.y)
        }
        return false
    }, setLocation: function (a, b) {
        this.x = a;
        this.y = b
    }
});
FR.Chart.Dimension2D = function (b, a) {
    this.initConstants(b, a)
};
$.extend(FR.Chart.Dimension2D.prototype, {
    initConstants: function (b, a) {
        this.width = FR.pick(b, 0);
        this.height = FR.pick(a, 0)
    }
});
FR.Chart.MapReturnButton = function (a) {
    this.bounds = a;
    this.clickable = true
};
$.extend(FR.Chart.MapReturnButton.prototype, {
    onClick: function (a, b) {
        b.returnBack = true;
        b.needRefresh = true
    }, containsPoint: function (b, a) {
        return this.bounds.containsPoint(b, a)
    }
});
FR.Chart.HeatMapControlBar = function (e, b, a, d, c) {
    this.bounds = e;
    this.position = b;
    this.mapHotAreaColor = a;
    this.seriesList = d;
    this.startItemIndex = 0;
    this.endItemIndex = a.getAreaNumber() - 1;
    this.areaColorBlock = [];
    this.jsType = "controlBar";
    this.textAttr = c;
    this.clickable = true;
    this._layoutAreaColorBlock()
};
$.extend(FR.Chart.HeatMapControlBar, {BAR_LONG: 26, BAR_SHORT: 13, BAR_GAP: 1});
$.extend(FR.Chart.HeatMapControlBar.prototype, {
    _layoutAreaColorBlock: function () {
        var g = 0, e = 0;
        var c = this.mapHotAreaColor.getAreaNumber();
        var k = FR.Chart.HeatMapControlBar.BAR_LONG;
        var h = FR.Chart.HeatMapControlBar.BAR_SHORT;
        var a = this.mapHotAreaColor.getMaxLabelWithIndex(0);
        var f = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, this.textAttr).width;
        var b = this.textAttr.frFont.size;
        var j = this.bounds.x;
        var i = this.bounds.y;
        switch (this.position) {
            case FR.Chart.Constants.LEFT:
                g = j + f + 5;
                e = i + b / 2;
                break;
            case FR.Chart.Constants.RIGHT:
                g = j;
                e = i + b / 2;
                break;
            default:
                g = j + f / 2;
                e = i + b + 5
        }
        if (this.isInTopOrBottom()) {
            for (var d = 0; d < c; d++) {
                var j = g + k * d + d;
                this.areaColorBlock.push(new FR.Chart.Bounds(j, e, k, h))
            }
        } else {
            for (var d = 0; d < c; d++) {
                var i = e + k * d + d;
                this.areaColorBlock.push(new FR.Chart.Bounds(g, i, h, k))
            }
        }
    }, draw: function (a) {
        if (this.isInTopOrBottom()) {
            this._drawTopOrBottom(a)
        } else {
            this._drawLeftOrRight(a)
        }
    }, _drawTopOrBottom: function (l) {
        this._drawColorBlocks(l);
        var h = FR.Chart.HeatMapControlBar.BAR_LONG * 2 + 1;
        var g = this.mapHotAreaColor.getNumberLabels();
        var b = this.textAttr.frFont.size;
        var c = FR.Chart.HeatMapControlBar.BAR_LONG + 1;
        var f = this.bounds.x;
        var a = this.bounds.y;
        var d = this.bounds.y + b + 5 + FR.Chart.HeatMapControlBar.BAR_SHORT + 5;
        for (var e = 0; e < g.length; e++) {
            var k = this._getFinalDrawLabel(g[e], h);
            var j = e % 2 === 0 ? a : d;
            this._drawLabel(k, f, j);
            f += c
        }
    }, _drawLeftOrRight: function (c) {
        this._drawColorBlocks(c);
        var f = this.bounds.width - FR.Chart.HeatMapControlBar.BAR_SHORT - 5;
        var a = this.bounds.y;
        var b = this.position == FR.Chart.Constants.RIGHT ? (this.bounds.x + FR.Chart.HeatMapControlBar.BAR_SHORT + 5) : this.bounds.x;
        var h = this.mapHotAreaColor.getNumberLabels();
        var g = FR.Chart.HeatMapControlBar.BAR_LONG + 1;
        for (var e = 0; e < h.length; e++) {
            var d = this._getFinalDrawLabel(h[e], f);
            this._drawLabel(d, b, a);
            a += g
        }
    }, _drawColorBlocks: function (a) {
        if (!a) {
            return
        }
        a.save();
        for (var c = 0; c < this.areaColorBlock.length; c++) {
            var b = this.mapHotAreaColor.getColorByIndex(c);
            if (this._isSeriesEnable(c)) {
                a.fillStyle = b
            } else {
                a.fillStyle = "rgba(128,128,128,0.8)"
            }
            this.areaColorBlock[c].paint(a)
        }
        a.restore()
    }, _getFinalDrawLabel: function (a, b) {
        var c = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, this.textAttr);
        if (c.width > b) {
            return FR.Chart.TextUtils.getTextWhenNotEnoughWidth(a, b, this.textAttr.frFont)
        }
        return a
    }, _drawLabel: function (b, a, d) {
        var c = $("<div>" + b + "</div>").css("position", "absolute").css("font", this.textAttr.frFont.getStringFont()).css("z-index", 1).css("color", this.textAttr.frFont.color).css("left", a).css("top", d);
        FR.Chart.DivCon.addDiv(FR.Chart.currentDivKey, c[0])
    }, containsPoint: function (a) {
        for (var b = 0, d = this.areaColorBlock.length; b < d; b++) {
            var c = this.areaColorBlock[b];
            if (c && c.containsPoint(a.x, a.y)) {
                return true
            }
        }
        return false
    }, findOnMoveGlyph: function (a, b) {
        if (this.containsPoint(a)) {
            b._hasfound = true;
            b._lastHover = this
        }
    }, onClick: function (a, d) {
        var b = this._getItemIndex(a);
        if (b !== -1) {
            d.needRefresh = true;
            var c = this.seriesList[b];
            if (c) {
                if (c.paintState >= FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                    c.paintState = FR.Chart.ChartPaintConstants.STATE_DISAPPEAR
                } else {
                    if (c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        c.paintState = FR.Chart.ChartPaintConstants.STATE_APPEAR
                    }
                }
            }
        }
    }, doOnMove: function (k, m, e, j) {
        var g = this._getItemIndex(m);
        if (this._isSeriesEnable(g)) {
            var b = this.areaColorBlock[g];
            var f = this.mapHotAreaColor.getColorByIndex(g);
            var d = new FR.Chart.Bounds(b.x - 2, b.y - 2, b.width + 4, b.height + 4);
            k.save();
            k.fillStyle = f;
            k.shadowBlur = 10;
            k.shadowColor = "rgba(0,0,0, 0.2)";
            d.paint(k);
            k.restore();
            var c = k;
            if (e && e.mapType != FR.Chart.MapType.Map_Normal) {
                c = j
            }
            var l = e.getSeriesPointsOfCurrentMap(g);
            c.save();
            e._saveClip4SeriesDrawThrowOutOfPlot(c, e);
            for (var h = 0; h < l.length; h++) {
                var a = l[h];
                a.doOnMoveWithoutTooltip(k, e, c)
            }
            c.restore()
        }
    }, _getItemIndex: function (a) {
        for (var b = 0, d = this.areaColorBlock.length;
             b < d; b++) {
            var c = this.areaColorBlock[b];
            if (c && c.containsPoint(a.x, a.y)) {
                return b
            }
        }
        return -1
    }, _isSeriesEnable: function (a) {
        if (this.seriesList && this.seriesList[a]) {
            var b = this.seriesList[a];
            return b.paintState >= FR.Chart.ChartPaintConstants.STATE_ENABLE
        }
        return false
    }, isInTopOrBottom: function () {
        return this.position == FR.Chart.Constants.TOP || this.position == FR.Chart.Constants.BOTTOM
    }
});
FR.Chart.Line2D = function (b, a) {
    this.startPoint = b;
    this.endPoint = a
};
$.extend(FR.Chart.Line2D.prototype, {
    startPoint: new FR.Chart.Point2D(), endPoint: new FR.Chart.Point2D(), getBounds2D: function () {
        var a = Math.min(this.startPoint.x, this.endPoint.x);
        var c = Math.max(this.startPoint.x, this.endPoint.x);
        var d = Math.min(this.startPoint.y, this.endPoint.y);
        var b = Math.max(this.startPoint.y, this.endPoint.y);
        return new FR.Chart.Bounds(a, d, c - a, b - d)
    }, isNeedRadialGradient: function () {
        return false
    }, transform: function (a) {
        var d = a.transform(this.startPoint);
        var c = a.transform(this.endPoint);
        var b = new FR.Chart.Line2D(d, c);
        return b
    }, draw: function (b, a) {
        if (a) {
            if (a == FR.Chart.Constants.LINE_THIN) {
                b.lineWidth = 1;
                this.draw(b);
                return
            } else {
                if (a == FR.Chart.Constants.LINE_MEDIUM) {
                    b.lineWidth = 2;
                    this.draw(b);
                    return
                } else {
                    if (a == FR.Chart.Constants.LINE_DASH || a == FR.Chart.Constants.LINE_HAIR || a == FR.Chart.Constants.LINE_HAIR2) {
                        b.lineWidth = 1
                    } else {
                        if (a == FR.Chart.Constants.LINE_THICK) {
                            b.lineWidth = 3;
                            this.draw(b);
                            return
                        } else {
                            if (a == FR.Chart.Constants.LINE_DOT) {
                                b.lineWidth = 1
                            } else {
                                if (a == FR.Chart.Constants.LINE_MEDIUM_DASH) {
                                    b.lineWidth = 2
                                } else {
                                    if (a == FR.Chart.Constants.LINE_DASH_DOT) {
                                        b.lineWidth = 1
                                    } else {
                                        if (a == FR.Chart.Constants.LINE_MEDIUM_DASH_DOT) {
                                            b.lineWidth = 2
                                        } else {
                                            if (a == FR.Chart.Constants.LINE_DASH_DOT_DOT) {
                                                b.lineWidth = 1
                                            } else {
                                                if (a == FR.Chart.Constants.LINE_MEDIUM_DASH_DOT_DOT) {
                                                    b.lineWidth = 2
                                                } else {
                                                    if (a == FR.Chart.Constants.LINE_SLANTED_DASH_DOT) {
                                                        b.lineWidth = 2
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            this.drawDotLine(b)
        } else {
            b.beginPath();
            b.moveTo(this.startPoint.x, this.startPoint.y);
            b.lineTo(this.endPoint.x, this.endPoint.y);
            b.stroke()
        }
    }, drawDotLine: function (n) {
        var e = 6;
        var l = this.startPoint.x;
        var k = this.startPoint.y;
        var h = this.endPoint.x;
        var f = this.endPoint.y;
        var a = l - h;
        var m = k - f;
        var g = 0;
        var b = 0;
        var j = 0;
        if (a === 0) {
            g = Math.abs(m) / e;
            b = 0;
            j = (k - f) > 0 ? -e : e
        } else {
            var c = Math.atan(m / a);
            b = e * Math.cos(c);
            j = e * Math.sin(c);
            g = Math.sqrt(a * a + m * m) / e
        }
        n.beginPath();
        if (g < 1) {
            n.moveTo(l + (h - l) * 0.95, k + (f - k) * 0.95);
            n.lineTo(h, f)
        } else {
            for (var d = 0; d < g - 0.5; d++) {
                n.moveTo(l + b * d, k + j * d);
                n.lineTo(l + b * (d + 0.5), k + j * (d + 0.5))
            }
        }
        n.stroke()
    }
});
FR.Chart.Line2D.relativeCCW = function (e, g, c, f, d, b) {
    c -= e;
    f -= g;
    d -= e;
    b -= g;
    var a = d * f - b * c;
    if (a === 0) {
        a = d * c + b * f;
        if (a > 0) {
            d -= c;
            b -= f;
            a = d * c + b * f;
            if (a < 0) {
                a = 0
            }
        }
    }
    return (a < 0) ? -1 : ((a > 0) ? 1 : 0)
};
FR.Chart.Bounds = function (b, d, c, a) {
    this.x = b;
    this.y = d;
    this.width = c;
    this.height = a;
    this.rect = true
};
$.extend(FR.Chart.Bounds.prototype, {
    initConstants: function (a) {
        a = a || {};
        this.x = a.x || 0;
        this.y = a.y || 0;
        this.width = a.width || 0;
        this.height = a.height || 0;
        this.isNigativeValue = a.isNigativeValue || false;
        this.isHorizontal4Bounds = a.isHorizontal4Bounds || false;
        this.is4RangePlot = a.is4RangePlot || false;
        this.isUnanimate = a.isUnanimate || false;
        this.is4StockPlotGlyph = false
    }, getBounds2D: function () {
        return this
    }, isNeedRadialGradient: function () {
        return false
    }, getMiddleX: function () {
        return this.x + this.width / 2
    }, getMiddleY: function () {
        return this.y + this.height / 2
    }, transform: function (a) {
        var c = new FR.Chart.Bounds();
        var d = a.transform({x: this.x, y: this.y});
        var b = a.transform({x: this.x + this.width, y: this.y + this.height});
        c.setRect(d.x, d.y, b.x - d.x, b.y - d.y);
        return c
    }, clone: function () {
        var a = new FR.Chart.Bounds(this.x, this.y, this.width, this.height);
        a.isNigativeValue = this.isNigativeValue;
        a.isHorizontal4Bounds = this.isHorizontal4Bounds;
        a.is4RangePlot = this.is4RangePlot;
        a.isUnanimate = this.isUnanimate;
        return a
    }, getLineGradient: function (a, b) {
        if (this.lineGradient) {
            return this.lineGradient
        }
        if (b) {
            this.lineGradient = a.createLinearGradient(this.x, this.y, this.x, this.y + this.height)
        } else {
            this.lineGradient = a.createLinearGradient(this.x, this.y, this.x + this.width, this.y)
        }
        return this.lineGradient
    }, paint: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSPaint(this);
        a.beginPath();
        a.moveTo(b.x, b.y);
        a.lineTo(b.x + b.width, b.y);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.lineTo(b.x, b.y + b.height);
        a.closePath();
        a.fill()
    }, draw: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x, b.y);
        a.lineTo(b.x + b.width, b.y);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.lineTo(b.x, b.y + b.height);
        a.closePath();
        a.stroke()
    }, drawWithOutBottom: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x, b.y + b.height);
        a.lineTo(b.x, b.y);
        a.lineTo(b.x + b.width, b.y);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.stroke()
    }, drawWithOutTop: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x, b.y);
        a.lineTo(b.x, b.y + b.height);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.lineTo(b.x + b.width, b.y);
        a.stroke()
    }, drawWithOutRight: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x + b.width, b.y);
        a.lineTo(b.x, b.y);
        a.lineTo(b.x, b.y + b.height);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.stroke()
    }, drawWithOutLeft: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x, b.y);
        a.lineTo(b.x + b.width, b.y);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.lineTo(b.x, b.y + b.height);
        a.stroke()
    }, drawLeftAndRight: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x, b.y + b.height);
        a.lineTo(b.x, b.y);
        a.moveTo(b.x + b.width, b.y);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.stroke()
    }, drawTopAndBottom: function (a) {
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        var b = FR.Chart.GraphHelper.dealRectShape4JSDraw(this);
        a.beginPath();
        a.moveTo(b.x, b.y);
        a.lineTo(b.x + b.width, b.y);
        a.moveTo(b.x, b.y + b.height);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.stroke()
    }, drawDragBorder: function (a) {
        if (this.isHorizontal4Bounds) {
            var b = new FR.Chart.Bounds(this.x, this.y - 3, this.width + 3, this.height + 6);
            if (b.width <= 0 || b.height <= 0) {
                return
            }
            var c = FR.Chart.GraphHelper.dealRectShape4JSDraw(b);
            a.beginPath();
            a.moveTo(c.x, c.y);
            a.lineTo(c.x + c.width, c.y);
            a.lineTo(c.x + c.width, c.y + c.height);
            a.lineTo(c.x, c.y + c.height);
            a.stroke()
        } else {
            var b = new FR.Chart.Bounds(this.x - 3, this.y - 3, this.width + 6, this.height + 3);
            if (b.width <= 0 || b.height <= 0) {
                return
            }
            var c = FR.Chart.GraphHelper.dealRectShape4JSDraw(b);
            a.beginPath();
            a.moveTo(c.x, c.y + c.height);
            a.lineTo(c.x, c.y);
            a.lineTo(c.x + c.width, c.y);
            a.lineTo(c.x + c.width, c.y + c.height);
            a.stroke()
        }
    }, setRect: function (a, d, b, c) {
        this.x = a;
        this.y = d;
        this.width = b;
        this.height = c
    }, containsPoint: function (a, c) {
        var b = new FR.Chart.Bounds(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
        return b.contains(a, c, 1, 1)
    }, contains: function (a, d, b, c) {
        if (this.x <= a && this.y <= d && ((this.x + this.width) >= (a + b)) && ((this.y + this.height) >= (d + c))) {
            return true
        }
        return false
    }, getStockAnimateShape: function (f) {
        var c = [];
        for (var d = 0; d < f; d++) {
            var b = this.x;
            var e = this.width;
            var a = FR.Chart.ChartEase.easeInCirc(d + 1, 0, this.height, f);
            if (this.upDown < 0) {
                var g = this.y;
                c[d] = new FR.Chart.Bounds(b, g, e, a)
            } else {
                var g = this.y + this.height - a;
                c[d] = new FR.Chart.Bounds(b, g, e, a)
            }
        }
        return c
    }, getActionChangeAnimateShape: function (c, g, d) {
        if (d <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (d == FR.Chart.ChartPaintConstants.STATE_APPEAR || !g) {
            return this.getActionDefaultAnimateShape(c)
        }
        var h = [];
        var k = parseInt(this.x - g.x);
        var j = parseInt(this.y - g.y);
        var e = parseInt(this.width - g.width);
        var a = parseInt(this.height - g.height);
        for (var f = 0; f < c; f++) {
            if (this.isUnanimate) {
                h[f] = this
            } else {
                var m = FR.Chart.ChartEase.easeInCirc(f + 1, g.x, k, c);
                var l = FR.Chart.ChartEase.easeInCirc(f + 1, g.y, j, c);
                var b = FR.Chart.ChartEase.easeInCirc(f + 1, g.width, e, c);
                var n = FR.Chart.ChartEase.easeInCirc(f + 1, g.height, a, c);
                h[f] = new FR.Chart.Bounds(m, l, b, n)
            }
        }
        return h
    }, getActionDefaultAnimateShape: function (d) {
        var a = [];
        for (var b = 0;
             b < d; b++) {
            if (this.isUnanimate) {
                a[b] = this
            } else {
                if (this.is4StockPlotGlyph) {
                } else {
                    if (this.isHorizontal4Bounds) {
                        var c = FR.Chart.ChartEase.easeOutQuint(b + 1, 0, this.width, d);
                        if (this.isNigativeValue !== this.axisReversed) {
                            a[b] = new FR.Chart.Bounds(this.x - c + this.width, this.y, c, this.height)
                        } else {
                            a[b] = new FR.Chart.Bounds(this.x, this.y, c, this.height)
                        }
                    } else {
                        if (this.is4RangePlot) {
                            a[b] = new FR.Chart.Bounds(FR.Chart.ChartEase.easeOutQuint(b + 1, 0, this.x, d), this.y, this.width, this.height)
                        } else {
                            var e = FR.Chart.ChartEase.easeOutQuint(b + 1, 0, this.height, d);
                            if (this.isNigativeValue !== this.axisReversed) {
                                a[b] = new FR.Chart.Bounds(this.x, this.y, this.width, e)
                            } else {
                                a[b] = new FR.Chart.Bounds(this.x, this.y + this.height - e, this.width, e)
                            }
                        }
                    }
                }
            }
        }
        return a
    }, getAnimateShape: function (b, a, d, c) {
        if (a == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
            return this.getActionChangeAnimateShape(b, d, c)
        } else {
            if (this.upDown) {
                return this.getStockAnimateShape(b)
            } else {
                return this.getActionDefaultAnimateShape(b)
            }
        }
    }, largerThan: function (a) {
        if (a.width && a.height) {
            return this.width * this.height > a.width * a.height
        }
    }
});
FR.Chart.RoundBounds = function (b, f, e, a, c, d) {
    this.x = b;
    this.y = f;
    this.width = e;
    this.height = a;
    this.arcWidth = c;
    this.arcHeight = d
};
$.extend(FR.Chart.RoundBounds.prototype, {
    x: 0, y: 0, width: 0, height: 0, arcWidth: 0, arcHeight: 0, paint: function (a) {
        if (this.width === 0 || this.height === 0) {
            return
        }
        this.roundPath(a);
        a.fill()
    }, draw: function (a) {
        if (this.width === 0 || this.height === 0) {
            return
        }
        this.roundPath(a);
        a.stroke()
    }, containsPoint: function (a, c) {
        var b = new FR.Chart.Bounds(this.x - 2, this.y - 2, this.width + 4, this.height + 4);
        return b.contains(a, c, 1, 1)
    }, contains: function (a, d, b, c) {
        if (this.x <= a && this.y <= d && ((this.x + this.width) >= (a + b)) && ((this.y + this.height) >= (d + c))) {
            return true
        }
        return false
    }, roundPath: function (c) {
        var b = Math.round(this.x), e = Math.round(this.y), a = Math.round(this.height), d = Math.round(this.width);
        c.beginPath();
        c.moveTo(b, e + this.arcHeight);
        c.lineTo(b, e + a - this.arcHeight);
        c.quadraticCurveTo(b, e + a, b + this.arcWidth, e + a);
        c.lineTo(b + d - this.arcWidth, e + a);
        c.quadraticCurveTo(b + d, e + a, b + d, e + a - this.arcHeight);
        c.lineTo(b + d, e + this.arcHeight);
        c.quadraticCurveTo(b + d, e, b + d - this.arcWidth, e);
        c.lineTo(b + this.arcWidth, e);
        c.quadraticCurveTo(b, e, b, e + this.arcHeight)
    }, drawRightBottomShadow: function (c) {
        var b = Math.round(this.x), e = Math.round(this.y), a = Math.round(this.height), d = Math.round(this.width);
        c.beginPath();
        c.moveTo(b, e + a - this.arcHeight);
        c.quadraticCurveTo(b, e + a, b + this.arcWidth, e + a);
        c.lineTo(b + d - this.arcWidth, e + a);
        c.quadraticCurveTo(b + d, e + a, b + d, e + a - this.arcHeight);
        c.lineTo(b + d, e + this.arcHeight);
        c.quadraticCurveTo(b + d, e, b + d - this.arcWidth, e);
        c.stroke()
    }, getBounds2D: function () {
        return new FR.Chart.Bounds(this.x, this.y, this.width, this.height)
    }, isNeedRadialGradient: function () {
        return false
    }
});
FR.Chart.Marker = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.size = FR.pick(a.size, 4.5);
        this.gapSize = 2;
        this.color = a.color;
        this.background = FR.Chart.AbstractBackground.initBackground(a.background);
        this.x = 0;
        this.y = 0
    }, paintBackgroundBiggerMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c)) {
            this.paintBackroungMarker(b, a, c);
            this.x = a;
            this.y = c
        }
    }, paintBackroungMarker: function (b, a, c) {
        this.paintMarker(b, a, c)
    }, paint: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c)) {
            if (!b) {
                return
            }
            b.save();
            b.lineWidth = 2;
            this.paintMarker(b, a, c);
            b.restore();
            this.x = a;
            this.y = c
        }
    }, getMarkerType: function () {
        return "Maker"
    }, drawDragBorder: function (a) {
        a.lineWidth = 2;
        this.paintMarker(a, this.x, this.y)
    }
});
$.extend(FR.Chart.Marker, {
    RoundMarker: "RoundMarker",
    RoundFilledMarker: "RoundFilledMarker",
    SquareFilledMarker: "SquareFilledMarker",
    TriangleFilledMarker: "TriangleFilledMarker",
    DiamondFilledMarker: "DiamondFilledMarker",
    CrossMarker: "CrossMarker",
    PlusSignMarker: "PlusSignMarker",
    CircleFilledMarker: "CircleFilledMarker",
    MinusSignMarker: "MinusSignMarker",
    DiamondMarker: "DiamondMarker",
    SquareMarker: "SquareMarker",
    TriangleMarker: "TriangleMarker",
    CircleMarker: "CircleMarker",
    AllEqualMarker: "AllEqualMarker",
    ClockLineMarker: "ClockLineMarker",
    AntiClockLineMarker: "AntiClockLineMarker",
    StarMarker: "StarMarker",
    XMarker: "XMarker",
    NullMarker: "NullMarker",
    PointMarker: "PointMarker",
    DowJonesMarker: "DowJonesMarker"
});
FR.Chart.AntiClockLineMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.AntiClockLineMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.AntiClockLineMarker()
    }, paintMarker: function (b, a, d) {
        if (this.background && !isNaN(a) && !isNaN(d) && this.size) {
            var c = this.size;
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c * 0.5, d - c), new FR.Chart.Point2D(a + c, d + c * 0.5)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a, d - c), new FR.Chart.Point2D(a + c, d)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d - c), new FR.Chart.Point2D(a + c, d + c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a + c * 0.5, d - c), new FR.Chart.Point2D(a + c, d - c * 0.5)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d - c * 0.5), new FR.Chart.Point2D(a + c * 0.5, d + c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d), new FR.Chart.Point2D(a, d + c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d + c * 0.5), new FR.Chart.Point2D(a - c * 0.5, d + c)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.AntiClockLineMarker
    }
});
FR.Chart.ClockLineMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.ClockLineMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.ClockLineMarker()
    }, paintMarker: function (b, a, d) {
        if (this.background && !isNaN(a) && !isNaN(d) && this.size) {
            var c = this.size;
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d - c * 0.5), new FR.Chart.Point2D(a - c * 0.5, d - c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d), new FR.Chart.Point2D(a, d - c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d + c * 0.5), new FR.Chart.Point2D(a + c * 0.5, d - c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c, d + c), new FR.Chart.Point2D(a + c, d - c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - c * 0.5, d + c), new FR.Chart.Point2D(a + c, d - c * 0.5)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a, d + c), new FR.Chart.Point2D(a + c, d)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a + c * 0.5, d + c), new FR.Chart.Point2D(a + c, d + c * 0.5)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.ClockLineMarker
    }
});
FR.Chart.PointMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.PointMarker.superclass.initConstants.apply(this, [a])
    }, paintMarker: function (h, g, e) {
        if (this.background && !isNaN(g) && !isNaN(e) && this.size) {
            var k = this.size;
            var d = 4;
            for (var c = 0; c < d; c++) {
                for (var b = 0; b < d; b++) {
                    var a = g - k + 2 * k * c / d;
                    var f = e - k + 2 * k * b / d;
                    this.background.draw(h, new FR.Chart.Line2D(new FR.Chart.Point2D(a, f), new FR.Chart.Point2D(a, f)))
                }
            }
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.RoundMarker
    }, drawDragBorder: function (a) {
    }
});
FR.Chart.AllEqualMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.AllEqualMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.AllEqualMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c - this.size), new FR.Chart.Point2D(a + this.size, c - this.size)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c), new FR.Chart.Point2D(a + this.size, c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c + this.size), new FR.Chart.Point2D(a + this.size, c + this.size)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.AllEqualMarker
    }
});
FR.Chart.MinusSignMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.MinusSignMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.MinusSignMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c - this.size / 2), new FR.Chart.Point2D(a + this.size, c - this.size / 2)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c + this.size / 2), new FR.Chart.Point2D(a + this.size, c + this.size / 2)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.MinusSignMarker
    }
});
FR.Chart.CircleFilledMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.CircleFilledMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.CircleFilledMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, new FR.Chart.Arc2D(a, c, this.size / 2, 0, 360, FR.Chart.Arc2D.CHORD))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.CircleFilledMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Arc2D(this.x, this.y, this.size / 2 + 3, 0, 360, FR.Chart.Arc2D.CHORD);
        b.draw(a)
    }
});
FR.Chart.CircleMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.CircleMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.CircleMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Arc2D(a, c, this.size / 2, 0, 360, FR.Chart.Arc2D.CHORD))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.CircleMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Arc2D(this.x, this.y, this.size / 2 + 3, 0, 360, FR.Chart.Arc2D.CHORD);
        b.draw(a)
    }
});
FR.Chart.RoundMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.RoundMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.RoundMarker()
    }, paintMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.draw(b, new FR.Chart.Arc2D(a, d, this.size, 0, 360, FR.Chart.Arc2D.CHORD))
    }, paintBackroungMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.paint(b, new FR.Chart.Arc2D(a, d, this.size, 0, 360, FR.Chart.Arc2D.CHORD))
    }, getMarkerType: function () {
        return FR.Chart.Marker.RoundMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Arc2D(this.x, this.y, this.size + 3, 0, 360, FR.Chart.Arc2D.CHORD);
        b.draw(a)
    }
});
FR.Chart.RoundFilledMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.RoundFilledMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.RoundFilledMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, new FR.Chart.Arc2D(a, c, this.size, 0, 360, FR.Chart.Arc2D.CHORD))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.RoundFilledMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Arc2D(this.x, this.y, this.size + 3, 0, 360, FR.Chart.Arc2D.CHORD);
        b.draw(a)
    }
});
FR.Chart.CrossMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.CrossMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.CrossMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c), new FR.Chart.Point2D(a + this.size, c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a, c + this.size), new FR.Chart.Point2D(a, c - this.size)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.CrossMarker
    }
});
FR.Chart.DiamondFilledMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.DiamondFilledMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.DiamondFilledMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, this.getPath(a, c, this.size))
        }
    }, getPath: function (a, g, e) {
        var d = [a - e, a, a + e, a];
        var b = [g, g - e, g, g + e];
        var f = new FR.Chart.GeneralPath();
        f.moveTo(d[d.length - 1], b[d.length - 1]);
        for (var c = 0; c < d.length; c++) {
            f.lineTo(d[c], b[c])
        }
        return f
    }, getMarkerType: function () {
        return FR.Chart.Marker.DiamondFilledMarker
    }, drawDragBorder: function (a) {
        var d = [this.x - this.size - 3 * Math.sqrt(2), this.x, this.x + this.size + 3 * Math.sqrt(2), this.x];
        var b = [this.y, this.y - this.size - 3 * Math.sqrt(2), this.y, this.y + this.size + 3 * Math.sqrt(2)];
        var e = new FR.Chart.GeneralPath();
        e.moveTo(d[d.length - 1], b[d.length - 1]);
        for (var c = 0; c < d.length; c++) {
            e.lineTo(d[c], b[c])
        }
        e.draw(a)
    }
});
FR.Chart.DiamondMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.DiamondMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.DiamondMarker()
    }, paintMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.draw(b, this.getPath(a, d, this.size))
    }, paintBackroungMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.paint(b, this.getPath(a, d, this.size))
    }, getPath: function (a, g, e) {
        var d = [a - e, a, a + e, a];
        var b = [g, g - e, g, g + e];
        var f = new FR.Chart.GeneralPath();
        f.moveTo(d[d.length - 1], b[d.length - 1]);
        for (var c = 0; c < d.length; c++) {
            f.lineTo(d[c], b[c])
        }
        return f
    }, getMarkerType: function () {
        return FR.Chart.Marker.DiamondMarker
    }, drawDragBorder: function (a) {
        var d = [this.x - this.size - 3 * Math.sqrt(2), this.x, this.x + this.size + 3 * Math.sqrt(2), this.x];
        var b = [this.y, this.y - this.size - 3 * Math.sqrt(2), this.y, this.y + this.size + 3 * Math.sqrt(2)];
        var e = new FR.Chart.GeneralPath();
        e.moveTo(d[d.length - 1], b[d.length - 1]);
        for (var c = 0; c < d.length; c++) {
            e.lineTo(d[c], b[c])
        }
        e.draw(a)
    }
});
FR.Chart.DowJonesMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.DowJonesMarker.superclass.initConstants.apply(this, [a])
    }, paintMarker: function (b, a, d) {
        if (this.background && !isNaN(a) && !isNaN(d) && this.size) {
            this.size = this.size / 2;
            b.lineWidth = FR.Chart.Constants.LINE_THIN;
            var c = new FR.Chart.GeneralPath();
            c.moveTo(a, d);
            c.lineTo(a + this.size, d);
            this.background.draw(b, c)
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.RoundMarker
    }
});
FR.Chart.NullMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.NullMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.NullMarker()
    }, paintMarker: function (b, a, c) {
    }, getMarkerType: function () {
        return FR.Chart.Marker.NullMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Bounds(this.x - 4, this.y - 4, 8, 8);
        b.draw(a)
    }
});
FR.Chart.PlusSignMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.PlusSignMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.PlusSignMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c + this.size), new FR.Chart.Point2D(a + this.size, c + this.size)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a, c + this.size), new FR.Chart.Point2D(a, c - this.size)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.PlusSignMarker
    }
});
FR.Chart.SquareFilledMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.SquareFilledMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.SquareFilledMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, new FR.Chart.Bounds(a - 0.75 * this.size, c - 0.75 * this.size, 1.5 * this.size, 1.5 * this.size))
        }
    }, paintBackroungMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, new FR.Chart.Bounds(a - 0.75 * (this.size - 2) - 2, c - 0.75 * (this.size - 2) - 2, 1.5 * (this.size - 2) + 4, 1.5 * (this.size - 2) + 4))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.SquareFilledMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Bounds(this.x - 0.75 * this.size - 3, this.y - 0.75 * this.size - 3, 1.5 * this.size + 6, 1.5 * this.size + 6);
        b.draw(a)
    }
});
FR.Chart.SquareMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.SquareMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.SquareMarker()
    }, paintMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.draw(b, new FR.Chart.Bounds(a - 0.75 * this.size, d - 0.75 * this.size, 1.5 * this.size, 1.5 * this.size))
    }, paintBackroungMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, new FR.Chart.Bounds(a - 0.75 * (this.size - 2) - 2, c - 0.75 * (this.size - 2) - 2, 1.5 * (this.size - 2) + 4, 1.5 * (this.size - 2) + 4))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.SquareMarker
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Bounds(this.x - 0.75 * this.size - 3, this.y - 0.75 * this.size - 3, 1.5 * this.size + 6, 1.5 * this.size + 6);
        b.draw(a)
    }
});
FR.Chart.StarMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.StarMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.StarMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c), new FR.Chart.Point2D(a + this.size, c)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a, c + this.size), new FR.Chart.Point2D(a, c - this.size)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c - this.size), new FR.Chart.Point2D(a + this.size, c + this.size)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c + this.size), new FR.Chart.Point2D(a + this.size, c - this.size)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.StarMarker
    }
});
FR.Chart.TriangleFilledMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.TriangleFilledMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.TriangleFilledMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.paint(b, this.getPath(a, c, this.size))
        }
    }, getPath: function (a, g, e) {
        var d = [a - e, a + e, a];
        var b = [g + e, g + e, g - e];
        var f = new FR.Chart.GeneralPath();
        f.moveTo(d[d.length - 1], b[b.length - 1]);
        for (var c = 0; c < d.length; c++) {
            f.lineTo(d[c], b[c])
        }
        return f
    }, getMarkerType: function () {
        return FR.Chart.Marker.TriangleFilledMarker
    }, drawDragBorder: function (a) {
        var d = [this.x - this.size - 3 * Math.sqrt(3), this.x + this.size + 3 * Math.sqrt(3), this.x];
        var b = [this.y + this.size + 3, this.y + this.size + 3, this.y - this.size - 6];
        var e = new FR.Chart.GeneralPath();
        e.moveTo(d[d.length - 1], b[b.length - 1]);
        for (var c = 0; c < d.length; c++) {
            e.lineTo(d[c], b[c])
        }
        e.draw(a)
    }
});
FR.Chart.TriangleMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.TriangleMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.TriangleMarker()
    }, paintMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.draw(b, this.getPath(a, d, this.size))
    }, paintBackroungMarker: function (b, a, d) {
        var c = this.background && !isNaN(a) && !isNaN(d) && this.size;
        if (!c) {
            return
        }
        this.background.paint(b, this.getPath(a, d, this.size))
    }, getPath: function (a, g, e) {
        var d = [a - e, a + e, a];
        var b = [g + e, g + e, g - e];
        var f = new FR.Chart.GeneralPath();
        f.moveTo(d[d.length - 1], b[b.length - 1]);
        for (var c = 0; c < d.length; c++) {
            f.lineTo(d[c], b[c])
        }
        return f
    }, getMarkerType: function () {
        return FR.Chart.Marker.TriangleMarker
    }, drawDragBorder: function (a) {
        var d = [this.x - this.size - 3 * Math.sqrt(3), this.x + this.size + 3 * Math.sqrt(3), this.x];
        var b = [this.y + this.size + 3, this.y + this.size + 3, this.y - this.size - 6];
        var e = new FR.Chart.GeneralPath();
        e.moveTo(d[d.length - 1], b[b.length - 1]);
        for (var c = 0; c < d.length; c++) {
            e.lineTo(d[c], b[c])
        }
        e.draw(a)
    }
});
FR.Chart.XMarker = FR.extend(FR.Chart.Marker, {
    initConstants: function (a) {
        FR.Chart.XMarker.superclass.initConstants.apply(this, [a])
    }, clone: function () {
        return new FR.Chart.XMarker()
    }, paintMarker: function (b, a, c) {
        if (this.background && !isNaN(a) && !isNaN(c) && this.size) {
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c - this.size), new FR.Chart.Point2D(a + this.size, c + this.size)));
            this.background.draw(b, new FR.Chart.Line2D(new FR.Chart.Point2D(a - this.size, c + this.size), new FR.Chart.Point2D(a + this.size, c - this.size)))
        }
    }, getMarkerType: function () {
        return FR.Chart.Marker.XMarker
    }
});
FR.Chart.GeneralPath = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (b) {
        this.x = [];
        this.y = [];
        this.type = [];
        this.ctrl = [];
        b = b || {};
        if (b.x) {
            for (var a = 0; a < b.x.length; a++) {
                if (b.type[a] == FR.Chart.GeneralPath.MOVE_TO) {
                    this.moveTo(b.x[a], b.y[a])
                } else {
                    if (b.type[a] == FR.Chart.GeneralPath.LINE_TO) {
                        this.lineTo(b.x[a], b.y[a])
                    } else {
                        if (b.type[a] == FR.Chart.GeneralPath.QUAD_TO) {
                            this.quadTo(b.ctrl[a].x, b.ctrl[a].y, b.x[a], b.y[a])
                        } else {
                            if (b.type[a] == FR.Chart.GeneralPath.CURVE_TO) {
                                this.curveTo(b.ctrl[a].x0, b.ctrl[a].y0, b.ctrl[a].x1, b.ctrl[a].y1, b.x[a], b.y[a])
                            } else {
                                if (b.type[a] == FR.Chart.GeneralPath.CLOSE) {
                                    this.closePath()
                                }
                            }
                        }
                    }
                }
            }
        }
    }, transform: function (c) {
        var f = new FR.Chart.GeneralPath();
        for (var e = 0; e < this.x.length; e++) {
            if (this.type[e] == FR.Chart.GeneralPath.MOVE_TO) {
                var b = c.transform({x: this.x[e], y: this.y[e]});
                f.moveTo(b.x, b.y)
            } else {
                if (this.type[e] == FR.Chart.GeneralPath.LINE_TO) {
                    var b = c.transform({x: this.x[e], y: this.y[e]});
                    f.lineTo(b.x, b.y)
                } else {
                    if (this.type[e] == FR.Chart.GeneralPath.QUAD_TO) {
                        var b = c.transform({x: this.x[e], y: this.y[e]});
                        var g = c.transform({x: this.ctrl[e].x, y: this.ctrl[e].y});
                        f.quadTo(g.x, g.y, b.x, b.y)
                    } else {
                        if (this.type[e] == FR.Chart.GeneralPath.CURVE_TO) {
                            var b = c.transform({x: this.x[e], y: this.y[e]});
                            var d = c.transform({x: this.ctrl[e][0].x, y: this.ctrl[e][0].y});
                            var a = c.transform({x: this.ctrl[e][1].x, y: this.ctrl[e][1].y});
                            f.curveTo(d.x, d.y, a.x, a.y, b.x, b.y)
                        } else {
                            if (this.type[e] == FR.Chart.GeneralPath.CLOSE) {
                                f.closePath()
                            }
                        }
                    }
                }
            }
        }
        return f
    }, draw: function (b, a) {
        if (this.x.length <= 0) {
            return
        }
        if (a) {
            b.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(a)
        }
        b.beginPath();
        for (var c = 0; c < this.x.length; c++) {
            if (c + 1 < this.x.length) {
                if (this.type[c + 1] == FR.Chart.GeneralPath.LINE_TO || this.type[c + 1] == FR.Chart.GeneralPath.CLOSE) {
                    b.moveTo(this.x[c], this.y[c]);
                    b.lineTo(this.x[c + 1], this.y[c + 1])
                } else {
                    if (this.type[c + 1] == FR.Chart.GeneralPath.QUAD_TO) {
                        b.moveTo(this.x[c], this.y[c]);
                        b.quadraticCurveTo(this.ctrl[c + 1].x, this.ctrl[c + 1].y, this.x[c + 1], this.y[c + 1])
                    } else {
                        if (this.type[c + 1] == FR.Chart.GeneralPath.CURVE_TO) {
                            b.moveTo(this.x[c], this.y[c]);
                            b.bezierCurveTo(this.ctrl[c + 1][0].x, this.ctrl[c + 1][0].y, this.ctrl[c + 1][1].x, this.ctrl[c + 1][1].y, this.x[c + 1], this.y[c + 1])
                        }
                    }
                }
            }
        }
        b.stroke()
    }, drawDragBorder: function (a) {
    }, paint: function (a) {
        a.beginPath();
        for (var b = 0; b < this.x.length; b++) {
            if (this.type[b] == FR.Chart.GeneralPath.MOVE_TO || b === 0) {
                a.moveTo(this.x[b], this.y[b])
            } else {
                if (this.type[b] == FR.Chart.GeneralPath.LINE_TO || this.type[b] == FR.Chart.GeneralPath.CLOSE) {
                    a.lineTo(this.x[b], this.y[b])
                } else {
                    if (this.type[b] == FR.Chart.GeneralPath.QUAD_TO) {
                        a.quadraticCurveTo(this.ctrl[b].x, this.ctrl[b].y, this.x[b], this.y[b])
                    } else {
                        if (this.type[b] == FR.Chart.GeneralPath.CURVE_TO) {
                            a.bezierCurveTo(this.ctrl[b][0].x, this.ctrl[b][0].y, this.ctrl[b][1].x, this.ctrl[b][1].y, this.x[b], this.y[b])
                        }
                    }
                }
            }
        }
        a.fill()
    }, getAnimateShape: function (e, n, j, a) {
        if (this.centerPoint) {
            return this.getAnimateRadarPath(e, a)
        }
        if (a <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        var l = [];
        for (var h = 0; h < e; h++) {
            var u = new FR.Chart.GeneralPath();
            var s = new FR.Chart.GeneralPath();
            l[h] = u;
            var q = this.x.length;
            if (this.type[q - 1] == FR.Chart.GeneralPath.CLOSE) {
                q--
            }
            for (var o = 0; o < q; o++) {
                if (o < q / 2) {
                    var r = this.x[o];
                    var d = this.y[o];
                    var p = this.x[q - 1 - o];
                    var b = this.y[q - 1 - o];
                    if (n == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && j && j.x[o] && j.y[o]) {
                        p = j.x[o];
                        b = j.y[o]
                    }
                    var g = FR.Chart.ChartEase.easeOutQuint(h + 1, p, r - p, e);
                    var f = FR.Chart.ChartEase.easeOutQuint(h + 1, b, d - b, e);
                    if (this.type[o] == FR.Chart.GeneralPath.MOVE_TO) {
                        FR.Chart.FoldLine.curveTo(u, s);
                        s.clear();
                        u.moveTo(g, f)
                    } else {
                        if (this.type[o] == FR.Chart.GeneralPath.LINE_TO) {
                            FR.Chart.FoldLine.curveTo(u, s);
                            s.clear();
                            u.lineTo(g, f)
                        } else {
                            if (this.type[o] == FR.Chart.GeneralPath.CLOSE) {
                                FR.Chart.FoldLine.curveTo(u, s);
                                s.clear();
                                u.closePath()
                            } else {
                                if (this.type[o] == FR.Chart.GeneralPath.QUAD_TO) {
                                    if (s.x.length === 0) {
                                        s.moveTo(u.x[u.x.length - 1], u.y[u.y.length - 1])
                                    }
                                    s.lineTo(g, f)
                                } else {
                                    if (this.type[o] === FR.Chart.GeneralPath.CURVE_TO) {
                                        if (s.x.length === 0) {
                                            s.moveTo(u.x[u.x.length - 1], u.y[u.y.length - 1])
                                        }
                                        s.lineTo(g, f)
                                    }
                                }
                            }
                        }
                    }
                } else {
                    FR.Chart.FoldLine.curveTo(u, s);
                    s.clear();
                    var g = this.x[o];
                    var f = this.y[o];
                    if (n == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && j && j.x[o] && j.y[o]) {
                        g = FR.Chart.ChartEase.easeOutQuint(h + 1, j.x[o], g - j.x[o], e);
                        f = FR.Chart.ChartEase.easeOutQuint(h + 1, j.y[o], f - j.y[o], e)
                    }
                    if (this.type[o] == FR.Chart.GeneralPath.LINE_TO) {
                        u.lineTo(g, f)
                    } else {
                        if (this.type[o] == FR.Chart.GeneralPath.CLOSE) {
                            u.closePath()
                        } else {
                            if (this.type[o] == FR.Chart.GeneralPath.QUAD_TO) {
                                var t = {x: this.ctrl[o].x, y: this.ctrl[o].y};
                                if (n == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && j) {
                                    t.x = FR.Chart.ChartEase.easeOutQuint(h + 1, j.ctrl[o].x, this.ctrl[o].x - j.ctrl[o].x, e);
                                    t.y = FR.Chart.ChartEase.easeOutQuint(h + 1, j.ctrl[o].y, this.ctrl[o].y - j.ctrl[o].y, e)
                                }
                                u.quadTo(t.x, t.y, g, f)
                            } else {
                                if (this.type[o] == FR.Chart.GeneralPath.CURVE_TO) {
                                    var m = {x: this.ctrl[o][0].x, y: this.ctrl[o][0].y};
                                    var k = {x: this.ctrl[o][1].x, y: this.ctrl[o][1].y};
                                    if (n == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && j) {
                                        m.x = FR.Chart.ChartEase.easeOutQuint(h + 1, j.ctrl[o][0].x, this.ctrl[o][0].x - j.ctrl[o][0].x, e);
                                        m.y = FR.Chart.ChartEase.easeOutQuint(h + 1, j.ctrl[o][0].y, this.ctrl[o][0].y - j.ctrl[o][0].y, e);
                                        k.x = FR.Chart.ChartEase.easeOutQuint(h + 1, j.ctrl[o][1].x, this.ctrl[o][1].x - j.ctrl[o][1].x, e);
                                        k.y = FR.Chart.ChartEase.easeOutQuint(h + 1, j.ctrl[o][1].y, this.ctrl[o][1].y - j.ctrl[o][1].y, e)
                                    }
                                    u.curveTo(m.x, m.y, k.x, k.y, g, f)
                                }
                            }
                        }
                    }
                }
            }
        }
        return l
    }, getTopFoldLineAnimateShape: function (d, o, h, e) {
        var c = [];
        for (var p = 0; p < d; p++) {
            var j = new FR.Chart.GeneralPath();
            var g = new FR.Chart.GeneralPath();
            c[p] = j;
            var q = this.x.length;
            if (this.type[q - 1] == FR.Chart.GeneralPath.CLOSE) {
                q--
            }
            for (var f = 0; f < q / 2; f++) {
                var b = this.x[f];
                var n = this.y[f];
                var a = this.x[q - 1 - f];
                var l = this.y[q - 1 - f];
                if (o == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && h && h.x[f] && h.y[f]) {
                    a = h.x[f];
                    l = h.y[f]
                }
                var m = FR.Chart.ChartEase.easeOutQuint(p + 1, a, b - a, d);
                var k = FR.Chart.ChartEase.easeOutQuint(p + 1, l, n - l, d);
                if (this.type[f] == FR.Chart.GeneralPath.MOVE_TO) {
                    FR.Chart.FoldLine.curveTo(j, g);
                    g.clear();
                    j.moveTo(m, k)
                } else {
                    if (this.type[f] == FR.Chart.GeneralPath.LINE_TO) {
                        FR.Chart.FoldLine.curveTo(j, g);
                        g.clear();
                        j.lineTo(m, k)
                    } else {
                        if (this.type[f] == FR.Chart.GeneralPath.CLOSE) {
                            FR.Chart.FoldLine.curveTo(j, g);
                            g.clear();
                            j.closePath()
                        } else {
                            if (this.type[f] == FR.Chart.GeneralPath.QUAD_TO) {
                                if (g.x.length === 0) {
                                    g.moveTo(j.x[j.x.length - 1], j.y[j.y.length - 1])
                                }
                                g.lineTo(m, k)
                            } else {
                                if (this.type[f] == FR.Chart.GeneralPath.CURVE_TO) {
                                    if (g.x.length === 0) {
                                        g.moveTo(j.x[j.x.length - 1], j.y[j.y.length - 1])
                                    }
                                    g.lineTo(m, k)
                                }
                            }
                        }
                    }
                }
            }
            FR.Chart.FoldLine.curveTo(j, g);
            g.clear()
        }
        return c
    }, getAnimatePath: function (b, f, e, c) {
        if (this.centerPoint) {
            return this.getAnimateRadarPath(b, c)
        }
        if (c <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (this.isXYScatter) {
            return this.getAnimateXYScatterPath(b, f, e, c)
        }
        if (this.upDown) {
            return this.getAnimateHighLowLinePath(b)
        }
        if (!this.yZero) {
            return this.getAnimateLinePath(b, f, e, c)
        }
        var a = [];
        for (var g = 0; g < b; g++) {
            var j = new FR.Chart.GeneralPath();
            for (var d = 0; d < this.x.length; d++) {
                var h = FR.Chart.ChartEase.easeOutQuint(g + 1, this.yZero, this.y[d] - this.yZero, b);
                if (this.type[d] == FR.Chart.GeneralPath.MOVE_TO) {
                    j.moveTo(this.x[d], h)
                } else {
                    if (this.type[d] == FR.Chart.GeneralPath.LINE_TO) {
                        j.lineTo(this.x[d], h)
                    } else {
                        if (this.type[d] == FR.Chart.GeneralPath.CLOSE) {
                            j.closePath()
                        } else {
                            if (this.type[d] == FR.Chart.GeneralPath.QUAD_TO) {
                                j.quadTo(this.ctrl[d].x, FR.Chart.ChartEase.easeOutQuint(g + 1, this.yZero, this.ctrl[d].y - this.yZero, b), this.x[d], h)
                            } else {
                                if (this.type[d] == FR.Chart.GeneralPath.CURVE_TO) {
                                    j.curveTo(this.ctrl[d][0].x, FR.Chart.ChartEase.easeOutQuint(g + 1, this.yZero, this.ctrl[d][0].y - this.yZero, b), this.ctrl[d][1].x, FR.Chart.ChartEase.easeOutQuint(g + 1, this.yZero, this.ctrl[d][1].y - this.yZero, b), this.x[d], h)
                                }
                            }
                        }
                    }
                }
            }
            a[g] = j
        }
        return a
    }, getAnimateXYScatterPath: function (c, b, g, f) {
        if (b == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && g && f == FR.Chart.ChartPaintConstants.STATE_ENABLE) {
            return this.getAnimateLinePath(c, b, g, f)
        }
        var d = [];
        for (var a = 0;
             a < c; a++) {
            var e = new FR.Chart.GeneralPath();
            if (f == FR.Chart.ChartPaintConstants.STATE_ENABLE && b == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
                d[a] = this
            } else {
                if (f == FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
                    d[a] = e
                } else {
                    d[a] = e;
                    if (a == c - 1) {
                        d[a] = this
                    }
                }
            }
        }
        return d
    }, getAnimateLinePath: function (d, l, h, e) {
        var c = [];
        var a = h && h.x.length > 0 && h.x.length > 0;
        if (l == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && a && e == FR.Chart.ChartPaintConstants.STATE_ENABLE) {
            for (var m = 0; m < d; m++) {
                var p = new FR.Chart.GeneralPath();
                for (var f = 0; f < this.x.length; f++) {
                    var o = FR.Chart.ChartEase.easeOutQuint(m + 1, h.y[f], this.y[f] - h.y[f], d);
                    if (this.type[f] == FR.Chart.GeneralPath.MOVE_TO) {
                        p.moveTo(this.x[f], o)
                    } else {
                        if (this.type[f] == FR.Chart.GeneralPath.LINE_TO) {
                            p.lineTo(this.x[f], o)
                        } else {
                            if (this.type[f] == FR.Chart.GeneralPath.CLOSE) {
                                p.closePath()
                            } else {
                                if (this.type[f] == FR.Chart.GeneralPath.QUAD_TO) {
                                    p.quadTo(this.ctrl[f].x, FR.Chart.ChartEase.easeOutQuint(m + 1, h.ctrl[f].y, this.ctrl[f].y - h.ctrl[f].y, d), this.x[f], o)
                                } else {
                                    if (this.type[f] == FR.Chart.GeneralPath.CURVE_TO) {
                                        p.curveTo(this.ctrl[f][0].x, FR.Chart.ChartEase.easeOutQuint(m + 1, h.ctrl[f][0].y, this.ctrl[f][0].y - h.ctrl[f][0].y, d), this.ctrl[f][1].x, FR.Chart.ChartEase.easeOutQuint(m + 1, h.ctrl[f][1].y, this.ctrl[f][1].y - h.ctrl[f][1].y, d), this.x[f], o)
                                    }
                                }
                            }
                        }
                    }
                }
                c[m] = p
            }
        } else {
            for (var m = 0; m < d; m++) {
                var p = new FR.Chart.GeneralPath();
                var g = new FR.Chart.GeneralPath();
                if (this.axisReversed) {
                    var b = this.x[0] - this.x[this.x.length - 1];
                    b = FR.Chart.ChartEase.easeOutQuint(m + 1, 0, b, d);
                    for (var f = 0; f < this.x.length; f++) {
                        var k = this.x[f];
                        var j = this.y[f];
                        if (this.x[f] < this.x[0] - b && this.x[f + 1] > this.x[0] - b) {
                            if (this.type[f] != FR.Chart.GeneralPath.MOVE_TO) {
                                var k = this.x[0] - b;
                                var n = (k - this.x[f + 1]) / (this.x[f] - k);
                                var j = (n * this.y[f] + this.y[f + 1]) / (1 + n)
                            }
                        }
                        if (this.x[f] < this.x[0] - b && this.x[f + 1] <= this.x[0] - b) {
                            break
                        }
                        if (this.type[f] == FR.Chart.GeneralPath.MOVE_TO) {
                            FR.Chart.FoldLine.curveTo(p, g);
                            g.clear();
                            p.moveTo(k, j)
                        } else {
                            if (this.type[f] == FR.Chart.GeneralPath.LINE_TO) {
                                FR.Chart.FoldLine.curveTo(p, g);
                                g.clear();
                                p.lineTo(k, j)
                            } else {
                                if (this.type[f] == FR.Chart.GeneralPath.CLOSE) {
                                    FR.Chart.FoldLine.curveTo(p, g);
                                    g.clear();
                                    p.closePath()
                                } else {
                                    if (this.type[f] == FR.Chart.GeneralPath.QUAD_TO) {
                                        if (g.x.length === 0) {
                                            g.moveTo(p.x[p.x.length - 1], p.y[p.y.length - 1])
                                        }
                                        g.lineTo(k, j)
                                    } else {
                                        if (this.type[f] == FR.Chart.GeneralPath.CURVE_TO) {
                                            if (g.x.length === 0) {
                                                g.moveTo(p.x[p.x.length - 1], p.y[p.y.length - 1])
                                            }
                                            g.lineTo(k, j)
                                        }
                                    }
                                }
                            }
                        }
                    }
                } else {
                    var b = this.x[this.x.length - 1] - this.x[0];
                    b = FR.Chart.ChartEase.easeOutQuint(m + 1, 0, b, d);
                    for (var f = 0; f < this.x.length; f++) {
                        var k = this.x[f];
                        var j = this.y[f];
                        if (this.x[f] > this.x[0] + b && this.x[f - 1] < this.x[0] + b) {
                            if (this.type[f] != FR.Chart.GeneralPath.MOVE_TO) {
                                var k = this.x[0] + b;
                                var n = (k - this.x[f - 1]) / (this.x[f] - k);
                                var j = (n * this.y[f] + this.y[f - 1]) / (1 + n)
                            }
                        }
                        if (this.x[f] > this.x[0] + b && this.x[f - 1] >= this.x[0] + b) {
                            break
                        }
                        if (this.type[f] == FR.Chart.GeneralPath.MOVE_TO) {
                            FR.Chart.FoldLine.curveTo(p, g);
                            g.clear();
                            p.moveTo(k, j)
                        } else {
                            if (this.type[f] == FR.Chart.GeneralPath.LINE_TO) {
                                FR.Chart.FoldLine.curveTo(p, g);
                                g.clear();
                                p.lineTo(k, j)
                            } else {
                                if (this.type[f] == FR.Chart.GeneralPath.CLOSE) {
                                    FR.Chart.FoldLine.curveTo(p, g);
                                    g.clear();
                                    p.closePath()
                                } else {
                                    if (this.type[f] == FR.Chart.GeneralPath.QUAD_TO) {
                                        if (g.x.length === 0) {
                                            g.moveTo(p.x[p.x.length - 1], p.y[p.y.length - 1])
                                        }
                                        g.lineTo(k, j)
                                    } else {
                                        if (this.type[f] == FR.Chart.GeneralPath.CURVE_TO) {
                                            if (g.x.length === 0) {
                                                g.moveTo(p.x[p.x.length - 1], p.y[p.y.length - 1])
                                            }
                                            g.lineTo(k, j)
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                FR.Chart.FoldLine.curveTo(p, g);
                c[m] = p
            }
        }
        return c
    }, getAnimateRadarPath: function (c, h) {
        var d = [];
        for (var b = 0; b < c; b++) {
            var f = new FR.Chart.GeneralPath();
            for (var a = 0; a < this.x.length; a++) {
                var g, e;
                if (h != FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
                    g = FR.Chart.ChartEase.easeOutQuint(b + 1, this.centerPoint.x, this.x[a] - this.centerPoint.x, c);
                    e = FR.Chart.ChartEase.easeOutQuint(b + 1, this.centerPoint.y, this.y[a] - this.centerPoint.y, c)
                } else {
                    g = FR.Chart.ChartEase.easeOutQuint(b + 1, this.x[a], this.centerPoint.x - this.x[a], c);
                    e = FR.Chart.ChartEase.easeOutQuint(b + 1, this.y[a], this.centerPoint.y - this.y[a], c)
                }
                if (this.type[a] == FR.Chart.GeneralPath.MOVE_TO) {
                    f.moveTo(g, e)
                } else {
                    if (this.type[a] == FR.Chart.GeneralPath.LINE_TO) {
                        f.lineTo(g, e)
                    } else {
                        if (this.type[a] == FR.Chart.GeneralPath.CLOSE) {
                            f.closePath()
                        }
                    }
                }
            }
            d[b] = f
        }
        return d
    }, getAnimateHighLowLinePath: function (d, h) {
        var e = [];
        for (var c = 0; c < d; c++) {
            var g = new FR.Chart.GeneralPath();
            var b = this.x[0], a, f;
            if (this.y[0] > this.y[1]) {
                a = this.y[1];
                f = this.y[0]
            } else {
                a = this.y[0];
                f = this.y[1]
            }
            if (this.upDown < 0) {
                g.moveTo(b, a);
                g.lineTo(b, FR.Chart.ChartEase.easeOutQuint(c + 1, a, f - a, d));
                g.closePath()
            } else {
                g.moveTo(b, f);
                g.lineTo(b, FR.Chart.ChartEase.easeOutQuint(c + 1, f, a - f, d));
                g.closePath()
            }
            e[c] = g
        }
        return e
    }, moveTo: function (a, b) {
        this.type[this.type.length] = FR.Chart.GeneralPath.MOVE_TO;
        this.x[this.x.length] = a;
        this.y[this.y.length] = b;
        this.ctrl[this.ctrl.length] = null
    }, lineTo: function (a, b) {
        this.type[this.type.length] = FR.Chart.GeneralPath.LINE_TO;
        this.x[this.x.length] = a;
        this.y[this.y.length] = b;
        this.ctrl[this.ctrl.length] = null
    }, quadTo: function (c, b, a, d) {
        this.type[this.type.length] = FR.Chart.GeneralPath.QUAD_TO;
        this.x[this.x.length] = a;
        this.y[this.y.length] = d;
        this.ctrl[this.ctrl.length] = new FR.Chart.Point2D(c, b)
    }, curveTo: function (c, b, e, d, a, g) {
        this.type[this.type.length] = FR.Chart.GeneralPath.CURVE_TO;
        this.x[this.x.length] = a;
        this.y[this.y.length] = g;
        var f = [];
        f[0] = new FR.Chart.Point2D(c, b);
        f[1] = new FR.Chart.Point2D(e, d);
        this.ctrl[this.ctrl.length] = f
    }, closePath: function () {
        for (var a = this.type.length - 1; a >= 0; a--) {
            if (this.type[a] == FR.Chart.GeneralPath.MOVE_TO) {
                this.type[this.type.length] = FR.Chart.GeneralPath.CLOSE;
                this.x[this.x.length] = this.x[a];
                this.y[this.y.length] = this.y[a];
                this.ctrl[this.ctrl.length] = null;
                return
            }
        }
        if (this.type.length > 1) {
            this.type[this.type.length] = FR.Chart.GeneralPath.CLOSE;
            this.x[this.x.length] = this.x[0];
            this.y[this.y.length] = this.y[0];
            this.ctrl[this.ctrl.length] = null
        }
    }, clear: function () {
        this.initConstants()
    }, isNeedRadialGradient: function () {
        return false
    }, getLargeShapeBounds4Map: function () {
        var h = [];
        var g = null;
        for (var c = 0; c < this.x.length; c++) {
            if (this.type[c] == FR.Chart.GeneralPath.MOVE_TO) {
                if (c !== 0 && g !== null) {
                    g.closePath();
                    h[h.length] = g
                }
                g = new FR.Chart.GeneralPath();
                g.moveTo(this.x[c], this.y[c])
            } else {
                if (this.type[c] == FR.Chart.GeneralPath.CLOSE) {
                    g.closePath();
                    h[h.length] = g
                } else {
                    g.lineTo(this.x[c], this.y[c])
                }
            }
        }
        var d = 0;
        var f = 0;
        var b = 0;
        for (var e = 0; e < h.length; e++) {
            var a = h[e].getBounds2D();
            if (a.width * a.height > d * f) {
                b = e;
                d = a.width;
                f = a.height
            }
        }
        if (h.length <= 0) {
            return this.getBounds2D()
        }
        return h[b].getBounds2D()
    }, getBounds2D: function () {
        var b = this.x[0] || 0;
        var e = this.y[0] || 0;
        var d = this.x[0] || 0;
        var a = this.y[0] || 0;
        for (var c = 0; c < this.x.length;
             c++) {
            b = Math.min(this.x[c], b);
            e = Math.min(this.y[c], e);
            d = Math.max(this.x[c], d);
            a = Math.max(this.y[c], a);
            if (this.type[c] == FR.Chart.GeneralPath.QUAD_TO) {
                b = Math.min(this.ctrl[c].x, b);
                e = Math.min(this.ctrl[c].y, e);
                d = Math.max(this.ctrl[c].x, d);
                a = Math.max(this.ctrl[c].y, a)
            } else {
                if (this.type[c] == FR.Chart.GeneralPath.CURVE_TO) {
                    b = Math.min(this.ctrl[c][0].x, b);
                    e = Math.min(this.ctrl[c][0].y, e);
                    d = Math.max(this.ctrl[c][0].x, d);
                    a = Math.max(this.ctrl[c][0].y, a);
                    b = Math.min(this.ctrl[c][1].x, b);
                    e = Math.min(this.ctrl[c][1].y, e);
                    d = Math.max(this.ctrl[c][1].x, d);
                    a = Math.max(this.ctrl[c][1].y, a)
                }
            }
        }
        return new FR.Chart.Bounds(b, e, d - b, a - e)
    }, append: function (b, c) {
        if (b instanceof FR.Chart.GeneralPath) {
            for (var a = 0; a < b.x.length; a++) {
                if (a === 0 && c) {
                    this.type[this.type.length] = FR.Chart.GeneralPath.LINE_TO
                } else {
                    this.type[this.type.length] = b.type[a]
                }
                this.x[this.x.length] = b.x[a];
                this.y[this.y.length] = b.y[a];
                this.ctrl[this.ctrl.length] = b.ctrl[a]
            }
        } else {
            if (b instanceof FR.Chart.Bounds) {
                this.moveTo(b.x, b.y);
                this.lineTo(b.x + b.width, b.y);
                this.lineTo(b.x + b.width, b.y + b.height);
                this.lineTo(b.x, b.y + b.height);
                this.closePath()
            }
        }
    }, getInteractivePath: function () {
        if (this.type[this.type.length - 1] == FR.Chart.GeneralPath.CLOSE) {
            return this
        }
        var b = new FR.Chart.GeneralPath();
        var d = 5;
        for (var a = 0; a < this.type.length; a++) {
            b.x[a] = this.x[a];
            b.y[a] = this.y[a] - d;
            b.type[a] = this.type[a];
            if (b.type[a] == FR.Chart.GeneralPath.QUAD_TO) {
                b.ctrl[a] = new FR.Chart.Point2D(this.ctrl[a].x, this.ctrl[a].y - d)
            } else {
                if (b.type[a] == FR.Chart.GeneralPath.CURVE_TO) {
                    var c = [];
                    c[0] = new FR.Chart.Point2D(this.ctrl[a][0].x, this.ctrl[a][0].y - d);
                    c[1] = new FR.Chart.Point2D(this.ctrl[a][1].x, this.ctrl[a][1].y - d);
                    b.ctrl[a] = c
                } else {
                    b.ctrl[a] = this.ctrl[a]
                }
            }
        }
        b.lineTo(this.x[this.x.length - 1], this.y[this.y.length - 1] + d);
        var a = this.type.length - 2;
        while (a >= 0) {
            switch (this.type[a + 1]) {
                case FR.Chart.GeneralPath.MOVE_TO:
                    b.moveTo(this.x[a], this.y[a] + d);
                    a--;
                    break;
                case FR.Chart.GeneralPath.LINE_TO:
                    b.lineTo(this.x[a], this.y[a] + d);
                    a--;
                    break;
                case FR.Chart.GeneralPath.QUAD_TO:
                    b.quadTo(this.ctrl[a + 1].x, this.ctrl[a + 1].y + d, this.x[a], this.y[a] + d);
                    a--;
                    break;
                case FR.Chart.GeneralPath.CURVE_TO:
                    b.curveTo(this.ctrl[a + 1][1].x, this.ctrl[a + 1][1].y + d, this.ctrl[a + 1][0].x, this.ctrl[a + 1][0].y + 1, this.x[a], this.y[a] + d);
                    a--;
                    break;
                case FR.Chart.GeneralPath.CLOSE:
                    b.type[b.type.length] = this.type[a];
                    b.x[b.x.length] = this.x[a];
                    b.y[b.y.length] = this.y[a] + d;
                    b.ctrl[b.ctrl.length] = this.ctrl[a];
                    a--;
                    break
            }
        }
        b.lineTo(this.x[0], this.y[0] + d);
        return b
    }, contains: function (a, e, b, d) {
        if (isNaN(a + b) || isNaN(e + d)) {
            return false
        }
        if (b <= 0 || d <= 0) {
            return false
        }
        var c = this.rectCrossings(a, e, a + b, e + d);
        return (c != FR.Chart.GeneralPath.RECT_INTERSECTS && (c & -1) !== 0)
    }, containsPoint: function (a, b) {
        return this.getInteractivePath().contains(a, b, 1, 1)
    }, intersects: function (a, e, b, d) {
        if (isNaN(a + b) && isNaN(e + d)) {
            return false
        }
        if (b <= 0 || d <= 0) {
            return false
        }
        var c = this.rectCrossings(a, e, a + b, e + d);
        return (c == FR.Chart.GeneralPath.RECT_INTERSECTS || (c & -1) !== 0)
    }, verticalIntersects: function (c, b) {
        if (isNaN(c + b)) {
            return false
        }
        if (b <= 0) {
            return false
        }
        var a = this.verticalCrossings(c, c + b);
        return (a == FR.Chart.GeneralPath.RECT_INTERSECTS || (a & -1) !== 0)
    }, verticalCrossings: function (g, b) {
        var a, c, f;
        a = c = this.y[0];
        var e = 0;
        for (var d = 1; d < this.y.length && e != FR.Chart.GeneralPath.RECT_INTERSECTS; d++) {
            switch (this.type[d]) {
                case FR.Chart.GeneralPath.MOVE_TO:
                    if (a != c) {
                        e = this.verticalCrossingsForLine(e, g, b, a, c)
                    }
                    c = a = this.y[d];
                    break;
                case FR.Chart.GeneralPath.LINE_TO:
                    f = this.y[d];
                    e = this.verticalCrossingsForLine(e, g, b, a, f);
                    a = f;
                    break;
                case FR.Chart.GeneralPath.CLOSE:
                    if (a != c) {
                        e = this.verticalCrossingsForLine(e, g, b, a, c)
                    }
                    a = c;
                    break
            }
        }
        if (e != FR.Chart.GeneralPath.RECT_INTERSECTS && a != c) {
            e = this.rectCrossingsForLine(e, g, b, a, c)
        }
        return e
    }, rectCrossings: function (a, m, h, b) {
        var l, k, e, c, j, g;
        l = e = this.x[0];
        k = c = this.y[0];
        var f = 0;
        for (var d = 1; d < this.x.length && f != FR.Chart.GeneralPath.RECT_INTERSECTS; d++) {
            switch (this.type[d]) {
                case FR.Chart.GeneralPath.MOVE_TO:
                    if (l != e || k != c) {
                        f = this.rectCrossingsForLine(f, a, m, h, b, l, k, e, c)
                    }
                    e = l = this.x[d];
                    c = k = this.y[d];
                    break;
                case FR.Chart.GeneralPath.LINE_TO:
                    j = this.x[d];
                    g = this.y[d];
                    f = this.rectCrossingsForLine(f, a, m, h, b, l, k, j, g);
                    l = j;
                    k = g;
                    break;
                case FR.Chart.GeneralPath.QUAD_TO:
                    f = this.rectCrossingsForQuad(f, a, m, h, b, l, k, this.ctrl[d].x, this.ctrl[d].y, j = this.x[d], g = this.y[d], 0);
                    l = j;
                    k = g;
                    break;
                case FR.Chart.GeneralPath.CURVE_TO:
                    f = this.rectCrossingsForCubic(f, a, m, h, b, l, k, this.ctrl[d][0].x, this.ctrl[d][0].y, this.ctrl[d][1].x, this.ctrl[d][1].y, j = this.x[d], g = this.y[d], 0);
                    l = j;
                    k = g;
                    break;
                case FR.Chart.GeneralPath.CLOSE:
                    if (l != e || k != c) {
                        f = this.rectCrossingsForLine(f, a, m, h, b, l, k, e, c)
                    }
                    l = e;
                    k = c;
                    break
            }
        }
        if (f != FR.Chart.GeneralPath.RECT_INTERSECTS && (l != e || k != c)) {
            f = this.rectCrossingsForLine(f, a, m, h, b, l, k, e, c)
        }
        return f
    }, verticalCrossingsForLine: function (c, e, a, d, b) {
        if ((d >= e && d <= a) || (b >= e && b <= a)) {
            return FR.Chart.GeneralPath.RECT_INTERSECTS
        } else {
            return c
        }
    }, rectCrossingsForLine: function (g, b, k, h, d, c, j, a, i) {
        if (j >= d && i >= d) {
            return g
        }
        if (j <= k && i <= k) {
            return g
        }
        if (c <= b && a <= b) {
            return g
        }
        if (c >= h && a >= h) {
            if (j < i) {
                if (j <= k) {
                    g++
                }
                if (i >= d) {
                    g++
                }
            } else {
                if (i < j) {
                    if (i <= k) {
                        g--
                    }
                    if (j >= d) {
                        g--
                    }
                }
            }
            return g
        }
        if ((c > b && c < h && j > k && j < d) || (a > b && a < h && i > k && i < d)) {
            return FR.Chart.GeneralPath.RECT_INTERSECTS
        }
        var f = c;
        if (j < k) {
            f += ((k - j) * (a - c) / (i - j))
        } else {
            if (j > d) {
                f += ((d - j) * (a - c) / (i - j))
            }
        }
        var e = a;
        if (i < k) {
            e += ((k - i) * (c - a) / (j - i))
        } else {
            if (i > d) {
                e += ((d - i) * (c - a) / (j - i))
            }
        }
        if (f <= b && e <= b) {
            return g
        }
        if (f >= h && e >= h) {
            if (j < i) {
                if (j <= k) {
                    g++
                }
                if (i >= d) {
                    g++
                }
            } else {
                if (i < j) {
                    if (i <= k) {
                        g--
                    }
                    if (j >= d) {
                        g--
                    }
                }
            }
            return g
        }
        return FR.Chart.GeneralPath.RECT_INTERSECTS
    }, rectCrossingsForCubic: function (h, q, c, t, e, p, g, d, j, a, i, n, f, b) {
        if (g >= e && j >= e && i >= e && f >= e) {
            return h
        }
        if (g <= c && j <= c && i <= c && f <= c) {
            return h
        }
        if (p <= q && d <= q && a <= q && n <= q) {
            return h
        }
        if (p >= t && d >= t && a >= t && n >= t) {
            if (g < f) {
                if (g <= c && f > c) {
                    h++
                }
                if (g < e && f >= e) {
                    h++
                }
            } else {
                if (f < g) {
                    if (f <= c && g > c) {
                        h--
                    }
                    if (f < e && g >= e) {
                        h--
                    }
                }
            }
            return h
        }
        if ((p > q && p < t && g > c && g < e) || (n > q && n < t && f > c && f < e)) {
            return FR.Chart.GeneralPath.RECT_INTERSECTS
        }
        if (b > 52) {
            return this.rectCrossingsForLine(h, q, c, t, e, p, g, n, f)
        }
        var l = (d + a) / 2;
        var r = (j + i) / 2;
        d = (p + d) / 2;
        j = (g + j) / 2;
        a = (a + n) / 2;
        i = (i + f) / 2;
        var k = (d + l) / 2;
        var m = (j + r) / 2;
        var o = (l + a) / 2;
        var s = (r + i) / 2;
        l = (k + o) / 2;
        r = (m + s) / 2;
        if (isNaN(l) || isNaN(r)) {
            return 0
        }
        h = this.rectCrossingsForCubic(h, q, c, t, e, p, g, d, j, k, m, l, r, b + 1);
        if (h != FR.Chart.GeneralPath.RECT_INTERSECTS) {
            h = this.rectCrossingsForCubic(h, q, c, t, e, l, r, o, s, a, i, n, f, b + 1)
        }
        return h
    }, rectCrossingsForQuad: function (i, d, o, j, f, e, n, p, k, c, m, b) {
        if (n >= f && k >= f && m >= f) {
            return i
        }
        if (n <= o && k <= o && m <= o) {
            return i
        }
        if (e <= d && p <= d && c <= d) {
            return i
        }
        if (e >= j && p >= j && c >= j) {
            if (n < m) {
                if (n <= o && m > o) {
                    i++
                }
                if (n < f && m >= f) {
                    i++
                }
            } else {
                if (m < n) {
                    if (m <= o && n > o) {
                        i--
                    }
                    if (m < f && n >= f) {
                        i--
                    }
                }
            }
            return i
        }
        if ((e < j && e > d && n < f && n > o) || (c < j && c > d && m < f && m > o)) {
            return FR.Chart.GeneralPath.RECT_INTERSECTS
        }
        if (b > 52) {
            return this.rectCrossingsForLine(i, d, o, j, f, e, n, c, m)
        }
        var a = (e + p) / 2;
        var g = (n + k) / 2;
        var h = (p + c) / 2;
        var l = (k + m) / 2;
        p = (a + h) / 2;
        k = (g + l) / 2;
        if (isNaN(p) || isNaN(k)) {
            return 0
        }
        i = this.rectCrossingsForQuad(i, d, o, j, f, e, n, a, g, p, k, b + 1);
        if (i != FR.Chart.GeneralPath.RECT_INTERSECTS) {
            i = this.rectCrossingsForQuad(i, d, o, j, f, p, k, h, l, c, m, b + 1)
        }
        return i
    }, getVerticalMiddlePointY: function () {
        var a = this.getBounds2D();
        var n = a.x + a.width / 2;
        var f = 0;
        var h = [];
        var l = a.y + a.height / 2;
        for (var d = 0; d < this.x.length; d++) {
            var c = (d + 1) % this.x.length;
            if (this.x[d] <= n && this.x[c] >= n || this.x[d] >= n && this.x[c] <= n) {
                if (this.x[d] === this.x[c]) {
                    h[f++] = (this.y[d] + this.y[c]) / 2
                } else {
                    h[f++] = (this.y[c] - this.y[d]) * (n - this.x[d]) / (this.x[c] - this.x[d]) + this.y[d]
                }
            }
        }
        if (f <= 0) {
            return l
        }
        h.sort();
        var e = f / 2;
        if (e > 0) {
            var g = 0;
            for (d = 0; d < e; d++) {
                c = d * 2;
                var b = d * 2 + 1;
                var m = Math.abs(h[c] - h[b]);
                if (m > g) {
                    g = m;
                    l = (h[c] + h[b]) / 2
                }
            }
        }
        if (this.containsPoint(n, l)) {
            return l
        }
        return a.y + a.height / 2
    }
});
$.extend(FR.Chart.GeneralPath, {
    MOVE_TO: 0,
    LINE_TO: 1,
    QUAD_TO: 2,
    CURVE_TO: 3,
    CLOSE: 4,
    RECT_INTERSECTS: 2147483648
});
FR.Chart.FoldLine = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        this.lineStyleInfo = new FR.Chart.LineStyleInfo();
        this.generalPath = a || null
    }, draw: function (a, b) {
        if (this.lineStyleInfo) {
            this.lineStyleInfo.paint(a, this.generalPath, b)
        }
    }, getShadeColor: function () {
        var b = FR.Chart.Color.getColorArray(this.lineStyleInfo.attrLineColor.seriesColor);
        var a = FR.Chart.Color.RGB2HSB(b[0], b[1], b[2]);
        return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], a[1] * 2, a[2] / 2))
    }, setAlpha: function (a) {
        this.lineStyleInfo.seriesAttrAlpha.alpha = a
    }, getAlpha: function () {
        return this.lineStyleInfo.seriesAttrAlpha.alpha
    }, draw4Demo: function (a) {
        if (this.generalPath) {
            this.generalPath.draw(a)
        }
    }, getShape: function () {
        return this.generalPath
    }, getAnimateGlyph: function (b, g, f, c) {
        var j = [];
        if (this.generalPath) {
            var e = null;
            if (f && g == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
                e = f.generalPath
            }
            var a = this.generalPath.getAnimatePath(b, g, e, c);
            for (var d = 0; d < a.length; d++) {
                if (g == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                    j[d] = this
                } else {
                    var h = new FR.Chart.FoldLine(a[d]);
                    j[d] = h;
                    h.lineStyleInfo = this.lineStyleInfo
                }
            }
        }
        return j
    }
});
$.extend(FR.Chart.FoldLine, {
    curveTo: function (k, j) {
        if (j.x.length <= 2) {
            k.append(j, true)
        } else {
            var a = 0.6;
            var h = [];
            var g = [];
            for (var c = 0; c < j.x.length - 1; c++) {
                h[c] = (j.x[c] + j.x[c + 1]) / 2;
                g[c] = (j.y[c] + j.y[c + 1]) / 2
            }
            var f = [];
            var e = [];
            for (var c = 1; c < h.length; c++) {
                var d = j.x[c] - (h[c - 1] + h[c]) / 2;
                var b = j.y[c] - (g[c - 1] + g[c]) / 2;
                f[(c - 1) * 2] = j.x[c] + (h[c - 1] + d - j.x[c]) * a;
                e[(c - 1) * 2] = j.y[c] + (g[c - 1] + b - j.y[c]) * a;
                f[(c - 1) * 2 + 1] = j.x[c] + (h[c] + d - j.x[c]) * a;
                e[(c - 1) * 2 + 1] = j.y[c] + (g[c] + b - j.y[c]) * a
            }
            var l = new FR.Chart.GeneralPath();
            l.moveTo(j.x[0], j.y[0]);
            for (var c = 1; c < j.x.length; c++) {
                if (c === 1) {
                    l.quadTo(f[0], e[0], j.x[c], j.y[c])
                } else {
                    if (c == j.x.length - 1) {
                        l.quadTo(f[f.length - 1], e[e.length - 1], j.x[c], j.y[c])
                    } else {
                        l.curveTo(f[(c - 1) * 2 - 1], e[(c - 1) * 2 - 1], f[(c - 1) * 2], e[(c - 1) * 2], j.x[c], j.y[c])
                    }
                }
            }
            k.append(l, true)
        }
    }
});
FR.Chart.TrendLine = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.equation = FR.pick(a.equation, FR.Chart.Constants.TRENDLINE_POLYNOMIAL);
        this.square = FR.pick(a.square, 6);
        this.moveAverage = FR.pick(a.moveAverage, 5);
        this.lineStyleInfo = a.lineStyleInfo == undefined ? null : new FR.Chart.LineStyleInfo(a.lineStyleInfo);
        this.trendLineName = FR.pick(a.trendLineName, FR.i18nText("Chart-Trend_Line"))
    }, createTrendLineGlyph: function () {
        var a = new FR.Chart.TrendLineGlyph();
        a.equation = this.equation;
        a.square = this.square;
        a.moveAverage = this.moveAverage;
        a.trendLineName = this.trendLineName;
        a.lineStyleInfo.attrLineColor.seriesColor = this.lineStyleInfo.attrLineColor.seriesColor;
        a.lineStyleInfo.attrLineStyle.lineStyle = this.lineStyleInfo.attrLineStyle.lineStyle;
        a.lineStyleInfo.seriesAttrAlpha.alpha = this.lineStyleInfo.seriesAttrAlpha.alpha;
        a.lineStyleInfo.seriesAttrBorder.borderStyle = this.lineStyleInfo.seriesAttrBorder.borderStyle;
        a.lineStyleInfo.seriesAttrBorder.borderBackground = this.lineStyleInfo.seriesAttrBorder.borderBackground;
        return a
    }
});
FR.Chart.Cubic = function (b, d, c, a) {
    this.x = b;
    this.y = d;
    this.width = c;
    this.height = a
};
$.extend(FR.Chart.Cubic.prototype, {
    x: 0,
    y: 0,
    z: 0,
    width: 0,
    height: 0,
    deep: 0,
    projection: null,
    points: null,
    covers: [0, 3, 4],
    horizontalDrawBar: false,
    setCubicWidthHeight: function (b, a) {
        this.width = b;
        this.height = a;
        if (this.points) {
            this.points = null;
            this.init()
        }
    },
    setCubicPosition: function (a, b) {
        this.x = a;
        this.y = b;
        if (this.points) {
            this.points = null;
            this.init()
        }
    },
    getGapWidth: function () {
        var a = this.getPoints();
        return Math.abs(a[4].x - a[0].x)
    },
    getGapHeight: function () {
        var a = this.getPoints();
        return Math.abs(a[0].y - a[4].y)
    },
    getPoints: function () {
        this.init();
        return this.points
    },
    init: function () {
        if (this.projection && !this.points) {
            this.points = [];
            var b = this.x;
            var f = this.y;
            var e = this.z;
            var d = this.width;
            var a = this.height;
            var c = this.deep;
            this.points[0] = this.projection.projectee(b, f, e);
            this.points[1] = this.projection.projectee(b + d, f, e);
            this.points[2] = this.projection.projectee(b, f + a, e);
            this.points[3] = this.projection.projectee(b + d, f + a, e);
            this.points[4] = this.projection.projectee(b, f, e - c);
            this.points[5] = this.projection.projectee(b + d, f, e - c);
            this.points[6] = this.projection.projectee(b, f + a, e - c);
            this.points[7] = this.projection.projectee(b + d, f + a, e - c)
        }
    },
    top: function () {
        if (this.points) {
            var a = new FR.Chart.GeneralPath();
            var b = this.points;
            a.moveTo(b[0].x, b[0].y);
            a.lineTo(b[1].x, b[1].y);
            a.lineTo(b[5].x, b[5].y);
            a.lineTo(b[4].x, b[4].y);
            a.closePath();
            return a
        }
    },
    bottom: function () {
        if (this.points) {
            var a = new FR.Chart.GeneralPath();
            var b = this.points;
            a.moveTo(b[2].x, b[2].y);
            a.lineTo(b[3].x, b[3].y);
            a.lineTo(b[7].x, b[7].y);
            a.lineTo(b[6].x, b[6].y);
            a.closePath();
            return a
        }
    },
    right: function () {
        if (this.points) {
            var a = new FR.Chart.GeneralPath();
            var b = this.points;
            a.moveTo(b[1].x, b[1].y);
            a.lineTo(b[3].x, b[3].y);
            a.lineTo(b[7].x, b[7].y);
            a.lineTo(b[5].x, b[5].y);
            a.closePath();
            return a
        }
    },
    left: function () {
        if (this.points) {
            var b = new FR.Chart.GeneralPath();
            var a = this.points;
            b.moveTo(a[0].x, a[0].y);
            b.lineTo(a[2].x, a[2].y);
            b.lineTo(a[6].x, a[6].y);
            b.lineTo(a[4].x, a[4].y);
            b.closePath();
            return b
        }
    },
    front: function () {
        if (this.points) {
            var a = new FR.Chart.GeneralPath();
            var b = this.points;
            a.moveTo(b[0].x, b[0].y);
            a.lineTo(b[1].x, b[1].y);
            a.lineTo(b[3].x, b[3].y);
            a.lineTo(b[2].x, b[2].y);
            a.closePath();
            return a
        }
    },
    back: function () {
        if (this.points) {
            var a = new FR.Chart.GeneralPath();
            var b = this.points;
            a.moveTo(b[4].x, b[4].y);
            a.lineTo(b[5].x, b[5].y);
            a.lineTo(b[7].x, b[7].y);
            a.lineTo(b[6].x, b[6].y);
            a.closePath();
            return a
        }
    },
    getShape: function () {
        this.init();
        if (this.points && this.covers) {
            var a = new FR.Chart.GeneralPath();
            for (var b = 0; b < this.covers.length; b++) {
                switch (this.covers[b]) {
                    case FR.Chart.Cubic.TOP:
                        a.append(this.top(), false);
                        break;
                    case FR.Chart.Cubic.BOTTOM:
                        a.append(this.bottom(), false);
                        break;
                    case FR.Chart.Cubic.LEFT:
                        a.append(this.left(), false);
                        break;
                    case FR.Chart.Cubic.RIGHT:
                        a.append(this.right(), false);
                        break;
                    case FR.Chart.Cubic.FRONT:
                        a.append(this.front(), false);
                        break;
                    case FR.Chart.Cubic.BACK:
                        a.append(this.back(), false);
                        break;
                    default:
                }
            }
            return a
        }
    },
    paint: function (l) {
        if (!l) {
            return
        }
        l.save();
        this.init();
        var s = FR.Chart.Color.Hex2RGB(l.fillStyle);
        if (s) {
            if (!l) {
                return
            }
            l.save();
            l.shadowBlur = 6;
            l.shadowOffsetX = 2;
            l.shadowColor = "rgba(0,0,0, 0.3)";
            this.back().paint(l);
            l.restore();
            var h = FR.Chart.Color.RGB2HSB(s[0], s[1], s[2]);
            var i = l.fillStyle;
            var p = FR.Chart.Color.HSB2RGB(h[0], h[1] - 0.3, h[2] + 0.35);
            var j = FR.Chart.Color.getColor(p);
            var q = FR.Chart.Color.HSB2RGB(h[0], h[1] - 0.1, h[2] + 0.1);
            var c = FR.Chart.Color.getColor(q);
            var k;
            if (this.horizontalDrawBar) {
                k = l.createLinearGradient(this.points[2].x, this.points[2].y, this.points[3].x, this.points[3].y)
            } else {
                k = l.createLinearGradient(this.points[2].x, this.points[2].y, this.points[0].x, this.points[0].y)
            }
            k.addColorStop(0, i);
            k.addColorStop(0.2, c);
            k.addColorStop(1, j);
            l.fillStyle = k;
            this.front().paint(l);
            var b = FR.Chart.Color.HSB2RGB(h[0], h[1] + 0.1, h[2] - 0.1);
            var g = FR.Chart.Color.getColor(b);
            var r = FR.Chart.Color.HSB2RGB(h[0], h[1] - 0.05, h[2] + 0.2);
            var f = FR.Chart.Color.getColor(r);
            var o = FR.Chart.Color.HSB2RGB(h[0], h[1] + 0.05, h[2] + 0.1);
            var a = FR.Chart.Color.getColor(o);
            k = l.createLinearGradient(this.points[3].x, this.points[3].y, this.points[5].x, this.points[5].y);
            k.addColorStop(0, g);
            k.addColorStop(0.7, f);
            k.addColorStop(1, a);
            l.fillStyle = k;
            this.right().paint(l);
            var d = FR.Chart.Color.HSB2RGB(h[0], h[1] - 0.05, h[2] + 0.05);
            var m = FR.Chart.Color.getColor(d);
            var e = FR.Chart.Color.HSB2RGB(h[0], h[1] - 0.2, h[2] + 0.3);
            var n = FR.Chart.Color.getColor(e);
            k = l.createLinearGradient(this.points[0].x, this.points[0].y, this.points[0].x, this.points[5].y);
            k.addColorStop(0, m);
            k.addColorStop(1, n);
            l.fillStyle = k;
            this.top().paint(l)
        }
        l.restore()
    },
    draw: function (a) {
    },
    getAnimateShape: function (a, h, g, b) {
        var d = [];
        if (b <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return d
        }
        for (var f = 0;
             f < a; f++) {
            var c;
            if (this.horizontalDrawBar) {
                var e = FR.Chart.ChartEase.easeOutQuint(f + 1, 0, this.width, a);
                c = new FR.Chart.Cubic(this.x, this.y, e, this.height)
            } else {
                var j = FR.Chart.ChartEase.easeOutQuint(f + 1, 0, this.height, a);
                c = new FR.Chart.Cubic(this.x, this.y + this.height - j, this.width, j)
            }
            c.projection = this.projection;
            c.z = this.z;
            c.deep = this.deep;
            c.horizontalDrawBar = this.horizontalDrawBar;
            d[f] = c
        }
        return d
    },
    containsPoint: function (a, b) {
        if (!this.shape) {
            this.shape = this.getShape()
        }
        return this.shape.containsPoint(a, b)
    },
    draw3DBase: function (b, c) {
        if (!b) {
            return
        }
        b.save();
        b.globalAlpha = 0.18;
        this.init();
        if (c == FR.Chart.Cubic.BOTTOM) {
            var a = b.createLinearGradient(this.points[2].x, this.points[2].y, this.points[2].x, this.points[6].y);
            a.addColorStop(0, "rgb(145,151,156)");
            a.addColorStop(1, "rgb(198, 205, 210)");
            b.fillStyle = a;
            this.bottom().paint(b)
        } else {
            if (c == FR.Chart.Cubic.LEFT) {
                var a = b.createLinearGradient(this.points[0].x, this.points[4].y, this.points[4].x, this.points[4].y);
                a.addColorStop(0, "rgb(145,151,156)");
                a.addColorStop(1, "rgb(198, 205, 210)");
                b.fillStyle = a;
                this.left().paint(b)
            }
        }
        b.restore()
    },
    isNeedRadialGradient: function () {
        return false
    },
    getBounds2D: function () {
        this.init();
        return this.front().getBounds2D()
    }
});
$.extend(FR.Chart.Cubic, {TOP: 0, BOTTOM: 1, LEFT: 2, RIGHT: 3, FRONT: 4, BACK: 5});
FR.Chart.Area3D = function (b, a) {
    this.z = b;
    this.deep = a;
    this.point_list = [];
    this.type_list = [];
    this.positivePaths = [];
    this.backPaths = [];
    this.flatPathArray = [];
    this.topSize = 0;
    this.preSize = 0;
    this.isFirst = false;
    this.positiveStartPoint = [];
    this.positiveEndPoint = [];
    this.backStartPoint = [];
    this.backEndPoint = []
};
$.extend(FR.Chart.Area3D.prototype, {
    z: 0,
    deep: 0,
    projection: null,
    point_list: [],
    type_list: [],
    positivePaths: [],
    backPaths: [],
    flatPathArray: [],
    topSize: 0,
    preSize: 0,
    isFirst: false,
    positiveStartPoint: [],
    positiveEndPoint: [],
    backStartPoint: [],
    backEndPoint: [],
    moveTo: function (a, b) {
        this.type_list.push(FR.Chart.Area3D.MOVE_TO);
        this.point_list.push(new FR.Chart.Point2D(a, b))
    },
    lineTo: function (a, b) {
        this.type_list.push(FR.Chart.Area3D.LINE_TO);
        this.point_list.push(new FR.Chart.Point2D(a, b))
    },
    closePath: function () {
        var a = this.type_list.length - 1;
        while (a >= 0 && this.type_list[a] == FR.Chart.Area3D.LINE_TO) {
            a--
        }
        if (a >= 0) {
            this.type_list.push(FR.Chart.Area3D.LINE_TO);
            this.point_list.push(this.point_list[a])
        }
    },
    getFrontArea: function () {
        var b = new FR.Chart.GeneralPath();
        for (var a = 0; a < this.point_list.length; a++) {
            var c = this.projection.projectee(this.point_list[a].x, this.point_list[a].y, this.z);
            if (a === 0) {
                b.moveTo(c.x, c.y)
            } else {
                b.lineTo(c.x, c.y)
            }
        }
        b.closePath();
        return b
    },
    getBottomPoint: function () {
        var a = this.point_list[0];
        var c = a.y;
        for (var b = 0; b < this.point_list.length;
             b++) {
            if (c < this.point_list[b].y) {
                a = this.point_list[b];
                c = a.y
            }
        }
        return a
    },
    getTopPoint: function () {
        var a = this.point_list[0];
        var c = a.y;
        for (var b = 0; b < this.point_list.length; b++) {
            if (c > this.point_list[b].y) {
                a = this.point_list[b];
                c = a.y
            }
        }
        return a
    },
    getLineShape: function (c) {
        var a = new FR.Chart.GeneralPath();
        if (c && c.length !== 0) {
            for (var b = 0; b < c.length; b++) {
                a.append(c[b], false)
            }
        }
        return a
    },
    getShape: function () {
        var a = this.getLineShape(this.getTopPaths());
        a.append(this.getFrontArea(), false);
        return a
    },
    getInteractivePath: function () {
        return this.getShape()
    },
    getTopPaths: function () {
        var n = [];
        var h = [];
        var k = -1;
        for (var j = 0; j < this.topSize - 1; j++) {
            if (this.type_list[j + 1] == FR.Chart.Area3D.MOVE_TO) {
                continue
            }
            var f = this.point_list[j].x;
            var m = this.point_list[j].y;
            var c = this.point_list[j + 1].x;
            var l = this.point_list[j + 1].y;
            var g = this.projection.projectee(f, m, this.z);
            var e = this.projection.projectee(c, l, this.z);
            var b = this.projection.projectee(c, l, this.z - this.deep);
            var a = this.projection.projectee(f, m, this.z - this.deep);
            var d = new FR.Chart.GeneralPath();
            d.moveTo(g.x, g.y);
            d.lineTo(e.x, e.y);
            d.lineTo(b.x, b.y);
            d.lineTo(a.x, a.y);
            d.closePath();
            n.push(d);
            if (m > l) {
                this.positivePaths.push(d);
                this.positiveStartPoint.push(this.point_list[j]);
                this.positiveEndPoint.push(this.point_list[j + 1])
            } else {
                if (m < l) {
                    this.backPaths.push(d);
                    this.backStartPoint.push(this.point_list[j]);
                    this.backEndPoint.push(this.point_list[j + 1])
                } else {
                    if (k == j - 1) {
                        h.push(d);
                        if (j == this.topSize - 2) {
                            this.flatPathArray.push(h);
                            h = []
                        }
                    } else {
                        if (k === -1) {
                            h.push(d);
                            k = j;
                            continue
                        }
                        this.flatPathArray.push(h);
                        h = []
                    }
                    k = j
                }
            }
        }
        return n
    },
    getAllPaths: function () {
        var l = [];
        for (var h = 0; h < this.point_list.length - 1; h++) {
            if (this.type_list[h + 1] == FR.Chart.Area3D.MOVE_TO) {
                continue
            }
            var f = this.point_list[h].x;
            var k = this.point_list[h].y;
            var c = this.point_list[h + 1].x;
            var j = this.point_list[h + 1].y;
            var g = this.projection.projectee(f, k, this.z);
            var e = this.projection.projectee(c, j, this.z);
            var b = this.projection.projectee(c, j, this.z - this.deep);
            var a = this.projection.projectee(f, k, this.z - this.deep);
            var d = new FR.Chart.GeneralPath();
            d.moveTo(g.x, g.y);
            d.lineTo(e.x, e.y);
            d.lineTo(b.x, b.y);
            d.lineTo(a.x, a.y);
            d.closePath();
            l.push(d)
        }
        return l
    },
    paint: function (a) {
        var b = this.getTopPaths();
        this.paintLeftRight(a);
        this.paintFlat(a);
        this.paintPositive(a);
        this.paintBack(a);
        if (this.isFirst) {
            this.paintBottom(a)
        }
        this.paintFront(a)
    },
    paintFlat: function (a) {
        for (var b = 0; b < this.flatPathArray.length; b++) {
            var c = this.flatPathArray[b];
            this.getLineShape(c).paint(a)
        }
    },
    paintPositive: function (k) {
        var j = FR.Chart.Color.Hex2RGB(k.fillStyle);
        var d = FR.Chart.Color.RGB2HSB(j[0], j[1], j[2]);
        var b = FR.Chart.Color.HSB2RGB(d[0], d[1], d[2]);
        var h = FR.Chart.Color.getColor(b);
        var e = FR.Chart.Color.HSB2RGB(d[0], d[1] - 0.2, d[2] + 0.35);
        var c = FR.Chart.Color.getColor(e);
        for (var g = 0; g < this.positivePaths.length; g++) {
            var l = this.positivePaths[g];
            var a = l.getBounds2D();
            if (!k) {
                return
            }
            k.save();
            var f = k.createLinearGradient(this.positiveStartPoint[g].x, this.positiveStartPoint[g].y, this.positiveEndPoint[g].x, this.positiveEndPoint[g].y);
            f.addColorStop(0, h);
            f.addColorStop(1, c);
            k.fillStyle = f;
            l.paint(k);
            k.restore()
        }
    },
    paintBottom: function (a) {
        var b = this.getBottomShape();
        b.paint(a)
    },
    getBottomShape: function () {
        var f = this.point_list[this.point_list.length - 2].x;
        var i = this.point_list[this.point_list.length - 2].y;
        var c = this.point_list[this.topSize].x;
        var h = this.point_list[this.topSize].y;
        var g = this.projection.projectee(f, i, this.z);
        var e = this.projection.projectee(c, h, this.z);
        var b = this.projection.projectee(c, h, this.z - this.deep);
        var a = this.projection.projectee(f, i, this.z - this.deep);
        var d = new FR.Chart.GeneralPath();
        d.moveTo(g.x, g.y);
        d.lineTo(e.x, e.y);
        d.lineTo(b.x, b.y);
        d.lineTo(a.x, a.y);
        d.closePath();
        return d
    },
    paintFront: function (j) {
        var d = this.getFrontArea();
        var i = this.getTopPoint();
        var a = this.getBottomPoint();
        var h = FR.Chart.Color.Hex2RGB(j.fillStyle);
        var e = FR.Chart.Color.RGB2HSB(h[0], h[1], h[2]);
        var g = j.fillStyle;
        var c = FR.Chart.Color.HSB2RGB(e[0], e[1] - 0.2, e[2] + 0.25);
        var b = FR.Chart.Color.getColor(c);
        var f = j.createLinearGradient(a.x, a.y, a.x, i.y);
        f.addColorStop(0, g);
        f.addColorStop(1, b);
        j.fillStyle = f;
        d.paint(j)
    },
    paintBack: function (j) {
        var h = FR.Chart.Color.Hex2RGB(j.fillStyle);
        var c = FR.Chart.Color.RGB2HSB(h[0], h[1], h[2]);
        var a = FR.Chart.Color.HSB2RGB(c[0], c[1] - 0.05, c[2] + 0.1);
        var g = FR.Chart.Color.getColor(a);
        var d = FR.Chart.Color.HSB2RGB(c[0], c[1] - 0.2, c[2] + 0.25);
        var b = FR.Chart.Color.getColor(d);
        for (var f = 0; f < this.backPaths.length; f++) {
            var k = this.backPaths[f];
            if (!j) {
                return
            }
            j.save();
            var e = j.createLinearGradient(this.backStartPoint[f].x, this.backStartPoint[f].y, this.backEndPoint[f].x, this.backEndPoint[f].y);
            e.addColorStop(0, g);
            e.addColorStop(1, b);
            j.fillStyle = e;
            k.paint(j);
            j.restore()
        }
    },
    paintLeftRight: function (c) {
        if (!c) {
            return
        }
        c.save();
        var b = this.getAllPaths();
        var g = b[b.length - 1];
        var e = b[this.topSize - 1];
        var d = FR.Chart.Color.Hex2RGB(c.fillStyle);
        var a = FR.Chart.Color.RGB2HSB(d[0], d[1], d[2]);
        var h = FR.Chart.Color.HSB2RGB(a[0], a[1] + 0.1, a[2] - 0.1);
        var f = FR.Chart.Color.getColor(h);
        c.fillStyle = f;
        g.paint(c);
        e.paint(c);
        c.restore()
    },
    draw: function (a) {
    },
    getAnimateShape: function (b, j, f, c) {
        if (c <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        var a = [];
        for (var e = 0; e < b; e++) {
            var m = new FR.Chart.Area3D(this.z, this.deep);
            m.projection = this.projection;
            m.type_list = this.type_list;
            m.topSize = this.topSize;
            m.preSize = this.preSize;
            m.isFirst = this.isFirst;
            m.point_list = [];
            for (var h = 0; h < this.topSize; h++) {
                var l = this.getAreaHeight(h);
                var k = FR.Chart.ChartEase.easeOutQuint(e + 1, 0, l, b);
                var d = this.point_list[2 * this.topSize - 1 - h];
                var g = d.y - k;
                if (h !== 0) {
                    if (this.point_list[h].y == this.point_list[h - 1].y) {
                        g = m.point_list[h - 1].y
                    }
                }
                m.point_list.push(new FR.Chart.Point2D(d.x, g))
            }
            for (var h = this.topSize; h < this.point_list.length; h++) {
                m.point_list.push(this.point_list[h])
            }
            a[e] = m
        }
        return a
    },
    getAreaHeight: function (a) {
        return this.point_list[2 * this.topSize - 1 - a].y - this.point_list[a].y
    },
    containsPoint: function () {
        return false
    }
});
$.extend(FR.Chart.Area3D, {MOVE_TO: "move_to", LINE_TO: "line_to"});
FR.Chart.Pie3D = function (b, c, a) {
    this.start_y = b;
    this.depth = c;
    this.radius = a;
    this.info = new FR.Chart.GeneralInfo();
    this.startEnable = true;
    this.endEnable = true;
    this.paintCount = 0
};
$.extend(FR.Chart.Pie3D.prototype, {
    x: 0,
    y: 0,
    start_y: 0,
    depth: 0,
    radius: 0,
    start: 0,
    extent: 360,
    projection: null,
    info: null,
    startEnable: true,
    endEnable: true,
    paintCount: 0,
    setAttribute: function (b, e, d, c, a) {
        this.x = b;
        this.y = e;
        this.start = d;
        this.extent = c;
        this.projection = a
    },
    paint: function (a) {
        this.paintBack(a);
        this.paintTop(a)
    },
    paintSides: function (a) {
        if (!a) {
            return
        }
        a.save();
        var e = this.sides();
        var c = FR.Chart.Color.Hex2RGB(a.fillStyle);
        var f = FR.Chart.Color.RGB2HSB(c[0], c[1], c[2]);
        var b = FR.Chart.Color.HSB2RGB(f[0], f[1] + 0.1, f[2] - 0.15);
        var d = FR.Chart.Color.getColor(b);
        a.fillStyle = d;
        e[0].paint(a);
        e[1].paint(a);
        a.restore()
    },
    paintStartSide: function (a) {
        if (!a) {
            return
        }
        a.save();
        var d = this.getStartSide();
        var c = FR.Chart.Color.Hex2RGB(a.fillStyle);
        var f = FR.Chart.Color.RGB2HSB(c[0], c[1], c[2]);
        var b = FR.Chart.Color.HSB2RGB(f[0], f[1] + 0.1, f[2] - 0.15);
        var e = FR.Chart.Color.getColor(b);
        a.fillStyle = e;
        d.paint(a);
        a.restore()
    },
    paintEndSide: function (a) {
        if (!a) {
            return
        }
        a.save();
        var d = this.getEndSide();
        var c = FR.Chart.Color.Hex2RGB(a.fillStyle);
        var f = FR.Chart.Color.RGB2HSB(c[0], c[1], c[2]);
        var b = FR.Chart.Color.HSB2RGB(f[0], f[1] + 0.1, f[2] - 0.15);
        var e = FR.Chart.Color.getColor(b);
        a.fillStyle = e;
        d.paint(a);
        a.restore()
    },
    paintTop: function (m) {
        if (!m) {
            return
        }
        m.save();
        var h = this.top();
        var a = h.width / 2;
        var j = h.width / 2 / a;
        var i = h.height / 2 / a;
        m.scale(j, i);
        var k = FR.Chart.Color.Hex2RGB(m.fillStyle);
        var d = FR.Chart.Color.RGB2HSB(k[0], k[1], k[2]);
        var l = FR.Chart.Color.HSB2RGB(d[0], d[1] - 0.2, d[2] + 0.25);
        var g = FR.Chart.Color.getColor(l);
        var e = m.fillStyle;
        var f = m.createRadialGradient(h.x / j, h.y / i, 0, h.x / j, h.y / i, a);
        f.addColorStop(0, g);
        f.addColorStop(1, e);
        m.fillStyle = f;
        var c = (180 - h.start - h.extent + 360) % 360;
        var b = new FR.Chart.Arc2D(h.x / j, h.y / i, a, c, h.extent);
        b.paint(m);
        m.restore()
    },
    getFrontPie3d: function () {
        var f = [];
        var e = this.getTheta();
        var i = this.top();
        var b = this.bottom();
        var c = i.start % 360;
        var g = (i.start + i.extent) % 360;
        var a = (e < 0 ? e + 360 : e);
        if (this.isAngleAtFront(c)) {
            if (!this.isAngleAtBack(g)) {
                if (this.extent < (180 + 2 * e)) {
                    var h = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    h.x = this.x;
                    h.y = this.y;
                    h.start = this.start;
                    h.extent = this.extent;
                    h.projection = this.projection;
                    h.info = this.info;
                    f.push(h);
                    return f
                } else {
                    var h = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    h.x = this.x;
                    h.y = this.y;
                    h.start = this.start;
                    h.extent = (360 - this.start) % 360;
                    h.projection = this.projection;
                    h.info = this.info;
                    h.startEnable = false;
                    var d = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    d.x = this.x;
                    d.y = this.y;
                    d.start = 180;
                    d.extent = (this.start + this.extent) % 360 - 180;
                    d.projection = this.projection;
                    d.info = this.info;
                    d.endEnable = false;
                    f.push(h);
                    f.push(d);
                    return f
                }
            } else {
                var h = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                h.x = this.x;
                h.y = this.y;
                h.start = this.start;
                h.extent = (360 - this.start % 360);
                h.projection = this.projection;
                h.info = this.info;
                f.push(h);
                return f
            }
        } else {
            if (!this.isAngleAtFront(g)) {
                if (this.extent < (180 - 2 * e)) {
                    return f
                } else {
                    var h = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    h.x = this.x;
                    h.y = this.y;
                    h.start = 180;
                    h.extent = 180;
                    h.projection = this.projection;
                    h.info = this.info;
                    f.push(h);
                    return f
                }
            } else {
                var h = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                h.x = this.x;
                h.y = this.y;
                h.start = 180;
                h.extent = (this.start + this.extent) % 360 - 180;
                h.projection = this.projection;
                h.info = this.info;
                f.push(h);
                return f
            }
        }
    },
    getBackPie3d: function () {
        var a = [];
        var f = this.getTheta();
        var g = this.top();
        var e = this.bottom();
        var h = g.start % 360;
        var c = (g.start + g.extent) % 360;
        if (this.isAngleAtFront(h)) {
            if (!this.isAngleAtBack(c)) {
                if (this.extent < (180 + 2 * f)) {
                    return a
                } else {
                    var b = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    b.x = this.x;
                    b.y = this.y;
                    b.start = 0;
                    b.extent = 180;
                    b.projection = this.projection;
                    b.info = this.info;
                    b.startEnable = false;
                    b.endEnable = false;
                    a.push(b);
                    return a
                }
            } else {
                var b = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                b.x = this.x;
                b.y = this.y;
                b.start = 0;
                b.extent = this.extent - (360 - this.start % 360);
                b.projection = this.projection;
                b.info = this.info;
                b.startEnable = false;
                a.push(b);
                return a
            }
        } else {
            if (!this.isAngleAtFront(c)) {
                if (this.extent < (180 - 2 * f)) {
                    var b = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    b.x = this.x;
                    b.y = this.y;
                    b.start = this.start;
                    b.extent = this.extent;
                    b.projection = this.projection;
                    b.info = this.info;
                    a.push(b);
                    return a
                } else {
                    var b = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    b.x = this.x;
                    b.y = this.y;
                    b.start = 360;
                    b.extent = (this.start + this.extent - 360) % 360;
                    b.projection = this.projection;
                    b.info = this.info;
                    b.startEnable = false;
                    var d = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                    d.x = this.x;
                    d.y = this.y;
                    d.start = this.start;
                    d.extent = (180 - this.start) % 360;
                    d.projection = this.projection;
                    d.info = this.info;
                    d.endEnable = false;
                    a.push(b);
                    a.push(d);
                    return a
                }
            } else {
                var b = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
                b.x = this.x;
                b.y = this.y;
                b.start = this.start;
                b.extent = (180 - this.start) % 360;
                b.projection = this.projection;
                b.info = this.info;
                b.endEnable = false;
                a.push(b);
                return a
            }
        }
    },
    paintNegtiveBack: function (i) {
        if (!i) {
            return
        }
        i.save();
        var h = this.top();
        var b = this.bottom();
        var d = h.start % 360;
        var f = (h.start + h.extent) % 360;
        var e = this.getTheta();
        var g = new FR.Chart.GeneralPath();
        if (this.isAngleAtFront(d)) {
            if (!this.isAngleAtBack(f)) {
                if (this.extent < (180 + 2 * e)) {
                } else {
                    g = this.getSideArea(h, b, e, 180 - e)
                }
            } else {
                g = this.getSideArea(h, b, e, f)
            }
        } else {
            if (!this.isAngleAtFront(f)) {
                if (this.extent < (180 - 2 * e)) {
                    g = this.getSideArea(h, b, d, f)
                } else {
                    var c = this.getSideArea(h, b, e, f);
                    var a = this.getSideArea(h, b, d, 180 - e);
                    g.append(c, false);
                    g.append(a, false)
                }
            } else {
                g = this.getSideArea(h, b, d, 180 - e)
            }
        }
        g.paint(i);
        i.restore()
    },
    paintBack: function (n) {
        if (!n) {
            return
        }
        n.save();
        var l = FR.Chart.Color.Hex2RGB(n.fillStyle);
        var g = FR.Chart.Color.RGB2HSB(l[0], l[1], l[2]);
        var j = FR.Chart.Color.HSB2RGB(g[0], g[1] + 0.1, g[2] - 0.1);
        var h = FR.Chart.Color.getColor(j);
        n.fillStyle = h;
        var m = this.top();
        var c = this.bottom();
        var e = m.start % 360;
        var i = (m.start + m.extent) % 360;
        var f = this.getTheta();
        var k = new FR.Chart.GeneralPath();
        var b = (f < 0 ? f + 360 : f);
        if (this.isAngleAtFront(e)) {
            if (!this.isAngleAtBack(i)) {
                if (this.extent < (180 + 2 * f)) {
                    k = this.getSideArea(m, c, e, i)
                } else {
                    var d = this.getSideArea(m, c, 180 - f, i);
                    var a = this.getSideArea(m, c, e, b);
                    k.append(d, false);
                    k.append(a, false)
                }
            } else {
                k = this.getSideArea(m, c, e, b)
            }
        } else {
            if (!this.isAngleAtFront(i)) {
                if (this.extent < (180 - 2 * f)) {
                } else {
                    k = this.getSideArea(m, c, 180 - f, b)
                }
            } else {
                k = this.getSideArea(m, c, 180 - f, i)
            }
        }
        k.paint(n);
        n.restore()
    },
    getSideArea: function (h, a, e, c) {
        var f = new FR.Chart.GeneralPath();
        var i = h.getShapeWithStartEnd(e, c, false);
        var b = a.getCounterclockwiseShapeWithStartEnd(e, c, false);
        var g = h.getPointWithAngle(e);
        var d = a.getPointWithAngle(c);
        f.moveTo(g.x, g.y);
        f.append(i, true);
        f.lineTo(d.x, d.y);
        f.append(b, true);
        f.closePath();
        return f
    },
    getTheta: function () {
        return Math.asin(-this.get_sin_theta()) * 180 / Math.PI
    },
    isAngleAtFront: function (a) {
        a = a / 180 * Math.PI;
        return (Math.sin(a) < -this.get_sin_theta())
    },
    isAngleAtBack: function (a) {
        return !this.isAngleAtFront(a)
    },
    get_sin_theta: function () {
        var b = (this.projection.elevation) / 180 * Math.PI;
        var a = this.projection.focus;
        return this.radius * (Math.pow(Math.sin(b), 2)) / (Math.cos(b) * a)
    },
    draw: function (a) {
    },
    getActionDefaultAnimateShape: function (b, e) {
        var c = [];
        for (var a = 0; a < b; a++) {
            var d = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
            d.x = this.x;
            d.y = this.y;
            d.start = this.start;
            d.extent = FR.Chart.ChartEase.easeOutQuint(a + 1, 0, this.extent, b);
            d.projection = this.projection;
            c.push(d)
        }
        return c
    },
    getActionChangeAnimateShape: function (c, h, f) {
        if (f <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (f == FR.Chart.ChartPaintConstants.STATE_APPEAR) {
            return this.getActionDefaultAnimateShape(c, f)
        }
        var e = [];
        for (var g = 0; g < c; g++) {
            var a = h.start;
            var k = h.extent;
            var j = this.start;
            var d = this.extent;
            if (Math.abs(j - a) > Math.abs(j - a + 360)) {
                j += 360
            }
            if (Math.abs(j - a) > Math.abs(j - a - 360)) {
                j -= 360
            }
            var m = FR.Chart.ChartEase.easeOutQuint(g + 1, h.x, this.x - h.x, c);
            var l = FR.Chart.ChartEase.easeOutQuint(g + 1, h.y, this.y - h.y, c);
            var b = new FR.Chart.Pie3D(this.start_y, this.depth, this.radius);
            b.x = m;
            b.y = l;
            b.start = this.start;
            b.extent = this.extent;
            b.projection = this.projection;
            e.push(b)
        }
        return e
    },
    getAnimateShape: function (b, a, d, c) {
        if (d && a == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
            return this.getActionChangeAnimateShape(b, d, c)
        } else {
            return this.getActionDefaultAnimateShape(b)
        }
    },
    containsPoint: function (a, b) {
        return this.top().getShape().containsPoint(a, b)
    },
    top: function () {
        return this.getArc2D(0, true)
    },
    bottom: function () {
        return this.getArc2D(this.depth, true)
    },
    back: function () {
        var f = this.getArc2D(0, false);
        var d = this.getArc2D(this.depth, false);
        var c = new FR.Chart.GeneralPath();
        var a = f.getStartPoint();
        var e = f.getEndPoint();
        var b = d.getEndPoint();
        var g = d.getStartPoint();
        c.moveTo(a.x, a.y);
        c.append(f.getShape(), true);
        c.lineTo(b.x, b.y);
        c.append(d.getCounterclockwiseShape(), true);
        c.closePath();
        return c
    },
    getStartSide: function () {
        var e = this.getArc2D(0, false);
        var b = this.getArc2D(this.depth, false);
        var a = e.getStartPoint();
        var c = e.getCenterPoint();
        var g = b.getStartPoint();
        var d = b.getCenterPoint();
        var f = new FR.Chart.GeneralPath();
        f.moveTo(a.x, a.y);
        f.lineTo(g.x, g.y);
        f.lineTo(d.x, d.y);
        f.lineTo(c.x, c.y);
        f.closePath();
        return f
    },
    getEndSide: function () {
        var g = this.getArc2D(0, false);
        var b = this.getArc2D(this.depth, false);
        var d = g.getEndPoint();
        var e = g.getCenterPoint();
        var a = b.getEndPoint();
        var f = b.getCenterPoint();
        var c = new FR.Chart.GeneralPath();
        c.moveTo(d.x, d.y);
        c.lineTo(a.x, a.y);
        c.lineTo(f.x, f.y);
        c.lineTo(e.x, e.y);
        c.closePath();
        return c
    },
    sides: function () {
        var a = [];
        a.push(this.getStartSide());
        a.push(this.getEndSide());
        return a
    },
    getArc2D: function (c, b) {
        var a = this.projection.projecteeArc(this.start_y + c, this.radius, this.start, this.extent, !!b);
        a.x += this.x + a.width / 2;
        a.y += this.y + a.height / 2;
        return a
    },
    getTopArcCenterPoint: function () {
        var b = this.top();
        var a = b.getMiddlePoint();
        return new FR.Chart.Point2D((b.x + a.x) / 2, (b.y + a.y) / 2)
    }
});
FR.Chart.Pie3DSide = function (b, a) {
    if (b instanceof FR.Chart.ShapeGlyph) {
        this.shapeGlyph = b;
        this.cylinder = b.shape
    } else {
        this.cylinder = b
    }
    this.isStart = a
};
FR.Chart.Ellipse = function (b, g, e, a, f, d, c) {
    this.x = b;
    this.y = g;
    this.width = e;
    this.height = a;
    this.start = f;
    this.extent = d;
    this.type = !!c
};
$.extend(FR.Chart.Ellipse.prototype, {
    x: 0, y: 0, width: 0, height: 0, start: 0, extent: 0, type: true, paint: function (a) {
        this.getShape().paint(a)
    }, draw: function (a) {
        this.getShape().draw(a)
    }, getShape: function () {
        return this.getShapeWithStartEnd(this.start, this.extent + this.start, this.type)
    }, getCounterclockwiseShape: function () {
        return this.getCounterclockwiseShapeWithStartEnd(this.start, this.extent + this.start, false)
    }, getClockwiseShape: function () {
        return this.getShapeWithStartEnd(this.start, this.extent + this.start, false)
    }, getShapeWithStartEnd: function (h, d, j) {
        var i = new FR.Chart.GeneralPath();
        var e = Math.PI / 90;
        var c = (h / 180) * Math.PI + Math.PI;
        var g = ((d - h) / 180) * Math.PI + c;
        var f = c;
        var l = this.width / 2;
        var k = this.height / 2;
        j = !!j;
        if (j) {
            i.moveTo(this.x, this.y)
        } else {
            i.moveTo(this.x + l * Math.cos(c), this.y + k * Math.sin(c))
        }
        while (f <= g) {
            i.lineTo(this.x + l * Math.cos(f), this.y + (k * Math.sin(f)));
            f += e
        }
        i.lineTo(this.x + l * Math.cos(g), this.y + (k * Math.sin(g)));
        if (j) {
            i.closePath()
        }
        return i
    }, getCounterclockwiseShapeWithStartEnd: function (h, d, j) {
        var i = new FR.Chart.GeneralPath();
        var e = Math.PI / 90;
        var c = (h / 180) * Math.PI + Math.PI;
        var g = ((d - h) / 180) * Math.PI + c;
        var f = g;
        var l = this.width / 2;
        var k = this.height / 2;
        j = !!j;
        if (j) {
            i.moveTo(this.x, this.y)
        } else {
            i.moveTo(this.x + l * Math.cos(g), this.y + k * Math.sin(g))
        }
        while (f >= c) {
            i.lineTo(this.x + l * Math.cos(f), this.y + (k * Math.sin(f)));
            f -= e
        }
        i.lineTo(this.x + l * Math.cos(c), this.y + (k * Math.sin(c)));
        if (j) {
            i.closePath()
        }
        return i
    }, getPointWithAngle: function (e) {
        var d = this.width / 2;
        var c = this.height / 2;
        e = (e / 180) * Math.PI + Math.PI;
        return new FR.Chart.Point2D(this.x + d * Math.cos(e), this.y + c * Math.sin(e))
    }, getStartPoint: function () {
        return this.getPointWithAngle(this.start)
    }, getMiddlePoint: function () {
        return this.getPointWithAngle(this.start + this.extent / 2)
    }, getEndPoint: function () {
        return this.getPointWithAngle(this.start + this.extent)
    }, getCenterPoint: function () {
        return new FR.Chart.Point2D(this.x, this.y)
    }, getMiddleAngle: function () {
        return this.start + this.extent / 2
    }, getMaxXPoint: function () {
        var b = this.width / 2;
        return new FR.Chart.Point2D(this.x + b, this.y)
    }, getMinXPoint: function () {
        var b = this.width / 2;
        return new FR.Chart.Point2D(this.x - b, this.y)
    }
});
FR.Chart.Ring3D = function (a) {
    this.projection = a;
    this.outerCylinderList = [];
    this.innerCylinderList = [];
    this.origin = []
};
$.extend(FR.Chart.Ring3D.prototype, {
    projection: null, outerCylinderList: null, innerCylinderList: null, paint: function (a) {
    }, draw: function (a) {
    }, drawTop: function (m) {
        if (!m) {
            return
        }
        m.save();
        for (var e = 0; e < this.getCylinderCount(); e++) {
            var f = new FR.Chart.Ring3D(this.projection);
            var j = this.getOuterCylinder(e);
            var l = j.info.getBackground().color;
            f.addCylinder(this.getOuterCylinder(e), this.getInnerCylinder(e));
            m.fillStyle = l;
            var k = FR.Chart.Color.Hex2RGB(m.fillStyle);
            var b = FR.Chart.Color.RGB2HSB(k[0], k[1], k[2]);
            var g = FR.Chart.Color.HSB2RGB(b[0], b[1] - 0.2, b[2] + 0.25);
            var c = FR.Chart.Color.getColor(g);
            var h = this.origin[e].top();
            var a = h.getMiddlePoint();
            var d = m.createLinearGradient(h.x, h.y, a.x, a.y);
            d.addColorStop(0, c);
            d.addColorStop(1, m.fillStyle);
            m.fillStyle = d;
            f.top().paint(m)
        }
        m.restore()
    }, drawBack: function (a) {
        if (!a) {
            return
        }
        a.save();
        for (var c = 0; c < this.getCylinderCount(); c++) {
            var d = this.getInnerCylinder(c);
            var b = d.info.getBackground().color;
            a.fillStyle = b;
            d.paintNegtiveBack(a)
        }
        a.restore()
    }, drawPositive: function (a) {
        if (!a) {
            return
        }
        a.save();
        for (var c = 0; c < this.getCylinderCount();
             c++) {
            var d = this.getOuterCylinder(c);
            var b = d.info.getBackground().color;
            a.fillStyle = b;
            d.paintBack(a)
        }
        a.restore()
    }, drawSide: function (h) {
        if (!h) {
            return
        }
        h.save();
        var j = [];
        var f = [];
        for (var b = 0; b < this.getCylinderCount(); b++) {
            if (this.getOuterCylinder(b).startEnable) {
                j.push(new FR.Chart.Pie3DSide(this.getOuterCylinder(b), true));
                f.push(new FR.Chart.Pie3DSide(this.getInnerCylinder(b), true))
            }
            if (this.getOuterCylinder(b).endEnable) {
                j.push(new FR.Chart.Pie3DSide(this.getOuterCylinder(b), false));
                f.push(new FR.Chart.Pie3DSide(this.getInnerCylinder(b), false))
            }
        }
        j.sort(FR.Chart.ChartUtils.sortPie3DSide);
        f.sort(FR.Chart.ChartUtils.sortPie3DSide);
        for (var c = 0; c < j.length; c++) {
            var g = j[c];
            var a = f[c];
            var d = new FR.Chart.Ring3D(this.projection);
            d.addCylinder(g.cylinder, a.cylinder);
            var e = g.cylinder.info.getBackground().color;
            h.fillStyle = e;
            if (g.isStart && g.cylinder.startEnable) {
                d.paintStartSide(h)
            } else {
                if (!g.isStart && g.cylinder.endEnable) {
                    d.paintEndSide(h)
                }
            }
        }
        h.restore()
    }, getCylinderCount: function () {
        return this.innerCylinderList.length
    }, getAnimateShape: function (b, a, d, c) {
        var e = [];
        return e
    }, top: function () {
        var a = this.getInnerCylinder(0);
        var c = this.getOuterCylinder(0);
        var d = a.top();
        var e = c.top();
        var b = e.getStartPoint();
        var f = d.getEndPoint();
        var g = new FR.Chart.GeneralPath();
        g.moveTo(b.x, b.y);
        g.append(e.getClockwiseShape(), true);
        g.lineTo(f.x, f.y);
        g.append(d.getCounterclockwiseShape(), true);
        g.closePath();
        return g
    }, front: function () {
        var a = this.getInnerCylinder(0);
        return a.back()
    }, back: function () {
        var a = this.getOuterCylinder(0);
        return a.back()
    }, paintStartSide: function (a) {
        if (!a) {
            return
        }
        a.save();
        var c = FR.Chart.Color.Hex2RGB(a.fillStyle);
        var f = FR.Chart.Color.RGB2HSB(c[0], c[1], c[2]);
        var b = FR.Chart.Color.HSB2RGB(f[0], f[1] + 0.1, f[2] - 0.15);
        var d = FR.Chart.Color.getColor(b);
        a.fillStyle = d;
        var e = this.getStartSide();
        e.paint(a);
        a.restore()
    }, getStartSide: function () {
        var d = this.getOuterCylinder(0);
        var b = this.getInnerCylinder(0);
        var a = d.top().getStartPoint();
        var e = b.top().getStartPoint();
        var g = d.bottom().getStartPoint();
        var c = b.bottom().getStartPoint();
        var f = new FR.Chart.GeneralPath();
        f.moveTo(a.x, a.y);
        f.lineTo(g.x, g.y);
        f.lineTo(c.x, c.y);
        f.lineTo(e.x, e.y);
        f.closePath();
        return f
    }, paintEndSide: function (a) {
        if (!a) {
            return
        }
        a.save();
        var c = FR.Chart.Color.Hex2RGB(a.fillStyle);
        var f = FR.Chart.Color.RGB2HSB(c[0], c[1], c[2]);
        var b = FR.Chart.Color.HSB2RGB(f[0], f[1] + 0.1, f[2] - 0.15);
        var d = FR.Chart.Color.getColor(b);
        a.fillStyle = d;
        var e = this.getEndSide();
        e.paint(a);
        a.restore()
    }, getEndSide: function () {
        var d = this.getOuterCylinder(0);
        var b = this.getInnerCylinder(0);
        var a = d.top().getEndPoint();
        var f = b.top().getEndPoint();
        var g = d.bottom().getEndPoint();
        var c = b.bottom().getEndPoint();
        var e = new FR.Chart.GeneralPath();
        e.moveTo(a.x, a.y);
        e.lineTo(g.x, g.y);
        e.lineTo(c.x, c.y);
        e.lineTo(f.x, f.y);
        e.closePath();
        return e
    }, calculateBackHalf: function () {
        var b = new FR.Chart.Ring3D(this.projection);
        for (var d = 0; d < this.getCylinderCount(); d++) {
            var e = this.getOuterCylinder(d).getBackPie3d();
            var a = this.getInnerCylinder(d).getBackPie3d();
            if (e.length == a.length) {
                for (var c = 0; c < e.length; c++) {
                    b.addCylinder(e[c], a[c]);
                    b.addOrigin(this.getOuterCylinder(d))
                }
            }
        }
        return b
    }, calculateFrontHalf: function () {
        var d = new FR.Chart.Ring3D(this.projection);
        for (var c = 0; c < this.getCylinderCount(); c++) {
            var e = this.getOuterCylinder(c).getFrontPie3d();
            var a = this.getInnerCylinder(c).getFrontPie3d();
            if (e.length == a.length) {
                for (var b = 0; b < e.length; b++) {
                    d.addCylinder(e[b], a[b]);
                    d.addOrigin(this.getOuterCylinder(c))
                }
            }
        }
        return d
    }, addOuterCylinder: function (a) {
        this.outerCylinderList.push(a)
    }, addInnerCylinder: function (a) {
        this.innerCylinderList.push(a)
    }, getOuterCylinder: function (a) {
        if (this.outerCylinderList && a < this.outerCylinderList.length) {
            return this.outerCylinderList[a]
        }
    }, getInnerCylinder: function (a) {
        if (this.innerCylinderList && a < this.innerCylinderList.length) {
            return this.innerCylinderList[a]
        }
    }, getRingStartAngle: function () {
        return this.getOuterCylinder(0).top().start
    }, getRingEndAngle: function () {
        var a = this.getOuterCylinder(0).top();
        return a.start + a.extent
    }, addCylinder: function (b, a) {
        this.outerCylinderList.push(b);
        this.innerCylinderList.push(a)
    }, addOrigin: function (a) {
        this.origin.push(a)
    }, getTopArcCenterPoint: function () {
        var a = this.getInnerCylinder(0);
        var b = this.getOuterCylinder(0);
        var c = a.top().getMiddlePoint();
        var d = b.top().getMiddlePoint();
        return new FR.Chart.Point2D((c.x + d.x) / 2, (c.y + d.y) / 2)
    }, containsPoint: function (a, b) {
        return this.top().containsPoint(a, b)
    }
});
FR.Chart.Ring = function (a, h, f, d, b, g, e, c) {
    this.x = a;
    this.y = h;
    this.outerRadius = f;
    this.outerStart = d;
    this.outerExtent = b;
    this.innerRadius = g;
    this.innerStart = e;
    this.innerExtent = c;
    if (this.innerExtent === 360 || this.outerExtent === 360) {
        this.outerStart = this.innerStart = 0;
        this.outerExtent = this.innerExtent = 360
    }
    this.outerCircle = new FR.Chart.Ellipse(this.x, this.y, this.outerRadius * 2, this.outerRadius * 2, this.outerStart, this.outerExtent);
    this.innerCircle = new FR.Chart.Ellipse(this.x, this.y, this.innerRadius * 2, this.innerRadius * 2, this.innerStart, this.innerExtent)
};
$.extend(FR.Chart.Ring.prototype, {
    x: 0,
    y: 0,
    outerRadius: 0,
    outerStart: 0,
    outerExtent: 0,
    innerRadius: 0,
    innerStart: 0,
    innerExtent: 0,
    outerCircle: null,
    innerCircle: null,
    paint: function (a) {
        this.doWithTheRing(a, true)
    },
    draw: function (a) {
        this.doWithTheRing(a, false)
    },
    doWithTheRing: function (a, c) {
        var b = this._getRingShape();
        if (c) {
            b.paint(a)
        } else {
            b.draw(a)
        }
    },
    getBounds2D: function () {
        return new FR.Chart.Bounds(this.x, this.y, this.outerRadius, this.outerRadius)
    },
    isNeedRadialGradient: function () {
        return true
    },
    getCenterPoint: function () {
        return new FR.Chart.Point2D(this.x, this.y)
    },
    getInnerRadius: function () {
        return this.innerRadius
    },
    getOuterRadius: function () {
        return this.outerRadius
    },
    getHalfAnglePoint: function () {
        return this.outerCircle.getMiddlePoint()
    },
    getBottomPoint: function () {
        var b = this.outerCircle.getStartPoint();
        var a = this.outerCircle.getEndPoint();
        return b.y > a.y ? b : a
    },
    getLeftMostPoint: function () {
        var b = this.outerCircle.getStartPoint();
        var a = this.outerCircle.getEndPoint();
        return b.x > a.x ? a : b
    },
    getRightMostPoint: function () {
        var b = this.outerCircle.getStartPoint();
        var a = this.outerCircle.getEndPoint();
        return b.x > a.x ? b : a
    },
    getTopPoint: function () {
        var b = this.outerCircle.getStartPoint();
        var a = this.outerCircle.getEndPoint();
        return b.y > a.y ? a : b
    },
    _getRingShape: function () {
        var c = new FR.Chart.GeneralPath();
        var a = this.outerCircle.getClockwiseShape();
        var e = this.innerCircle.getCounterclockwiseShape();
        var b = this.outerCircle.getStartPoint();
        var d = this.innerCircle.getEndPoint();
        c.moveTo(b.x, b.y);
        c.append(a, true);
        c.lineTo(d.x, d.y);
        c.append(e, true);
        c.closePath();
        return c
    },
    getAnimateShape: function (b, a, d, c) {
        if (d && a == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
            return this.getActionChangeAnimateShape(b, d, c)
        } else {
            return this.getActionDefaultAnimateShape(b, c)
        }
    },
    getActionChangeAnimateShape: function (f, p, h) {
        if (h <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (h == FR.Chart.ChartPaintConstants.STATE_APPEAR) {
            return this.getActionDefaultAnimateShape(f)
        }
        var g = [];
        for (var l = 0; l < f; l++) {
            var o = p.outerStart;
            var k = p.outerExtent;
            var c = this.outerStart;
            var j = this.outerExtent;
            var q = p.innerStart;
            var e = p.innerExtent;
            var n = this.innerStart;
            var b = this.innerExtent;
            if (Math.abs(c - o) > Math.abs(c - o + 360)) {
                c += 360
            }
            if (Math.abs(c - o) > Math.abs(c - o - 360)) {
                c -= 360
            }
            if (Math.abs(n - q) > Math.abs(n - q + 360)) {
                n += 360
            }
            if (Math.abs(n - q) > Math.abs(n - q - 360)) {
                n -= 360
            }
            var d = FR.Chart.ChartEase.easeOutQuint(l + 1, o, c - o, f);
            var a = FR.Chart.ChartEase.easeOutQuint(l + 1, k, j - k, f);
            var m = FR.Chart.ChartEase.easeOutQuint(l + 1, q, n - q, f);
            var r = FR.Chart.ChartEase.easeOutQuint(l + 1, e, b - e, f);
            g[l] = new FR.Chart.Ring(this.x, this.y, this.outerRadius, d, a, this.innerRadius, m, r)
        }
        return g
    },
    getActionDefaultAnimateShape: function (d, f) {
        var e = [];
        if (f <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return e
        }
        if (this.innerExtent === 360 || this.outerExtent === 360) {
            this.outerStart = this.innerStart = 0;
            this.outerExtent = this.innerExtent = 360
        }
        for (var c = 0; c < d; c++) {
            var b = Math.min(FR.Chart.ChartEase.easeOutQuint(c + 1, 0, this.outerExtent, d), this.outerExtent);
            var a = Math.min(FR.Chart.ChartEase.easeOutQuint(c + 1, 0, this.innerExtent, d), this.innerExtent);
            e[c] = new FR.Chart.Ring(this.x, this.y, this.outerRadius, this.outerStart, b, this.innerRadius, this.innerStart, a)
        }
        return e
    },
    drawDragBorder: function (a) {
    },
    containsPoint: function (a, b) {
        return this._getRingShape().containsPoint(a, b)
    },
    getPointWithAngle: function (a) {
        return this.outerCircle.getPointWithAngle(a)
    },
    getHalfAngle: function () {
        return this.outerStart + this.outerExtent / 2
    },
    getExtent: function () {
        return this.outerExtent
    },
    getRadius: function () {
        return this.outerRadius
    }
});
FR.Chart.Arc2D = function (b, f, a, e, d, c) {
    this.x = b;
    this.y = f;
    this.start = e;
    this.extent = d;
    this.radius = a;
    this.width = a * 2;
    this.height = a * 2;
    this.type = FR.pick(c, FR.Chart.Arc2D.PIE)
};
$.extend(FR.Chart.Arc2D, {CHORD: 0, OPEN: 1, PIE: 2});
$.extend(FR.Chart.Arc2D.prototype, {
    x: 0, y: 0, start: 0, extent: 0, radius: 0, width: 0, height: 0, paint: function (a) {
        this.doWithTheArc(a, true)
    }, draw: function (a) {
        this.doWithTheArc(a, false)
    }, transform: function (c) {
        var f = c.transform({x: this.x, y: this.y});
        var d = c.transform({x: this.x + this.radius, y: this.y + this.radius});
        var b = Math.abs(f.x - d.x);
        var e = Math.abs(f.y - d.y);
        var a = Math.sqrt(b * b + e + e);
        return new FR.Chart.Arc2D(f.x, f.y, a, this.start, this.extent)
    }, drawDragBorder: function (a) {
        var g = (180 - this.start - this.extent + 360) % 360;
        var c = this.extent;
        var b = g + c / 2;
        b = (b / 180) * Math.PI + Math.PI;
        var e = this.x + -5 * Math.cos(b);
        var d = this.y + -5 * Math.sin(b);
        var f = new FR.Chart.Arc2D(e, d, this.radius + 8, this.start, this.extent, this.type);
        f.draw(a)
    }, doWithTheArc: function (j, d) {
        var g = true;
        var f = this.type;
        var b = Number(360 - this.start).toFixed(2);
        var i = -Number(this.extent).toFixed(2);
        b = Number(b);
        i = Number(i);
        if (Math.abs(i) === 360) {
            g = false;
            f = FR.Chart.Arc2D.OPEN;
            i = 360;
            b = 0
        } else {
            if (i > 0) {
                g = false
            } else {
                if (i === 0) {
                    return
                }
            }
        }
        var e = b * Math.PI / 180;
        var c = (i + b) * Math.PI / 180;
        var a = new FR.Chart.Point2D(this.x + this.radius * Math.cos(e), this.y + this.radius * Math.sin(e));
        var h = new FR.Chart.Point2D(this.x + this.radius * Math.cos(c), this.y + this.radius * Math.sin(c));
        if (d) {
            j.beginPath();
            switch (f) {
                case FR.Chart.Arc2D.CHORD:
                case FR.Chart.Arc2D.OPEN:
                    j.moveTo(a.x, a.y);
                    break;
                case FR.Chart.Arc2D.PIE:
                    j.moveTo(this.x, this.y);
                    break
            }
            j.arc(this.x, this.y, this.radius, e, c, g);
            j.fill()
        } else {
            if (i < 360 && this.type != FR.Chart.Arc2D.OPEN) {
                j.beginPath();
                j.moveTo(a.x, a.y);
                if (this.type == FR.Chart.Arc2D.PIE) {
                    j.lineTo(this.x, this.y)
                }
                j.lineTo(h.x, h.y);
                j.stroke()
            }
            j.beginPath();
            j.globalAlpha = 0.5;
            j.arc(this.x, this.y, this.radius, e, c, g);
            j.stroke()
        }
    }, getActionChangeAnimateShape: function (c, h, f) {
        if (f <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (f == FR.Chart.ChartPaintConstants.STATE_APPEAR) {
            return this.getActionDefaultAnimateShape(c)
        }
        var e = [];
        for (var g = 0; g < c; g++) {
            var a = h.start;
            var k = h.extent;
            var j = this.start;
            var d = this.extent;
            if (Math.abs(j - a) > Math.abs(j - a + 360)) {
                j += 360
            }
            if (Math.abs(j - a) > Math.abs(j - a - 360)) {
                j -= 360
            }
            var b = FR.Chart.ChartEase.easeOutQuint(g + 1, a, j - a, c);
            var n = FR.Chart.ChartEase.easeOutQuint(g + 1, k, d - k, c);
            var m = FR.Chart.ChartEase.easeOutQuint(g + 1, h.x, this.x - h.x, c);
            var l = FR.Chart.ChartEase.easeOutQuint(g + 1, h.y, this.y - h.y, c);
            e[g] = new FR.Chart.Arc2D(m, l, this.radius, b, n, this.type)
        }
        return e
    }, getActionDefaultAnimateShape: function (b) {
        var c = [];
        for (var a = 0; a < b; a++) {
            c[a] = new FR.Chart.Arc2D(this.x, this.y, this.radius, this.start, FR.Chart.ChartEase.easeOutQuint(a + 1, 0, this.extent, b), this.type)
        }
        return c
    }, getAnimateShape: function (b, a, d, c) {
        if (d && a == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
            return this.getActionChangeAnimateShape(b, d, c)
        } else {
            return this.getActionDefaultAnimateShape(b)
        }
    }, getStartPoint: function () {
        return this.getArcPoint(-this.start)
    }, getArcPoint: function (b) {
        b = b * Math.PI / 180;
        var a = this.x + (Math.cos(b) * 0.5) * this.width;
        var c = this.y + (Math.sin(b) * 0.5) * this.height;
        return new FR.Chart.Point2D(a, c)
    }, getEndPoint: function () {
        return this.getArcPoint(-(this.start + this.extent))
    }, getHalfAnglePoint: function () {
        return this.getArcPoint(-(this.start + this.extent / 2))
    }, isNeedRadialGradient: function () {
        return false
    }, getCenterPoint: function () {
        return new FR.Chart.Point2D(this.x, this.y)
    }, getBounds2D: function () {
        var b, k, a, j;
        if (this.type == FR.Chart.Arc2D.PIE) {
            b = k = a = j = 0
        } else {
            b = k = 1;
            a = j = -1
        }
        var c = 0;
        for (var d = 0; d < 6; d++) {
            if (d < 4) {
                c += 90;
                if (!this.containsAngle(c)) {
                    continue
                }
            } else {
                if (d === 4) {
                    c = this.start
                } else {
                    c += this.extent
                }
            }
            var g = -c * Math.PI / 180;
            var m = Math.cos(g);
            var f = Math.sin(g);
            b = Math.min(b, m);
            k = Math.min(k, f);
            a = Math.max(a, m);
            j = Math.max(j, f)
        }
        var l = this.width;
        var e = this.height;
        a = (a - b) * 0.5 * l;
        j = (j - k) * 0.5 * e;
        b = this.x + (b * 0.5) * l;
        k = this.y + (k * 0.5) * e;
        return new FR.Chart.Bounds(b, k, a, j)
    }, containsPoint: function (n, l) {
        var i = this.width;
        if (i <= 0) {
            return false
        }
        var e = (n - this.x + this.width / 2) / i - 0.5;
        var a = this.height;
        if (a <= 0) {
            return false
        }
        var c = (l - this.y + this.height / 2) / a - 0.5;
        var o = (e * e + c * c);
        if (o >= 0.25) {
            return false
        }
        var j = Math.abs(this.extent);
        if (j >= 360) {
            return true
        }
        var h = this.containsAngle(-Math.atan2(c, e) * 180 / Math.PI);
        if (this.type == FR.Chart.Arc2D.PIE) {
            return h
        }
        if (h) {
            if (j >= 180) {
                return true
            }
        } else {
            if (j <= 180) {
                return false
            }
        }
        var g = -this.start / 180 * Math.PI;
        var d = Math.cos(g);
        var m = Math.sin(g);
        g += -this.extent / 180 * Math.PI;
        var b = Math.cos(g);
        var k = Math.sin(g);
        var f = (FR.Chart.Line2D.relativeCCW(d, m, b, k, n, l) * FR.Chart.Line2D.relativeCCW(d, m, b, k, 0, 0) >= 0);
        return h ? !f : f
    }, normalizeDegrees: function (a) {
        if (a > 180) {
            if (a <= (180 + 360)) {
                a = a - 360
            } else {
                a = a - (360 * Math.Round(a / 360));
                if (a == -180) {
                    a = 180
                }
            }
        } else {
            if (a <= -180) {
                if (a > (-180 - 360)) {
                    a = a + 360
                } else {
                    a = a - (360 * Math.Round(a / 360));
                    if (a == -180) {
                        a = 180
                    }
                }
            }
        }
        return a
    }, containsAngle: function (c) {
        var b = this.extent;
        var a = (b < 0);
        if (a) {
            b = -b
        }
        if (b >= 360) {
            return true
        }
        c = this.normalizeDegrees(c) - this.normalizeDegrees(this.start);
        if (a) {
            c = -c
        }
        if (c < 0) {
            c += 360
        }
        return (c >= 0) && (c < b)
    }, getPointWithAngle: function (a) {
        return this.getArcPoint(a + 180)
    }, getHalfAngle: function () {
        var b = (180 - this.start - this.extent + 360) % 360;
        var a = this.extent;
        return (b + a / 2) % 360
    }, getBottomPoint: function () {
        var b = this.getStartPoint();
        var a = this.getEndPoint();
        return b.y > a.y ? b : a
    }, getLeftMostPoint: function () {
        var b = this.getStartPoint();
        var a = this.getEndPoint();
        return b.x > a.x ? a : b
    }, getRightMostPoint: function () {
        var b = this.getStartPoint();
        var a = this.getEndPoint();
        return b.x > a.x ? b : a
    }, getTopPoint: function () {
        var b = this.getStartPoint();
        var a = this.getEndPoint();
        return b.y > a.y ? a : b
    }, getExtent: function () {
        return this.extent
    }, getRadius: function () {
        return this.radius
    }
});
FR.Chart.MoveButton = function (a, b) {
    this.bounds = new FR.Chart.Bounds(a, b, FR.Chart.MoveButton.WIDTH, FR.Chart.MoveButton.HEIGHT)
};
$.extend(FR.Chart.MoveButton.prototype, {
    draw: function (c) {
        if (this.bounds) {
            var b = this.bounds.x;
            var g = this.bounds.y;
            var a = this.bounds.height;
            var e = this.bounds.width;
            var d = new FR.Chart.RoundBounds(b, g, e, a, 5, 5);
            c.fillStyle = "rgb(255, 255, 255)";
            d.paint(c);
            c.lineWidth = 1;
            c.strokeStyle = "rgb(102,102,102)";
            d.draw(c);
            var f = new FR.Chart.GeneralPath();
            f.moveTo(b + e / 2 - 1, g + a / 2 - 2.5);
            f.lineTo(b + e / 2 - 1, g + a / 2 + 2.5);
            f.moveTo(b + e / 2 + 1, g + a / 2 - 2.5);
            f.lineTo(b + e / 2 + 1, g + a / 2 + 2.5);
            f.draw(c)
        }
    }, containsPoint: function (a, c) {
        var b = new FR.Chart.Bounds(this.bounds.x - 10, this.bounds.y - 10, this.bounds.width + 20, this.bounds.height + 20);
        return this.bounds ? b.containsPoint(a, c) : false
    }
});
$.extend(FR.Chart.MoveButton, {WIDTH: 11, HEIGHT: 19});
FR.Chart.LegendButton = function (b, c, a) {
    this.position = FR.pick(a, FR.Chart.Constants.TOP);
    this.initButtonBounds(b, c);
    this.onPress = false;
    this.isDisable = false;
    this.onMove = false
};
$.extend(FR.Chart.LegendButton.prototype, {
    initButtonBounds: function (a, b) {
        switch (this.position) {
            case FR.Chart.Constants.TOP:
                this.bounds = new FR.Chart.Bounds(a, b, FR.Chart.LegendButton.TOP_WIDTH, FR.Chart.LegendButton.TOP_HEIGHT);
                break;
            case FR.Chart.Constants.LEFT:
                this.bounds = new FR.Chart.Bounds(a, b, FR.Chart.LegendButton.RIGHT_WIDTH, FR.Chart.LegendButton.RIGHT_HEIGHT);
                break;
            case FR.Chart.Constants.RIGHT:
                this.bounds = new FR.Chart.Bounds(a, b, FR.Chart.LegendButton.RIGHT_WIDTH, FR.Chart.LegendButton.RIGHT_HEIGHT);
                break;
            default:
                this.bounds = new FR.Chart.Bounds(a, b, FR.Chart.LegendButton.TOP_WIDTH, FR.Chart.LegendButton.TOP_HEIGHT)
        }
    }, draw: function (a) {
        if (!this.bounds) {
            return
        }
        if (!a) {
            return
        }
        a.save();
        if (this.isDisable) {
            a.strokeStyle = "rgb(139, 192, 241)"
        } else {
            a.strokeStyle = "rgb(221, 221, 221)"
        }
        a.lineWidth = 3;
        this._drawButtonPath(a);
        a.restore()
    }, _drawButtonPath: function (a) {
        if (this.bounds) {
            a.translate(this.bounds.x, this.bounds.y);
            var b = this._getButtonPath();
            b.draw(a);
            a.translate(-this.bounds.x, -this.bounds.y)
        }
    }, _getButtonPath: function () {
        var c = new FR.Chart.GeneralPath();
        var b = this.bounds.width;
        var a = this.bounds.height;
        if (this.position == FR.Chart.Constants.TOP) {
            c.moveTo(1, a - 1);
            c.lineTo(b / 2, 1);
            c.lineTo(b - 1, a - 1)
        } else {
            if (this.position == FR.Chart.Constants.BOTTOM) {
                c.moveTo(1, 1);
                c.lineTo(b / 2, a - 1);
                c.lineTo(b - 1, 1)
            } else {
                if (this.position == FR.Chart.Constants.RIGHT) {
                    c.moveTo(0, 0);
                    c.lineTo(b, a / 2);
                    c.lineTo(0, a)
                } else {
                    if (this.position == FR.Chart.Constants.LEFT) {
                        c.moveTo(b, 0);
                        c.lineTo(0, a / 2);
                        c.lineTo(b, a)
                    }
                }
            }
        }
        return c
    }, drawOnPress: function (a) {
        if (this.bounds) {
            if (!a) {
                return
            }
            a.save();
            a.lineWidth = 3;
            a.strokeStyle = "rgb(75, 145, 194)";
            this._drawButtonPath(a);
            a.restore()
        }
    }, draw4OnMove: function (a) {
        if (!this.bounds || !this.onMove) {
            return
        }
        if (!a) {
            return
        }
        a.save();
        a.strokeStyle = "rgb(85,166,222)";
        a.lineWidth = 3;
        this._drawButtonPath(a);
        a.restore()
    }, containsPoint: function (a, b) {
        return this.bounds == null ? false : this.bounds.containsPoint(a, b)
    }
});
$.extend(FR.Chart.LegendButton, {TOP_WIDTH: 13, TOP_HEIGHT: 9, RIGHT_WIDTH: 9, RIGHT_HEIGHT: 13});
FR.Chart.Bubble = function (b, c, a) {
    this.centerX = b;
    this.centerY = c;
    this.radius = a;
    this.bounds = new FR.Chart.Bounds(b - a, c - a, a * 2, a * 2);
    this.colorInfo = new FR.Chart.ColorInfo();
    this.jsType = "bubble"
};
$.extend(FR.Chart.Bubble.prototype, {
    getTooltipBounds4Shape: function (b) {
        var a = this.centerX + this.radius / Math.sqrt(2) + 1;
        var c = this.centerY + this.radius / Math.sqrt(2) + 1;
        b.x = a;
        b.y = c;
        return b
    }, draw: function (a) {
        if (this.radius <= 1) {
            return
        }
        if (!a) {
            return
        }
        a.save();
        a.globalAlpha = this.colorInfo.seriesAttrAlpha.alpha;
        var c = FR.Chart.Color.getColorArray(this.colorInfo.seriesAttrColor.seriesColor);
        a.fillStyle = "rgba(" + c + ",0.6)";
        var b = new FR.Chart.Arc2D(this.centerX, this.centerY, this.radius + 1, 0, 360, FR.Chart.Arc2D.OPEN);
        b.paint(a);
        a.globalAlpha = 0.5;
        a.strokeStyle = "rgb(" + c + ")";
        b.draw(a);
        a.restore()
    }, getShape: function () {
        return this
    }, getBounds2D: function () {
        var a = new FR.Chart.Arc2D(this.centerX, this.centerY, this.radius, 0, 360, FR.Chart.Arc2D.PIE);
        return a.getBounds2D()
    }, isNeedRadialGradient: function () {
        return false
    }, drawDragBorder: function (a) {
        var b = new FR.Chart.Arc2D(this.centerX, this.centerY, this.radius + 3, 0, 360, FR.Chart.Arc2D.PIE);
        b.draw(a)
    }, setAlpha: function (a) {
        this.colorInfo.seriesAttrAlpha.alpha = a
    }, getAlpha: function () {
        return this.colorInfo.seriesAttrAlpha.alpha
    }, getAnimateGlyph: function (f, e, c, g) {
        if (g == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (g == FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
            var b = new FR.Chart.BubbleDisappear(this.centerX, this.centerY, this.radius);
            b.colorInfo = this.colorInfo;
            return b.getAnimateGlyph(f)
        }
        var h = [];
        for (var d = 0; d < f; d++) {
            if (e == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL || (e == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && g == FR.Chart.ChartPaintConstants.STATE_ENABLE)) {
                if (c) {
                    var a = new FR.Chart.Bubble(FR.Chart.ChartEase.easeOutQuint(d + 1, c.centerX, this.centerX - c.centerX, f), FR.Chart.ChartEase.easeOutQuint(d + 1, c.centerY, this.centerY - c.centerY, f), this.radius);
                    h[d] = a;
                    a.colorInfo = this.colorInfo
                } else {
                    var a = new FR.Chart.Bubble(this.centerX, this.centerY, FR.Chart.ChartEase.easeOutBounce(d + 1, 0, this.radius, f));
                    h[d] = a;
                    a.colorInfo = this.colorInfo
                }
            } else {
                if ((e == FR.Chart.ChartPaintConstants.ACTION_MODEL_DEFAULT && g == FR.Chart.ChartPaintConstants.STATE_ENABLE) || g == FR.Chart.ChartPaintConstants.STATE_APPEAR) {
                    var a = new FR.Chart.Bubble(this.centerX, this.centerY, FR.Chart.ChartEase.easeOutBounce(d + 1, 0, this.radius, f));
                    h[d] = a;
                    a.colorInfo = this.colorInfo
                }
            }
        }
        return h
    }, containsPoint: function (a, c) {
        var b = new FR.Chart.Arc2D(this.centerX, this.centerY, this.radius, 0, 360, FR.Chart.Arc2D.PIE);
        return b.containsPoint(a, c)
    }
});
FR.Chart.BubbleDisappear = FR.extend(FR.Chart.Bubble, {
    constructor: function (b, c, a) {
        FR.Chart.BubbleDisappear.superclass.constructor.apply(this, [b, c, a])
    }, draw: function (b) {
        if (this.actionStep > this.step / 2 || (this.step < 2)) {
            return
        }
        this.step /= 2;
        if (!b) {
            return
        }
        b.save();
        var a = new FR.Chart.Bubble();
        a.colorInfo = this.colorInfo;
        a.radius = this.radius / 9;
        a.centerX = this.centerX - this.radius * 0.75;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX - this.radius - a.centerX, this.step);
        a.centerY = this.centerY - this.radius * 0.75;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 9;
        a.centerX = this.centerX - this.radius * 0.25;
        a.centerY = this.centerY;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY + this.radius - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 5;
        a.centerX = this.centerX - this.radius * 0.5;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX - this.radius * 1.25 - a.centerX, this.step);
        a.centerY = this.centerY + this.radius * 0.5;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY + this.radius - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 8;
        a.centerX = this.centerX - this.radius * 0.25;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX - this.radius * 1.25 - a.centerX, this.step);
        a.centerY = this.centerY + this.radius * 0.4;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY + this.radius * 1.25 - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 8;
        a.centerX = this.centerX + this.radius * 0.25;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX + this.radius * 0.2 - a.centerX, this.step);
        a.centerY = this.centerY - this.radius;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY - this.radius * 1.25 - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 7;
        a.centerX = this.centerX + this.radius * 0.5;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX + this.radius * 0.75 - a.centerX, this.step);
        a.centerY = this.centerY - this.radius * 0.5;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 7;
        a.centerX = this.centerX + this.radius;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX + this.radius * 1.3 - a.centerX, this.step);
        a.centerY = this.centerY - this.radius * 0.25;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY - a.centerY, this.step);
        a.draw(b);
        a.radius = this.radius / 7;
        a.centerX = this.centerX + this.radius;
        a.centerX = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerX, this.centerX + this.radius * 1.5 - a.centerX, this.step);
        a.centerY = this.centerY + this.radius * 0.25;
        a.centerY = FR.Chart.ChartEase.easeOutCirc(this.actionStep, a.centerY, this.centerY + this.radius * 0.75 - a.centerY, this.step);
        a.draw(b);
        b.restore()
    }, getAnimateGlyph: function (a) {
        var d = [];
        for (var c = 0; c < a; c++) {
            var b = new FR.Chart.BubbleDisappear(this.centerX, this.centerY, this.radius);
            b.colorInfo = this.colorInfo;
            b.step = a;
            b.actionStep = c;
            d[c] = b
        }
        return d
    }
});
FR.Chart.Meter = function (a, c, b) {
    this.titleGlyph = a;
    this.value = c;
    this.meterStyle = b;
    this.shapeType = "meter"
};
$.extend(FR.Chart.Meter.prototype, {
    value: 0,
    titleGlyph: null,
    meterStyle: null,
    bounds: null,
    meterMiddleX: 0,
    meterMiddleY: 0,
    radius: 0,
    startAngle: 0,
    extentAngle: 0,
    arcWidth: 0,
    arrowColor: null,
    getBounds: function () {
        return this.bounds
    },
    draw: function (a) {
        this._initTransientValue();
        if (this.radius <= 0) {
            return
        }
        this._drawArrow(a)
    },
    drawMeterBottom: function (a, d) {
        if (d) {
            this.resetBeforeDraw()
        }
        this._initTransientValue();
        if (this.radius <= 0) {
            return
        }
        for (var b = 0, c = this.meterStyle.intervals.length;
             b < c; b++) {
            this._drawArcForInterval(a, this.meterStyle.getInterval(b))
        }
        this._drawMeterTicks(a);
        this._drawDisplay(a);
        if (this.titleGlyph && this.meterStyle.isShowTitle) {
            this.titleGlyph.bounds = new FR.Chart.Bounds(this.meterMiddleX - this.titleDim.width / 2, this.meterMiddleY - this.radius - this.titleDim.height - 12, this.titleDim.width, this.titleDim.height);
            this.titleGlyph.draw(a)
        }
    },
    resetBeforeDraw: function () {
        this.meterStyle.resetAutoDesignIntervals(this.value);
        this.meterStyle.tickSize = this._getTickSize();
        this.resetAutoMax()
    },
    resetAutoMax: function () {
        if (this.meterStyle.designType === 0) {
            if (this.value < 0) {
                var c = this.meterStyle.tickSize * Math.pow(10, this.meterStyle.order);
                var a = -c * 9;
                this.meterStyle.startValue = a;
                this.meterStyle.endValue = 0;
                var b = this.meterStyle.getInterval(0);
                b.resetInterval(a, a + c * 3, "rgb(231, 71, 62)");
                b = this.meterStyle.getInterval(1);
                b.resetInterval(a + c * 3, a + c * 6, "rgb(252, 210, 9)");
                b = this.meterStyle.getInterval(2);
                b.resetInterval(a + c * 6, 0, "rgb(77, 184, 73)")
            } else {
                this.meterStyle.startValue = 0;
                this.meterStyle.endValue = this.meterStyle.startValue + this.meterStyle.tickSize * 9 * Math.pow(10, this.meterStyle.order);
                var b = this.meterStyle.getInterval(0);
                b.resetInterval(this.meterStyle.startValue, this.meterStyle.endValue / 3, "rgb(231, 71, 62)");
                b = this.meterStyle.getInterval(1);
                b.resetInterval(this.meterStyle.endValue / 3, this.meterStyle.endValue * 2 / 3, "rgb(252, 210, 9)");
                b = this.meterStyle.getInterval(2);
                b.resetInterval(this.meterStyle.endValue * 2 / 3, this.meterStyle.endValue, "rgb(77, 184, 73)")
            }
        }
    },
    getCurrentValueDim: function () {
        var a = this.dealWithDoubleValue((this.value / Math.pow(10, this.meterStyle.order)));
        return FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, this.meterStyle.valueTextAttr)
    },
    getColor4CurrentValue: function () {
        for (var c = 0, a = this.meterStyle.intervals.length; c < a; c++) {
            var b = this.meterStyle.getInterval(c);
            if (b.beginValue <= this.value && b.endValue > this.value) {
                return FR.Chart.Color.rgb2Hex(b.backgroundColor).hex
            }
        }
        return "rgb(0,0,0)"
    },
    dealWithDoubleValue: function (a) {
        return parseFloat(FR.Chart.ChartUtils.accNumber(a))
    },
    getMaxTickLableDim: function () {
        var i = new FR.Chart.TextAttr();
        var c = new FR.Chart.FRFont();
        c.size = 9;
        c.fontName = "CenturyGothic";
        i.frFont = c;
        var d = Math.pow(10, this.meterStyle.order);
        var a = this.dealWithDoubleValue(this.meterStyle.startValue / d);
        var f = this.dealWithDoubleValue(this.meterStyle.endValue / d);
        var g = this.dealWithDoubleValue(this.meterStyle.tickSize);
        var j = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation("", i);
        for (var e = a; e <= f; e += g) {
            var b = this.dealWithDoubleValue(e);
            if (this.meterStyle.unitFormat) {
                b = FR.contentFormat(e, this.meterStyle.unitFormat)
            } else {
                b = FR.Chart.ChartUtils.accNumber(b);
                b = FR.contentFormat(e, "#.##")
            }
            var h = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(b, i);
            if (h.width > j.width) {
                j = h
            }
        }
        return j
    },
    _getTickSize: function () {
        var c = 0.09;
        var a = Math.pow(10, this.meterStyle.order);
        var d = this.meterStyle.endValue / a;
        var b = this.meterStyle.startValue / a;
        var e = d - b;
        while (e > 1) {
            e /= 10;
            c *= 10
        }
        e = c;
        while (e < d - b) {
            e += c
        }
        return e / 9
    },
    _adjustRadius: function (d, b) {
        var e = this.meterStyle.meterAngle;
        var c = this.getCurrentValueDim().height + this.radius * 0.18;
        if (this.meterMiddleY + c > this.bounds.y + this.bounds.height) {
            b = b - (this.meterMiddleY + c - this.bounds.y - this.bounds.height)
        }
        if (e === 360) {
            this.radius = Math.min(d, b) / 2
        } else {
            if (e > 180) {
                this.radius = Math.min(b / (1 + Math.sin((this.meterStyle.meterAngle - 180) / 2 * Math.PI / 180)), d / 2)
            } else {
                this.radius = Math.min(b, d / 2)
            }
        }
        this.meterMiddleY = this.bounds.y + this.titleDim.height + this.radius;
        var a = this.bounds.y + this.bounds.height / 2;
        this.meterMiddleY = Math.max(a, this.meterMiddleY)
    },
    _initTransientValue: function () {
        this.titleDim = new FR.Chart.Dimension2D();
        if (this.titleGlyph != null && this.meterStyle.isShowTitle) {
            var d = this.titleGlyph.text;
            this.titleDim = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(d, this.meterStyle.titleTextAttr)
        }
        this.meterStyle.maxArrowAngle = Math.min(this.meterStyle.maxArrowAngle, this.meterStyle.meterAngle);
        var e = (2 * FR.Chart.MeterStyle.DEFAULT_BORDER_SIZE);
        var b = (2 * FR.Chart.MeterStyle.DEFAULT_BORDER_SIZE);
        var c = this.bounds.width - 8 - e;
        var a = this.bounds.height - 8 - b - this.titleDim.height;
        this.meterMiddleX = this.bounds.width / 2 + this.bounds.x;
        this._calculateMiddleYAndRadius(c, a);
        this.arcWidth = 0.24 * this.radius
    },
    _calculateMiddleYAndRadius: function (b, a) {
        if (this.meterStyle.dialShape == FR.Chart.MeterStyle.CIRCLE) {
            this.radius = Math.min(b, a) / 2
        } else {
            if (this.meterStyle.meterAngle > 180) {
                this.radius = Math.min(a / (1 + Math.sin((this.meterStyle.meterAngle - 180) / 2 * Math.PI / 180)), b / 2)
            } else {
                this.radius = Math.min(a, b / 2)
            }
        }
        this.meterMiddleY = this.bounds.y + this.titleDim.height + this.radius;
        this._adjustRadius(b, a)
    },
    _drawArrow: function (o) {
        if (!o) {
            return
        }
        o.save();
        if (!this.arrowColor) {
            return
        }
        o.fillStyle = this.arrowColor;
        this.value = FR.Chart.ChartUtils.accNumber(this.value);
        if ((this.value >= this.meterStyle.startValue && this.value <= this.meterStyle.endValue)) {
            var e = 0.74;
            var i = 0.06;
            var j = 0.04;
            var g = this._valueToAngle(this.value, this.meterStyle.maxArrowAngle);
            var f = this.meterMiddleX + ((e * this.radius) * Math.cos(Math.PI * g / 180));
            var d = this.meterMiddleY - ((e * this.radius) * Math.sin(Math.PI * g / 180));
            var n = this.meterMiddleX + this.radius * i * Math.cos(Math.PI * (g - 90) / 180);
            var l = this.meterMiddleY - this.radius * i * Math.sin(Math.PI * (g - 90) / 180);
            var c = this.meterMiddleX + this.radius * i * Math.cos(Math.PI * (g + 90) / 180);
            var b = this.meterMiddleY - this.radius * i * Math.sin(Math.PI * (g + 90) / 180);
            var a = new FR.Chart.GeneralPath();
            a.moveTo(f, d);
            a.lineTo(n, l);
            a.lineTo(c, b);
            a.closePath();
            a.paint(o);
            var h = this.radius * i;
            var m = new FR.Chart.Arc2D(this.meterMiddleX, this.meterMiddleY, h, 0, 360, FR.Chart.Arc2D.PIE);
            m.paint(o);
            o.fillStyle = "white";
            var k = this.radius * j;
            var p = new FR.Chart.Arc2D(this.meterMiddleX, this.meterMiddleY, k, 0, 360, FR.Chart.Arc2D.PIE);
            p.paint(o)
        }
        o.restore()
    },
    getShape: function () {
        return this.getBounds()
    },
    _valueToAngle: function (c, a) {
        c = c - this.meterStyle.startValue;
        var b = (a / 2 + 90);
        return (b - (c / (this.meterStyle.endValue - this.meterStyle.startValue)) * a)
    },
    _getFont: function (d, c) {
        var a = new FR.Chart.FRFont();
        a.size = 8;
        var b = new FR.Chart.TextAttr();
        b.frFont = a;
        var e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, b);
        while (e.width < d.width && e.height < d.height) {
            a.size += 1;
            b.frFont = a;
            e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, b);
            if (a.size > 20) {
                return a
            }
        }
        return a
    },
    _getTextBounds: function (c, a) {
        if (c == null) {
            return
        }
        var b = FR.Chart.GraphHelper.stringDimension(c, a, 0);
        return new FR.Chart.Bounds(0, 0, b.width, b.height)
    },
    _drawArcForInterval: function (b, c) {
        if (!c.backgroundColor) {
            return
        }
        if (!b) {
            return
        }
        b.save();
        b.strokeStyle = c.backgroundColor;
        var e = c.beginValue < this.meterStyle.startValue ? this.meterStyle.startValue : c.beginValue;
        var a = c.endValue > this.meterStyle.endValue ? this.meterStyle.endValue : c.endValue;
        if (e > a) {
            return
        }
        var g = this._valueToAngle(e, this.meterStyle.maxArrowAngle);
        var h = this._valueToAngle(a, this.meterStyle.maxArrowAngle);
        b.lineWidth = 3;
        var f = this.radius - this.arcWidth;
        for (var d = f; d < this.radius; d++) {
            b.beginPath();
            b.arc(this.meterMiddleX, this.meterMiddleY, d, (360 - g) * Math.PI / 180, (360 - h) * Math.PI / 180, false);
            b.stroke()
        }
        b.restore()
    },
    _drawMeterTicks: function (c) {
        var b = Math.pow(10, this.meterStyle.order);
        var e = this.meterStyle.startValue / b;
        var a = this.meterStyle.endValue / b;
        if (this.meterStyle.tickSize > 0) {
            if (e > a) {
                return
            }
            if (!c) {
                return
            }
            c.save();
            c.strokeStyle = this.meterStyle.tickColor;
            c.fillStyle = this.meterStyle.tickColor;
            var h = new FR.Chart.BoundsManager();
            for (var d = e, f = 0; d <= a; d += this.meterStyle.tickSize, f++) {
                if (d != e && d != a) {
                    this._drawMeterTickLine(c, d * b, false, true)
                }
                if (!(this.meterStyle.maxArrowAngle === 360 && d == a)) {
                    this._drawMeterTickLabel(c, d, h)
                }
            }
            for (var g = e; g <= a; g += this.meterStyle.tickSize / 5) {
                if ((g - e) % this.meterStyle.tickSize === 0) {
                    continue
                }
                this._drawMeterTickLine(c, g * b, false, false)
            }
            c.restore()
        }
    },
    _drawMeterTickLine: function (k, f, j, h) {
        if (!k) {
            return
        }
        k.save();
        var d = this._valueToAngle(f, this.meterStyle.maxArrowAngle);
        var a = this.radius * 0.96;
        var b = this.radius * 0.18;
        if (!h && !j) {
            b = this.radius * 0.1
        }
        var e = this.meterMiddleX + a * Math.cos(Math.PI * (d / 180));
        var c = this.meterMiddleY - a * Math.sin(Math.PI * (d / 180));
        var i = this.meterMiddleX + (a - b) * Math.cos(Math.PI * (d / 180));
        var g = this.meterMiddleY - (a - b) * Math.sin(Math.PI * (d / 180));
        var l = new FR.Chart.Line2D(new FR.Chart.Point2D(i, g), new FR.Chart.Point2D(e, c));
        k.lineWidth = this.radius > 100 ? 1.4 : 1;
        k.strokeStyle = "white";
        k.lineCap = "round";
        l.draw(k);
        k.restore()
    },
    _drawMeterTickLabel: function (l, j, k) {
        if (!l) {
            return
        }
        l.save();
        l.textBaseline = "top";
        if (this.meterStyle.tickLabelsVisible) {
            var c = Math.pow(10, this.meterStyle.order);
            var e = this._valueToAngle(j * c, this.meterStyle.maxArrowAngle);
            var d;
            if (this.meterStyle.unitFormat) {
                d = FR.contentFormat(j, this.meterStyle.unitFormat)
            } else {
                j = FR.Chart.ChartUtils.accNumber(j);
                d = FR.contentFormat(j, "#.##")
            }
            l.strokeStyle = "rgb(51, 51, 51)";
            l.fillStyle = "rgb(51, 51, 51)";
            var m = 9;
            l.font = " " + m + "px Verdana";
            var f = new FR.Chart.TextAttr();
            f.frFont = new FR.Chart.FRFont();
            f.frFont.color = "rgb(51, 51, 51)";
            f.frFont.size = m;
            f.frFont.fontName = "Verdana";
            var h = this._getTextBounds(d, f.frFont);
            var a = this.radius * 0.72;
            var i = this.meterMiddleX + a * Math.cos(Math.PI * (e / 180));
            var g = this.meterMiddleY - a * Math.sin(Math.PI * (e / 180));
            if (e < 90 || e > 270) {
                i -= h.width
            }
            var f = new FR.Chart.TextAttr();
            f.frFont = new FR.Chart.FRFont();
            f.frFont.color = "rgb(51, 51, 51)";
            f.frFont.size = m;
            f.frFont.fontName = "Verdana";
            var b = new FR.Chart.Bounds(i, g, h.width, h.height);
            if (!k.isInteract(b)) {
                k.addBounds(b);
                FR.Chart.TextUtils.drawLabelWithNoRotation(l, d, f, b, FR.Chart.currentDivKey)
            }
        }
        l.restore()
    },
    _drawDisplay: function (k) {
        if (!k) {
            return
        }
        k.save();
        var c = Math.pow(10, this.meterStyle.order);
        var i = this.dealWithDoubleValue(this.value / c);
        var d = this.getCurrentValueDim();
        var e = d.width;
        var b = this.meterMiddleX - e / 2;
        var a = this.meterMiddleY + 0.06 * this.radius;
        if (this.meterStyle.valueTextAttr && this.meterStyle.valueTextAttr.frFont) {
            this.meterStyle.valueTextAttr.frFont.color = this.getColor4CurrentValue()
        }
        var j = new FR.Chart.Bounds(b, a, d.width, d.height);
        FR.Chart.TextUtils.drawLabelWithNoRotation(k, i, this.meterStyle.valueTextAttr, j, FR.Chart.currentDivKey);
        var f = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(this.meterStyle.units, this.meterStyle.unitTextAttr);
        var h = this.meterMiddleX - f.width / 2;
        var g = this.meterMiddleY - 0.22 * this.radius - f.height;
        j = new FR.Chart.Bounds(h, g, f.width, f.height);
        FR.Chart.TextUtils.drawLabelWithNoRotation(k, this.meterStyle.units, this.meterStyle.unitTextAttr, j, FR.Chart.currentDivKey)
    },
    getAnimateGlyph: function (b, l, g) {
        var e = this.meterStyle.getInterval(this.meterStyle.intervals.length - 1).endValue;
        if (this.value < this.meterStyle.getInterval(0).beginValue || this.value > e) {
            return null
        }
        var h = [];
        var f = this.getColor4CurrentValue();
        for (var d = 0; d < b; d++) {
            if (l == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                h[d] = this;
                h[d].arrowColor = f
            } else {
                var c;
                var a = FR.Chart.ChartEase.easeOutQuint(d + 1, 0, this.value, b);
                if (g) {
                    var k = g.value;
                    a = FR.Chart.ChartEase.easeOutQuint(d + 1, k, this.value - k, b)
                }
                if (this.value < 0 && g) {
                    var j = this.meterStyle.getInterval(0).beginValue;
                    a = FR.Chart.ChartEase.easeOutQuint(d + 1, j - k, j - this.value, b);
                    a = j - a
                }
                if (this.value < 0 && !g) {
                    var j = this.meterStyle.getInterval(0).beginValue;
                    a = FR.Chart.ChartEase.easeInBack(d + 1, 0, j - this.value, b);
                    a = j - a
                }
                c = new FR.Chart.Meter(this.titleGlyph, a, this.meterStyle);
                c.bounds = this.bounds;
                c.arrowColor = f;
                h[d] = c
            }
        }
        return h
    }
});
FR.Chart.SimpleMeter = FR.extend(FR.Chart.Meter, {
    constructor: function (a, c, b) {
        this.initAll();
        FR.Chart.Meter.superclass.constructor.apply(this, [a, c, b])
    }, _calculateMeterShape: function () {
        this.innerRadius = this.radius * 0.88
    }, draw: function (a) {
        this._initTransientValue();
        this._calculateMeterShape();
        this.drawLight(a)
    }, drawLight: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.alpha = 1;
        a.strokeStyle = this.valueColor;
        a.lineWidth = this.innerRadius * 0.1364;
        a.lineCap = "round";
        var b = Math.min(this.value, this.meterStyle.endValue);
        b = Math.max(b, this.meterStyle.startValue);
        this.meterExtend = (b - this.meterStyle.startValue) * 300 / (this.meterStyle.endValue - this.meterStyle.startValue);
        a.beginPath();
        a.arc(this.meterMiddleX, this.meterMiddleY, this.innerRadius, 120 * Math.PI / 180, (120 + this.meterExtend) * Math.PI / 180, false);
        a.stroke();
        a.restore
    }, initAll: function () {
        this.tickColor = "rgb(51,51,51)"
    }, drawMeterBottom: function (a, b) {
        if (!a) {
            return
        }
        if (b) {
            this.resetBeforeDraw()
        }
        this._initTransientValue();
        this._calculateMeterShape();
        this._calculateLightColor();
        this.arcWidth = this.radius * 0.12;
        a.alpha = 0.5;
        a.strokeStyle = "rgb(214,214,214)";
        a.lineWidth = this.arcWidth;
        a.lineCap = "round";
        a.beginPath();
        a.arc(this.meterMiddleX, this.meterMiddleY, this.innerRadius, 120 * Math.PI / 180, 60 * Math.PI / 180, false);
        a.stroke();
        this._drawStrings(a);
        if (this.titleGlyph && this.meterStyle.isShowTitle) {
            this.titleGlyph.bounds = new FR.Chart.Bounds(this.meterMiddleX - this.titleDim.width / 2, this.meterMiddleY - this.radius - this.titleDim.height - 12, this.titleDim.width, this.titleDim.height);
            this.titleGlyph.draw(a)
        }
    }, _drawStrings: function (l, i) {
        l.strokeStyle = "";
        l.lineWidth = 1;
        var f = "30px Gentury Gothic";
        var c = "12px Microsoft YaHei";
        var k = "9px Gentury Gothic";
        var q = Math.pow(10, this.meterStyle.order);
        var d = this.dealWithDoubleValue(this.value / q) + "";
        var p = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(d, this.meterStyle.valueTextAttr);
        var t = this.meterMiddleX - p.width / 2;
        var s = this.meterMiddleY - p.height / 2;
        var j = new FR.Chart.Bounds(t, s, p.width, p.height);
        this.meterStyle.valueTextAttr.frFont.color = this.valueColor;
        FR.Chart.TextUtils.drawLabelWithNoRotation(l, d, this.meterStyle.valueTextAttr, j, i);
        var m = this.meterStyle.units;
        var b = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(m, this.meterStyle.unitTextAttr);
        var t = this.meterMiddleX - b.width / 2;
        var s = s - this.radius * 0.05 - b.height;
        var u = new FR.Chart.Bounds(t, s, b.width, b.height);
        FR.Chart.TextUtils.drawLabelWithNoRotation(l, m, this.meterStyle.unitTextAttr, u, i);
        l.fon = k;
        l.fillStyle = this.tickColor;
        var o = this.meterMiddleX + this.innerRadius * Math.cos(120 * Math.PI / 180);
        var n = this.meterMiddleY + this.innerRadius * Math.sin(120 * Math.PI / 180) - this.radius * 0.1;
        var h = this.meterMiddleX + this.innerRadius * Math.cos(60 * Math.PI / 180);
        var g = this.meterMiddleY + this.innerRadius * Math.sin(60 * Math.PI / 180) - this.radius * 0.1;
        var q = Math.pow(10, this.meterStyle.order);
        var a = this.dealWithDoubleValue(this.meterStyle.startValue / q);
        l.fillText(a, o, n);
        var e = this.dealWithDoubleValue(this.meterStyle.endValue / q);
        var r = l.measureText(e);
        l.fillText(e, h - r.width, g)
    }, _calculateLightColor: function () {
        for (var b = 0, c = this.meterStyle.intervals.length; b < c; b++) {
            var d = this._dealBegin(b);
            var a = this._dealEnd(b);
            if (d <= this.value && a >= this.value) {
                this.valueColor = this.meterStyle.getInterval(b).backgroundColor;
                break
            }
        }
        if (this.value < this.meterStyle.startValue) {
            this.valueColor = this.meterStyle.getInterval(0).backgroundColor
        }
        if (this.value > this.meterStyle.endValue) {
            this.valueColor = this.meterStyle.getInterval(this.meterStyle.intervals.length - 1).backgroundColor
        }
    }, _dealBegin: function (b) {
        var a = this.meterStyle.getInterval(b);
        return a.beginValue < this.meterStyle.startValue ? this.meterStyle.startValue : a.beginValue
    }, _dealEnd: function (b) {
        var a = this.meterStyle.getInterval(b);
        return a.endValue > this.meterStyle.endValue ? this.meterStyle.endValue : a.endValue
    }, _calculateMiddleYAndRadius: function (b, a) {
        this.radius = Math.min(b / 2, a / 1.886);
        this.meterMiddleY = this.bounds.y + 8 + FR.Chart.MeterStyle.DEFAULT_BORDER_SIZE + this.titleDim.height;
        if (b / 2 > a / 1.886) {
            this.meterMiddleY += this.radius
        } else {
            this.meterMiddleY += a / 2
        }
    }, getAnimateGlyph: function (f, d, a) {
        var e = [];
        for (var c = 0; c < f; c++) {
            if (d == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                e[c] = this
            } else {
                var g;
                var h = FR.Chart.ChartEase.easeOutQuint(c + 1, 0, this.value, f);
                if (a) {
                    var b = a.value;
                    h = FR.Chart.ChartEase.easeOutQuint(c + 1, b, this.value - b, f)
                }
                g = new FR.Chart.SimpleMeter(this.titleGlyph, h, this.meterStyle);
                g.bounds = this.bounds;
                g.valueColor = this.valueColor;
                e[c] = g
            }
        }
        return e
    }
});
FR.Chart.BlueMeter = FR.extend(FR.Chart.Meter, {
    draw: function (a) {
        this._initTransientValue();
        this._drawArrow(a)
    }, drawMeterBottom: function (a, d) {
        if (!a) {
            return
        }
        if (d) {
            this.resetBeforeDraw()
        }
        this._initTransientValue();
        this.drawBackground(a);
        for (var b = 0, c = this.meterStyle.intervals.length; b < c; b++) {
            this._drawArcForInterval(a, this.meterStyle.getInterval(b), b)
        }
        this._drawMeterTicks(a);
        this.drawDisplay(a);
        if (this.titleGlyph && this.meterStyle.isShowTitle) {
            this.titleGlyph.bounds = new FR.Chart.Bounds(this.meterMiddleX - this.titleDim.width / 2, this.meterMiddleY - this.radius - this.titleDim.height - 12, this.titleDim.width, this.titleDim.height);
            this.titleGlyph.draw(a)
        }
    }, _initTransientValue: function () {
        this.meterStyle.maxArrowAngle = 300;
        FR.Chart.BlueMeter.superclass._initTransientValue.apply(this, [])
    }, drawBackground: function (b) {
        if (!b) {
            return
        }
        b.save();
        var a = b.createLinearGradient(this.meterMiddleX - this.radius, this.meterMiddleY - this.radius, this.meterMiddleX + this.radius, this.meterMiddleY + this.radius);
        a.addColorStop(0, "rgb(234,231,227)");
        a.addColorStop(0.2, "rgb(154,149,154)");
        a.addColorStop(0.5, "rgb(255,255,255)");
        a.addColorStop(0.8, "rgb(142,136,139)");
        a.addColorStop(1, "rgb(181,181,182)");
        b.fillStyle = a;
        b.shadowBlur = 5;
        b.shadowOffsetX = 2;
        b.shadowOffsetY = 4;
        b.shadowColor = "rgba(0,0,0,0.3)";
        var d = new FR.Chart.Arc2D(this.meterMiddleX, this.meterMiddleY, this.radius, 0, 360, false);
        d.paint(b);
        var e = this.radius * 0.9;
        var c = b.createRadialGradient(this.meterMiddleX, this.meterMiddleY, 0, this.meterMiddleX, this.meterMiddleY, e);
        c.addColorStop(0, "rgb(20, 134, 255)");
        c.addColorStop(0.7, "rgb(0, 59, 128)");
        c.addColorStop(1, "rgb(0, 35, 64)");
        b.fillStyle = c;
        var f = new FR.Chart.Arc2D(this.meterMiddleX, this.meterMiddleY, e, 0, 360, false);
        f.paint(b);
        b.restore()
    }, _drawArcForInterval: function (l, d, h) {
        if (!l) {
            return
        }
        l.save();
        l.strokeStyle = d.backgroundColor;
        var e = d.beginValue < this.meterStyle.startValue ? this.meterStyle.startValue : d.beginValue;
        var g = d.endValue > this.meterStyle.endValue ? this.meterStyle.endValue : d.endValue;
        if (e > g) {
            return
        }
        var f = this._valueToAngle(e, this.meterStyle.maxArrowAngle);
        var a = this._valueToAngle(g, this.meterStyle.maxArrowAngle);
        var i = this.radius * 0.07;
        var j = this.radius * 0.85 - i * 0.5;
        l.lineWidth = i;
        if (h === 0) {
            l.lineCap = "round"
        } else {
            l.lineCap = "square"
        }
        var b = (360 - f) * Math.PI / 180;
        var c = (360 - a) * Math.PI / 180;
        var k = (b + c) / 2;
        l.beginPath();
        l.arc(this.meterMiddleX, this.meterMiddleY, j, b, k, false);
        l.stroke();
        if (h === this.meterStyle.intervals.length - 1) {
            l.lineCap = "round"
        } else {
            l.lineCap = "square"
        }
        l.beginPath();
        l.arc(this.meterMiddleX, this.meterMiddleY, j, k, c, false);
        l.stroke();
        l.restore()
    }, _drawMeterTickLine: function (k, f, j, h) {
        if (!k) {
            return
        }
        k.save();
        var d = this._valueToAngle(f, this.meterStyle.maxArrowAngle);
        var a = this.radius * 0.75;
        var b = this.radius * 0.12;
        if (!h && !j) {
            b = this.radius * 0.08
        }
        var e = this.meterMiddleX + a * Math.cos(Math.PI * (d / 180));
        var c = this.meterMiddleY - a * Math.sin(Math.PI * (d / 180));
        var i = this.meterMiddleX + (a - b) * Math.cos(Math.PI * (d / 180));
        var g = this.meterMiddleY - (a - b) * Math.sin(Math.PI * (d / 180));
        var l = new FR.Chart.Line2D(new FR.Chart.Point2D(i, g), new FR.Chart.Point2D(e, c));
        k.lineWidth = 2;
        k.lineCap = "round";
        k.strokeStyle = "white";
        l.draw(k);
        k.restore()
    }, _drawMeterTickLabel: function (k, i, j) {
        if (!k) {
            return
        }
        k.save();
        if (this.meterStyle.tickLabelsVisible) {
            var b = Math.pow(10, this.meterStyle.order);
            var e = this._valueToAngle(i * b, this.meterStyle.maxArrowAngle);
            var c;
            if (this.meterStyle.unitFormat) {
                c = FR.contentFormat(i, this.meterStyle.unitFormat)
            } else {
                i = FR.Chart.ChartUtils.accNumber(i);
                c = FR.contentFormat(i, "#.##")
            }
            k.fillStyle = "white";
            var l = 9;
            k.font = " " + l + "px CenturyGothic";
            var d = new FR.Chart.TextAttr();
            d.frFont = new FR.Chart.FRFont();
            d.frFont.color = "white";
            d.frFont.size = 9;
            d.frFont.fontName = "CenturyGothic";
            var g = this._getTextBounds(c, d.frFont);
            var h = this.meterMiddleX + this.radius * Math.cos(Math.PI * (e / 180)) * 0.5 - g.width * 0.5;
            var f = this.meterMiddleY - this.radius * Math.sin(Math.PI * (e / 180)) * 0.5 - g.height * 0.5;
            var a = new FR.Chart.Bounds(h, f, g.width, g.height);
            if (!j.isInteract(a)) {
                j.addBounds(a);
                k.notUseDivText = true;
                FR.Chart.TextUtils.drawLabelWithNoRotation(k, c, d, a, FR.Chart.currentDivKey);
                k.notUseDivText = false
            }
        }
        k.restore()
    }, drawDisplay: function (m) {
        var c = "" + this.dealWithDoubleValue(this.value / Math.pow(10, this.meterStyle.order));
        var b = this.meterStyle.valueTextAttr;
        b.frFont.color = "white";
        var e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, b);
        var i = this.meterMiddleX - e.width / 2;
        var h = this.meterMiddleY;
        var a = new FR.Chart.Bounds(i, h, e.width, e.height);
        FR.Chart.TextUtils.drawLabelWithNoRotation(m, c, b, a, FR.Chart.currentDivKey);
        var f = this.meterStyle.unitTextAttr;
        f.frFont.color = "white";
        var g = this.meterStyle.units;
        var d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(g, f);
        var k = (this.meterMiddleX - d.width / 2);
        var j = (this.meterMiddleY - d.height);
        var l = new FR.Chart.Bounds(k, j, d.width, d.height);
        FR.Chart.TextUtils.drawLabelWithNoRotation(m, g, f, l, FR.Chart.currentDivKey)
    }, _drawArrow: function (i) {
        if (this.value >= this.meterStyle.startValue && this.value <= this.meterStyle.endValue) {
            if (!i) {
                return
            }
            i.save();
            i.fillStyle = "white";
            i.globalAlpha = 0.25;
            var d = this.radius * 0.44;
            var h = new FR.Chart.Arc2D(this.meterMiddleX, this.meterMiddleY, d, 0, 360, false);
            h.paint(i);
            i.globalAlpha = 1;
            var c = new FR.Chart.GeneralPath();
            var e = new FR.Chart.GeneralPath();
            var a = this.getPointerPath(c, e);
            i.fillStyle = "rgb(242, 150, 0)";
            c.paint(i);
            i.fillStyle = "rgb(216, 110, 30)";
            e.paint(i);
            i.fillStyle = "black";
            i.globalAlpha = 0.5;
            a.draw(i);
            var g = this.radius * 0.36;
            var b = new FR.Chart.Arc2D(this.meterMiddleX, this.meterMiddleY, g, 0, 360, false);
            i.fillStyle = "white";
            i.globalAlpha = 1;
            b.paint(i);
            var f = i.createRadialGradient(this.meterMiddleX, this.meterMiddleY, 0, this.meterMiddleX, this.meterMiddleY, g);
            f.addColorStop(0, "rgb(20,134,255)");
            f.addColorStop(1, "rgb(0, 90, 238)");
            i.fillStyle = f;
            b.paint(i);
            i.strokeStyle = "rgb(16, 68, 160)";
            i.lineWidth = 2;
            b.draw(i);
            i.restore()
        }
    }, getPointerPath: function (c, k) {
        var m = 0.12;
        var n = 0.72;
        var o = 180;
        var e = -90 / 180 * Math.PI;
        var b = this.value;
        var i = this._valueToAngle(b, this.meterStyle.maxArrowAngle);
        var l = this.meterMiddleX + this.radius * m * Math.cos(Math.PI * (i / o) - e);
        var j = this.meterMiddleY - this.radius * m * Math.sin(Math.PI * (i / o) - e);
        var f = this.meterMiddleX + this.radius * m * Math.cos(Math.PI * (i / o) + e);
        var d = this.meterMiddleY - this.radius * m * Math.sin(Math.PI * (i / o) + e);
        var h = this.meterMiddleX + ((n * this.radius) * Math.cos(Math.PI * i / o));
        var g = this.meterMiddleY - ((n * this.radius) * Math.sin(Math.PI * i / o));
        c.moveTo(h, g);
        c.lineTo(l, j);
        c.lineTo((f + l) / 2, (d + j) / 2);
        c.closePath();
        k.moveTo(h, g);
        k.lineTo(f, d);
        k.lineTo((f + l) / 2, (d + j) / 2);
        k.closePath();
        var a = new FR.Chart.GeneralPath();
        a.moveTo(h, g);
        a.lineTo(l, j);
        a.lineTo(f, d);
        a.closePath();
        return a
    }, _calculateMiddleYAndRadius: function (b, a) {
        this.radius = Math.min(b, a) / 2;
        this.meterMiddleY = this.bounds.y + 8 + FR.Chart.MeterStyle.DEFAULT_BORDER_SIZE + this.titleDim.height;
        if (b > a) {
            this.meterMiddleY += this.radius
        } else {
            this.meterMiddleY += a / 2
        }
    }, getAnimateGlyph: function (b, j, f) {
        var e = this.meterStyle.getInterval(this.meterStyle.intervals.length - 1).endValue;
        if (this.value < this.meterStyle.getInterval(0).beginValue || this.value > e) {
            return null
        }
        var g = [];
        for (var d = 0; d < b; d++) {
            if (j == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                g[d] = this
            } else {
                var c;
                var a = FR.Chart.ChartEase.easeOutQuint(d + 1, 0, this.value, b);
                if (f) {
                    var h = f.value;
                    a = FR.Chart.ChartEase.easeOutQuint(d + 1, h, this.value - h, b)
                }
                c = new FR.Chart.BlueMeter(this.titleGlyph, a, this.meterStyle);
                c.bounds = this.bounds;
                g[d] = c
            }
        }
        return g
    }
});
FR.Chart.IconDemo = function (a, b) {
    this.bounds = a;
    this.state = FR.pick(b, FR.Chart.ChartIconState.STATE_NORMAL);
    this.normalStyle = "rgb(102,102,102)";
    this.selectedStyle = "rgb(41,158,255)";
    this.currentStyle = this.normalStyle
};
$.extend(FR.Chart.IconDemo.prototype, {
    bounds: new FR.Chart.Bounds(), state: FR.Chart.ChartIconState.STATE_NORMAL, draw: function (a) {
        if (this.state === FR.Chart.ChartIconState.STATE_SELECT || this.state === FR.Chart.ChartIconState.STATE_OVER) {
            this.currentStyle = this.selectedStyle
        } else {
            this.currentStyle = this.normalStyle
        }
        if (!a) {
            return
        }
        a.save();
        if (this.state === FR.Chart.ChartIconState.STATE_OVER) {
            a.globalAlpha = 0.6
        }
        this.paint(a);
        a.restore()
    }, paint: function (a) {
    }
});
FR.Chart.ColumnSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var c = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + 11, 6, 11);
        c.paint(a);
        var b = new FR.Chart.Bounds(this.bounds.x + 8, this.bounds.y, 6, 22);
        b.paint(a);
        var d = new FR.Chart.Bounds(this.bounds.x + 16, this.bounds.y + 5, 6, 17);
        d.paint(a)
    }
});
FR.Chart.LineSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (b) {
        b.strokeStyle = this.currentStyle;
        b.lineCap = "round";
        var a = new FR.Chart.GeneralPath();
        a.moveTo(this.bounds.x + 1, this.bounds.y + 15);
        a.lineTo(this.bounds.x + 7, this.bounds.y + 7);
        a.lineTo(this.bounds.x + 15, this.bounds.y + 14);
        a.lineTo(this.bounds.x + 21, this.bounds.y + 3);
        a.draw(b, 2)
    }
});
FR.Chart.BarSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var c = new FR.Chart.Bounds(this.bounds.x, this.bounds.y, 11, 6);
        c.paint(a);
        var b = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + 8, 22, 6);
        b.paint(a);
        var d = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + 16, 17, 6);
        d.paint(a)
    }
});
FR.Chart.PieSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.Arc2D(this.bounds.x + 11, this.bounds.y + 11, 10, 0, 90);
        b.paint(a);
        a.moveTo(this.bounds.x + 10, this.bounds.y + 1);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 264.26 * Math.PI / 180, 137.87 * Math.PI / 180, 1);
        a.lineTo(this.bounds.x + 10, this.bounds.y + 11);
        a.closePath();
        a.fill();
        a.moveTo(this.bounds.x + 21, this.bounds.y + 12);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 5.71 * Math.PI / 180, 132.22 * Math.PI / 180, 0);
        a.lineTo(this.bounds.x + 11, this.bounds.y + 12);
        a.closePath();
        a.fill()
    }
});
FR.Chart.AreaSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x, this.bounds.y + 12);
        b.lineTo(this.bounds.x + 3, this.bounds.y + 13);
        b.lineTo(this.bounds.x + 11, this.bounds.y + 8);
        b.lineTo(this.bounds.x + 16, this.bounds.y + 10);
        b.lineTo(this.bounds.x + 22, this.bounds.y + 2);
        b.lineTo(this.bounds.x + 22, this.bounds.y + 22);
        b.lineTo(this.bounds.x, this.bounds.y + 22);
        b.closePath();
        b.paint(a)
    }
});
FR.Chart.ScatterSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.Arc2D(this.bounds.x + 4, this.bounds.y + 3, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 10, this.bounds.y + 5, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 19, this.bounds.y + 4, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 3, this.bounds.y + 11, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 13, this.bounds.y + 10, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 18, this.bounds.y + 11, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 5, this.bounds.y + 19, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 9, this.bounds.y + 14, 2, 0, 360);
        b.paint(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 15, this.bounds.y + 5, 2, 0, 360);
        b.paint(a)
    }
});
FR.Chart.BubbleSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.strokeStyle = this.currentStyle;
        var b = new FR.Chart.Arc2D(this.bounds.x + 4, this.bounds.y + 4, 2, 0, 360);
        b.draw(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 13, this.bounds.y + 4, 1, 0, 360);
        b.draw(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 10, this.bounds.y + 12, 4, 0, 360);
        b.draw(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 18, this.bounds.y + 9, 1, 0, 360);
        b.draw(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 4, this.bounds.y + 18, 1, 0, 360);
        b.draw(a);
        b = new FR.Chart.Arc2D(this.bounds.x + 17, this.bounds.y + 17, 2, 0, 360);
        b.draw(a)
    }
});
FR.Chart.RadarSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        this.paintBackgroung(a);
        a.strokeStyle = this.currentStyle;
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 3, this.bounds.y + 9);
        b.lineTo(this.bounds.x + 11, this.bounds.y + 6);
        b.lineTo(this.bounds.x + 19, this.bounds.y + 9);
        b.lineTo(this.bounds.x + 16, this.bounds.y + 22);
        b.lineTo(this.bounds.x + 8, this.bounds.y + 16);
        b.closePath();
        b.draw(a, 1)
    }, paintBackgroung: function (a) {
        a.strokeStyle = "rgb(204,204,204)";
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y);
        b.lineTo(this.bounds.x + 22, this.bounds.y + 8);
        b.lineTo(this.bounds.x + 18, this.bounds.y + 22);
        b.lineTo(this.bounds.x + 4, this.bounds.y + 22);
        b.lineTo(this.bounds.x, this.bounds.y + 8);
        b.closePath();
        b.draw(a, 1);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y + 5);
        b.lineTo(this.bounds.x + 17, this.bounds.y + 10);
        b.lineTo(this.bounds.x + 15, this.bounds.y + 17);
        b.lineTo(this.bounds.x + 7, this.bounds.y + 17);
        b.lineTo(this.bounds.x + 5, this.bounds.y + 10);
        b.closePath();
        b.draw(a, 1);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y + 11);
        b.lineTo(this.bounds.x + 11, this.bounds.y);
        b.draw(a, 1);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y + 11);
        b.lineTo(this.bounds.x + 22, this.bounds.y + 8);
        b.draw(a, 1);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y + 11);
        b.lineTo(this.bounds.x + 18, this.bounds.y + 22);
        b.draw(a, 1);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y + 11);
        b.lineTo(this.bounds.x + 4, this.bounds.y + 22);
        b.draw(a, 1);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 11, this.bounds.y + 11);
        b.lineTo(this.bounds.x, this.bounds.y + 8);
        b.draw(a, 1)
    }
});
FR.Chart.StockSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.Bounds(this.bounds.x + 2, this.bounds.y + 4, 2, 14);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + 8, 6, 6);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 10, this.bounds.y, 2, 22);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 8, this.bounds.y + 4, 6, 14);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 18, this.bounds.y + 1, 2, 17);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 16, this.bounds.y + 5, 6, 9);
        b.paint(a)
    }
});
FR.Chart.MeterSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (b) {
        b.fillStyle = this.currentStyle;
        b.strokeStyle = this.currentStyle;
        b.lineWidth = 2;
        var c = new FR.Chart.Arc2D(this.bounds.x + 11, this.bounds.y + 11, 9, 0, 360);
        c.draw(b);
        var d = new FR.Chart.GeneralPath();
        d.moveTo(this.bounds.x + 11, this.bounds.y + 9);
        d.lineTo(this.bounds.x + 13, this.bounds.y + 10);
        d.lineTo(this.bounds.x + 15, this.bounds.y + 5);
        d.closePath();
        d.paint(b);
        c = new FR.Chart.Arc2D(this.bounds.x + 11, this.bounds.y + 11, 3, 0, 360);
        c.paint(b);
        b.lineWidth = 1;
        b.lineCap = "round";
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(this.bounds.x + 11, this.bounds.y + 2), new FR.Chart.Point2D(this.bounds.x + 11, this.bounds.y + 5));
        a.draw(b, FR.Chart.Constants.LINE_THIN);
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(this.bounds.x + 16, this.bounds.y + 8), new FR.Chart.Point2D(this.bounds.x + 18, this.bounds.y + 7));
        a.draw(b, FR.Chart.Constants.LINE_THIN);
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(this.bounds.x + 16, this.bounds.y + 13), new FR.Chart.Point2D(this.bounds.x + 19, this.bounds.y + 14));
        a.draw(b, FR.Chart.Constants.LINE_THIN);
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(this.bounds.x + 3, this.bounds.y + 14), new FR.Chart.Point2D(this.bounds.x + 6, this.bounds.y + 13));
        a.draw(b, FR.Chart.Constants.LINE_THIN);
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(this.bounds.x + 4, this.bounds.y + 7), new FR.Chart.Point2D(this.bounds.x + 6, this.bounds.y + 8));
        a.draw(b, FR.Chart.Constants.LINE_THIN)
    }
});
FR.Chart.RangeSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (b) {
        b.fillStyle = "rgb(204,204,204)";
        var c = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + 5, 22, 11);
        c.paint(b);
        b.strokeStyle = "rgb(153,153,153)";
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(this.bounds.x, this.bounds.y + 10), new FR.Chart.Point2D(this.bounds.x + 22, this.bounds.y + 10));
        a.draw(b, 1);
        b.fillStyle = this.currentStyle;
        var d = new FR.Chart.Bounds(this.bounds.x + 3, this.bounds.y + 5, 2, 11);
        d.paint(b);
        d = new FR.Chart.Bounds(this.bounds.x + 10, this.bounds.y + 5, 2, 11);
        d.paint(b);
        d = new FR.Chart.Bounds(this.bounds.x + 14, this.bounds.y + 5, 2, 11);
        d.paint(b);
        d = new FR.Chart.Bounds(this.bounds.x + 18, this.bounds.y + 5, 2, 11);
        d.paint(b)
    }
});
FR.Chart.CustomSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (b) {
        b.strokeStyle = this.currentStyle;
        var a = new FR.Chart.GeneralPath();
        a.moveTo(this.bounds.x + 3, this.bounds.y + 12);
        a.lineTo(this.bounds.x + 7, this.bounds.y + 6);
        a.lineTo(this.bounds.x + 13, this.bounds.y + 8);
        a.lineTo(this.bounds.x + 19, this.bounds.y + 1);
        a.draw(b, FR.Chart.Constants.LINE_MEDIUM);
        b.fillStyle = this.currentStyle;
        var c = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + 15, 6, 7);
        c.paint(b);
        c = new FR.Chart.Bounds(this.bounds.x + 8, this.bounds.y + 11, 6, 11);
        c.paint(b);
        c = new FR.Chart.Bounds(this.bounds.x + 16, this.bounds.y + 8, 6, 14);
        c.paint(b)
    }
});
FR.Chart.GanttSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.Bounds(this.bounds.x, this.bounds.y, 6, 6);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 5, this.bounds.y + 8, 8, 6);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 12, this.bounds.y + 16, 6, 6);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 5, this.bounds.y, 1, 8);
        b.paint(a);
        b = new FR.Chart.Bounds(this.bounds.x + 12, this.bounds.y + 8, 1, 8);
        b.paint(a);
        a.fillStyle = "rgb(204,204,204)";
        b = new FR.Chart.Bounds(this.bounds.x + 18, this.bounds.y + 16, 4, 6);
        b.paint(a)
    }
});
FR.Chart.DonutSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        a.beginPath();
        a.moveTo(this.bounds.x + 11, this.bounds.y + 1);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 270 * Math.PI / 180, 360 * Math.PI / 180, 0);
        a.lineTo(this.bounds.x + 16, this.bounds.y + 11);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 5, 360 * Math.PI / 180, 270 * Math.PI / 180, 1);
        a.closePath();
        a.fill();
        a.moveTo(this.bounds.x + 10, this.bounds.y + 1);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 264.26 * Math.PI / 180, 137.87 * Math.PI / 180, 1);
        a.lineTo(this.bounds.x + 7, this.bounds.y + 14);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 5, 140.22 * Math.PI / 180, 258.64 * Math.PI / 180, 0);
        a.closePath();
        a.fill();
        a.moveTo(this.bounds.x + 21, this.bounds.y + 12);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 5.74 * Math.PI / 180, 132.13 * Math.PI / 180, 0);
        a.lineTo(this.bounds.x + 8, this.bounds.y + 15);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 5, 129.29 * Math.PI / 180, 11.53 * Math.PI / 180, 1);
        a.closePath();
        a.fill()
    }
});
FR.Chart.FunnelSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x, this.bounds.y);
        b.lineTo(this.bounds.x + 22, this.bounds.y);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 8);
        b.lineTo(this.bounds.x + 1, this.bounds.y + 8);
        b.closePath();
        b.paint(a);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 1, this.bounds.y + 9);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 9);
        b.lineTo(this.bounds.x + 19, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 3, this.bounds.y + 16);
        b.closePath();
        b.paint(a);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 3, this.bounds.y + 17);
        b.lineTo(this.bounds.x + 19, this.bounds.y + 17);
        b.lineTo(this.bounds.x + 14, this.bounds.y + 22);
        b.lineTo(this.bounds.x + 8, this.bounds.y + 22);
        b.closePath();
        b.paint(a)
    }
});
FR.Chart.MapSmallIcon = FR.extend(FR.Chart.IconDemo, {
    paint: function (a) {
        a.fillStyle = this.currentStyle;
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 1, this.bounds.y + 12);
        b.lineTo(this.bounds.x + 2, this.bounds.y + 7);
        b.lineTo(this.bounds.x + 3, this.bounds.y + 5);
        b.lineTo(this.bounds.x + 5, this.bounds.y + 6);
        b.lineTo(this.bounds.x + 14, this.bounds.y + 6);
        b.lineTo(this.bounds.x + 16, this.bounds.y + 8);
        b.lineTo(this.bounds.x + 17, this.bounds.y + 8);
        b.lineTo(this.bounds.x + 20, this.bounds.y + 5);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 6);
        b.lineTo(this.bounds.x + 20, this.bounds.y + 7);
        b.lineTo(this.bounds.x + 20, this.bounds.y + 12);
        b.lineTo(this.bounds.x + 18, this.bounds.y + 14);
        b.lineTo(this.bounds.x + 19, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 18, this.bounds.y + 17);
        b.lineTo(this.bounds.x + 17, this.bounds.y + 15);
        b.lineTo(this.bounds.x + 15, this.bounds.y + 15);
        b.lineTo(this.bounds.x + 14, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 12, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 11, this.bounds.y + 18);
        b.lineTo(this.bounds.x + 9, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 7, this.bounds.y + 15);
        b.lineTo(this.bounds.x + 5, this.bounds.y + 15);
        b.lineTo(this.bounds.x + 3, this.bounds.y + 14);
        b.closePath();
        b.paint(a);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 4, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 6, this.bounds.y + 16);
        b.lineTo(this.bounds.x + 6, this.bounds.y + 17);
        b.lineTo(this.bounds.x + 4, this.bounds.y + 17);
        b.closePath();
        b.paint(a)
    }
});
FR.Chart.GisMapSmallIcon = FR.extend(FR.Chart.IconDemo, {
    draw: function (a) {
        if (!a) {
            return
        }
        a.save();
        this.drawBackground(a);
        var b = "rgba(77,77,77,0.9)";
        var c = "rgba(255,255,255,0.8)";
        if (this.state === FR.Chart.ChartIconState.STATE_SELECT || this.state === FR.Chart.ChartIconState.STATE_OVER) {
            b = "rgba(237,30,121,0.9)";
            c = "rgba(255,255,255,0.8)"
        }
        if (this.state === FR.Chart.ChartIconState.STATE_OVER) {
            a.globalAlpha = 0.6
        }
        this.paint(a, c, b);
        a.restore()
    }, drawBackground: function (a) {
        a.fillStyle = "rgb(204,204,204)";
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 1, this.bounds.y + 2);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 5);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 7);
        b.lineTo(this.bounds.x + 1, this.bounds.y + 4);
        b.closePath();
        b.paint(a);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 1, this.bounds.y + 9);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 12);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 14);
        b.lineTo(this.bounds.x + 1, this.bounds.y + 11);
        b.closePath();
        b.paint(a);
        b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 6, this.bounds.y + 1);
        b.lineTo(this.bounds.x + 8, this.bounds.y + 1);
        b.lineTo(this.bounds.x + 5, this.bounds.y + 21);
        b.lineTo(this.bounds.x + 3, this.bounds.y + 21);
        b.closePath();
        b.paint(a)
    }, paint: function (a, e, c) {
        a.fillStyle = c;
        var d = new FR.Chart.GeneralPath();
        d.moveTo(this.bounds.x + 7, this.bounds.y + 13);
        d.lineTo(this.bounds.x + 11, this.bounds.y + 14);
        d.lineTo(this.bounds.x + 15, this.bounds.y + 13);
        d.lineTo(this.bounds.x + 11, this.bounds.y + 17);
        d.closePath();
        d.paint(a);
        var b = new FR.Chart.Arc2D(this.bounds.x + 11, this.bounds.y + 10, 5, 0, 360);
        b.paint(a);
        a.fillStyle = e;
        b = new FR.Chart.Arc2D(this.bounds.x + 11, this.bounds.y + 10, 3, 0, 360);
        b.paint(a)
    }
});
FR.Chart.MapReturnSmallIcon = FR.extend(FR.Chart.IconDemo, {
    draw: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.fillStyle = "rgb(41,158,255)";
        a.beginPath();
        a.moveTo(this.bounds.x + 12, this.bounds.y + 5);
        a.arc(this.bounds.x + 12, this.bounds.y + 13, 8, 270 * Math.PI / 180, 90 * Math.PI / 180, 0);
        a.arc(this.bounds.x + 12, this.bounds.y + 17, 4, 90 * Math.PI / 180, 270 * Math.PI / 180, 1);
        a.lineTo(this.bounds.x + 9, this.bounds.y + 13);
        a.lineTo(this.bounds.x + 9, this.bounds.y + 16);
        a.lineTo(this.bounds.x + 2, this.bounds.y + 9);
        a.lineTo(this.bounds.x + 9, this.bounds.y + 2);
        a.lineTo(this.bounds.x + 9, this.bounds.y + 5);
        a.closePath();
        a.fill();
        a.restore()
    }
});
FR.Chart.RefreshSmallIcon = FR.extend(FR.Chart.IconDemo, {
    draw: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.fillStyle = "rgb(41,158,255)";
        a.moveTo(this.bounds.x + 4, this.bounds.y + 4);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 225 * Math.PI / 180, 90 * Math.PI / 180, 1);
        a.lineTo(this.bounds.x + 11, this.bounds.y + 19);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 8, 90 * Math.PI / 180, 225 * Math.PI / 180, 0);
        a.closePath();
        a.fill();
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 1, this.bounds.y + 1);
        b.lineTo(this.bounds.x + 8, this.bounds.y + 8);
        b.lineTo(this.bounds.x + 8, this.bounds.y + 1);
        b.closePath();
        b.paint(a);
        a.moveTo(this.bounds.x + 11, this.bounds.y + 3);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 8, 270 * Math.PI / 180, 45 * Math.PI / 180, 0);
        a.lineTo(this.bounds.x + 18, this.bounds.y + 18);
        a.arc(this.bounds.x + 11, this.bounds.y + 11, 10, 45 * Math.PI / 180, 270 * Math.PI / 180, 1);
        a.closePath();
        a.fill();
        var b = new FR.Chart.GeneralPath();
        b.moveTo(this.bounds.x + 14, this.bounds.y + 14);
        b.lineTo(this.bounds.x + 21, this.bounds.y + 21);
        b.lineTo(this.bounds.x + 14, this.bounds.y + 21);
        b.closePath();
        b.paint(a);
        a.restore()
    }
});
FR.Chart.TimeSwitchButton = function (a, b) {
    this.time = "1";
    this.unit = FR.Chart.Constants.YEAR;
    this.isGlobal = false;
    this.isPress = false;
    this.isOver = false
};
$.extend(FR.Chart.TimeSwitchButton.prototype, {
    draw: function (c) {
        if (!this.bounds) {
            return
        }
        if (!c) {
            return
        }
        c.save();
        c.fillStyle = this.isPress ? "rgb(41,171,226)" : (this.isOver ? "rgb(41,171,226)" : "rgb(122,218,244)");
        var b = Math.round(this.bounds.x), f = Math.round(this.bounds.y), a = Math.round(this.bounds.height),
            e = Math.round(this.bounds.width);
        var d = 4;
        c.beginPath();
        c.moveTo(b, f + d);
        c.lineTo(b, f + a - d);
        c.quadraticCurveTo(b, f + a, b + d, f + a);
        c.lineTo(b + e - d, f + a);
        c.quadraticCurveTo(b + e, f + a, b + e, f + a - d);
        c.lineTo(b + e, f + d);
        c.quadraticCurveTo(b + e, f, b + e - d, f);
        c.lineTo(b + d, f);
        c.quadraticCurveTo(b, f, b, f + d);
        c.closePath();
        c.fill();
        this._drawButtonText(c);
        c.restore()
    }, getUnitString: function (a) {
        if (a === FR.Chart.Constants.YEAR) {
            return FR.i18nText("FR-Chart-TimeUnit_Year")
        } else {
            if (a === FR.Chart.Constants.MONTH) {
                return FR.i18nText("FR-Chart-TimeUnit_Month")
            } else {
                if (a === FR.Chart.Constants.DAY) {
                    return FR.i18nText("FR-Chart-TimeUnit_Day")
                } else {
                    if (a === FR.Chart.Constants.Hour) {
                        return FR.i18nText("FR-Chart-TimeUnit_Hour")
                    } else {
                        if (a === FR.Chart.Constants.Minute) {
                            return FR.i18nText("FR-Chart-TimeUnit_Minute")
                        } else {
                            if (a === FR.Chart.Constants.Second) {
                                return FR.i18nText("FR-Chart-TimeUnit_Second")
                            }
                        }
                    }
                }
            }
        }
        return FR.i18nText("FR-Chart-TimeUnit_Year")
    }, getTextAttr: function () {
        var a = new FR.Chart.TextAttr();
        a.frFont = new FR.Chart.FRFont();
        a.frFont.color = "white";
        a.frFont.size = 9;
        a.horizontalAlignment = FR.Chart.Constants.CENTER;
        a.verticalAlignment = FR.Chart.Constants.CENTER;
        return a
    }, _drawButtonText: function (b) {
        if (this.bounds) {
            var g = new FR.Chart.TextGlyph();
            g.textAttr = this.getTextAttr();
            g.text = this.isGlobal ? FR.i18nText("FR-Chart-TimeSwitch_Global") : this.time + this.getUnitString(this.unit);
            var e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(g.text, g.textAttr);
            var c = (this.bounds.height - e.height) / 2 - 2;
            var d = 10 + (this.bounds.width - e.width) / 2;
            var a = Math.round(this.bounds.x), f = Math.round(this.bounds.y);
            g.bounds = new FR.Chart.Bounds(a + d, f + c, e.width, e.height);
            g.position = FR.Chart.Constants.CENTER;
            b.notUseDivText = true;
            g.draw(b);
            b.notUseDivText = false
        }
    }, containsPoint: function (a, b) {
        return this.bounds == null ? false : this.bounds.containsPoint(a, b)
    }
});
$.extend(FR.Chart.TimeSwitchButton, {});
FR.Chart = FR.Chart || {};
FR.Chart.TextAttr = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.frFont = a.font == undefined ? null : new FR.Chart.FRFont(a.font);
        this.direction = FR.pick(a.direction, FR.Chart.Style.LEFT_TO_RIGHT);
        this.rotation = FR.pick(a.rotation, 0);
        this.horizontalAlignment = FR.pick(a.horizontalAlignment, FR.Chart.Constants.LEFT);
        this.verticalAlignment = FR.pick(a.verticalAlignment, FR.Chart.Constants.CENTER);
        this.alignText = FR.pick(a.alignText, FR.Chart.Style.HORIZONTALTEXT)
    }, clone: function () {
        var a = new FR.Chart.TextAttr();
        a.frFont = this.frFont;
        a.direction = this.direction;
        a.rotation = this.rotation;
        a.horizontalAlignment = this.horizontalAlignment;
        a.verticalAlignment = this.verticalAlignment;
        a.alignText = this.alignText;
        return a
    }
});
FR.Chart.AttrFillStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (b) {
        b = b || {};
        this.colorStyle = FR.Chart.ChartUtils.getFillColorStyle(b.colorStyle);
        this.colorlist = [];
        if (b.definedColors) {
            this.colorlist = FR.Chart.DefinedColors[b.definedColors]
        }
        if (b.colorList) {
            for (var a = 0; a < b.colorList.length;
                 a++) {
                this.colorlist[a] = b.colorList[a]
            }
        }
    }, getColorIndex: function (a) {
        if (a >= 0) {
            return this.colorlist[a % this.colorlist.length]
        }
        return "rgb(255, 255, 255)"
    }, getColorSize: function () {
        return this.colorlist.length
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrFillStyle
    }
});
FR.Chart.AttrMarkerType = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.markerType = a.markerType
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrMarkerType
    }
});
FR.Chart.AttrAxisPosition = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.axisPosition = FR.pick(a.axisPosition, "LEFT")
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrAxisPosition
    }
});
FR.Chart.AttrAlpha = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.alpha = FR.pick(a.alpha, 1)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrAlpha
    }
});
FR.Chart.AttrBorder = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.borderColor = FR.pick(a.borderColor, "black");
        this.borderStyle = FR.pick(a.borderStyle, FR.Chart.Constants.LINE_NONE);
        this.isRoundBorder = FR.pick(a.isRoundBorder, false)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrBorder
    }, setBorderColor: function (a) {
        this.borderColor = a
    }, getBorderColor: function () {
        return this.borderColor
    }, setBorderStyle: function (a) {
        this.borderStyle = a
    }, getBorderStyle: function () {
        return this.borderStyle
    }
});
FR.Chart.AttrBackground = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesBackground = FR.Chart.AbstractBackground.initBackground(a.seriesBackground)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrBackground
    }
});
FR.Chart.AttrColor = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesColor = a.seriesColor
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrColor
    }, setSeriesColor: function (a) {
        this.seriesColor = a
    }, getSeriesColor: function () {
        return this.seriesColor
    }
});
FR.Chart.AttrLine = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesLineColor = a.seriesLineColor;
        this.seriesLineStyle = FR.pick(a.seriesLineStyle, FR.Chart.Constants.LINE_THIN)
    }, draw: function (a, b) {
        if (!a) {
            return
        }
        a.save();
        if (this.seriesLineColor && this.seriesLineStyle != FR.Chart.Constants.LINE_NONE) {
            a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.seriesLineStyle);
            a.strokeStyle = this.seriesLineColor;
            b.draw(a)
        }
        a.restore()
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrLine
    }
});
FR.Chart.AttrLineStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.lineStyle = FR.pick(a.lineStyle, FR.Chart.Constants.LINE_THIN)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrLineStyle
    }
});
FR.Chart.AttrNullValueBreak = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.isNullValueBreak = FR.pick(a.isNullValueBreak, false)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrNullValueBreak
    }
});
FR.Chart.AttrCurveLine = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.isCurve = FR.pick(a.isCurve, false)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrCurveLine
    }
});
FR.Chart.AttrLineSeries = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.isCurve = FR.pick(a.isCurve, false);
        this.isNullValueBreak = FR.pick(a.isNullValueBreak, true);
        this.lineStyle = FR.pick(a.lineStyle, FR.Chart.Constants.LINE_THICK);
        this.markerType = FR.pick(a.markerType, FR.Chart.Marker.NullMarker);
        this.axisPosition = FR.pick(a.axisPosition, FR.Chart.CustomAttr.Axis_LEFT)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrLineSeries
    }
});
FR.Chart.AttrBarSeries = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesOverlapPercent = FR.pick(a.seriesOverlapPercent, -0.25);
        this.categoryIntervalPercent = FR.pick(a.categoryIntervalPercent, 1);
        this.axisPosition = FR.pick(a.axisPosition, FR.Chart.CustomAttr.Axis_LEFT)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrBarSeries
    }
});
FR.Chart.AttrAreaSeries = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.isCurve = FR.pick(a.isCurve, false);
        this.markerType = FR.pick(a.markerType, FR.Chart.Marker.NullMarker);
        this.axisPosition = FR.pick(a.axisPosition, FR.Chart.CustomAttr.Axis_LEFT)
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrAreaSeries
    }
});
FR.Chart.AttrTrendLine = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (b) {
        if (b && b.trendLineList) {
            this.trendLineList = [];
            for (var a = 0; a < b.trendLineList.length; a++) {
                this.trendLineList[a] = new FR.Chart.TrendLine(b.trendLineList[a])
            }
        }
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrTrendLine
    }
});
FR.Chart.AttrContents = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesLabel = FR.pick(a.labelContent || a.seriesLabel || "");
        this.isShowGuidLine = FR.pick(a.leadLine || a.isShowGuidLine || false);
        this.position = FR.pick(FR.Chart.ChartUtils.getPosition(a.position), FR.Chart.Constants.TOP);
        this.isWhiteBackground = FR.pick(a.isWhiteBackground, true);
        this.isShowMutiSeries = FR.pick(a.isShowMutiSeries, false);
        this.textAttr = a.textAttr == undefined ? null : new FR.Chart.TextAttr(a.textAttr);
        this.format = a.valueFormat;
        this.percentFormat = a.percentFormat
    }, equals: function (a) {
        return a && a instanceof FR.Chart.AttrContents
    }
});
FR.Chart.AbstractBackground = {
    initBackground: function (a) {
        a = a || {};
        this.background = null;
        if (a.backgroundType) {
            if (a.backgroundType == "TextureBackground" || a.backgroundType == "PatternBackground") {
                this.background = new FR.Chart.PatterBackground(a)
            } else {
                this.background = new FR.Chart[a.backgroundType](a)
            }
            this.background.backgroundType = a.backgroundType
        }
        return this.background
    }
};
FR.Chart.ColorBackground = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.isHorizontal = a.isHorizontal;
        this.backgroundType = FR.pick(a.backgroundType, "ColorBackground")
    }, paint: function (a, b) {
        if (this.color && b && a) {
            a.save();
            a.fillStyle = this.color;
            b.paint(a);
            a.strokeStyle = this.color;
            b.draw(a);
            a.restore()
        }
    }, draw: function (a, b) {
        if (this.color && b && a) {
            a.save();
            a.strokeStyle = this.color;
            b.draw(a);
            a.restore()
        }
    }
});
$.extend(FR.Chart.ColorBackground, {
    getInstance: function (a) {
        var b = new FR.Chart.ColorBackground();
        b.color = a;
        return b
    }
});
FR.Chart.IntervalColorBackground = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.bgColor = a.bgColor;
        this.position = FR.pick(a.position, FR.Chart.Constants.LEFT);
        this.intervalLength = FR.pick(a.intervalLength, 0)
    }, paint: function (l, g) {
        if (this.intervalLength <= 0 || this.bgColor == null || this.bgColor == "") {
            return
        }
        if (g instanceof FR.Chart.Bounds && l) {
            l.save();
            var d = FR.Chart.GraphHelper.dealRectShape4JSPaint(g);
            var b = 1;
            var c = d.width - b * 2;
            var k = d.height - b * 2;
            var j = d.x + b;
            var h = d.y + d.height + b;
            l.fillStyle = this.bgColor;
            var f = parseInt(k / this.intervalLength);
            var a = parseInt(c / this.intervalLength);
            if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
                for (var e = 0; e < f; e++) {
                    if (e % 2 === 0) {
                        l.fillRect(j, h - (e + 1) * this.intervalLength, c, this.intervalLength)
                    }
                }
                if (f % 2 === 0) {
                    l.fillRect(j, d.y, c, k - f * this.intervalLength)
                }
            } else {
                for (var e = 0; e < a; e++) {
                    if (e % 2 === 0) {
                        l.fillRect(j + e * this.intervalLength, d.y, this.intervalLength, k)
                    }
                }
                if (a % 2 === 0) {
                    l.fillRect(j + a * this.intervalLength, d.y, c - a * this.intervalLength, k)
                }
            }
            l.restore()
        }
    }
});
FR.Chart.GradientBackground = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.useCell = FR.pick(a.useCell, true);
        this.direction = FR.pick(a.direction, 0);
        this.cyclic = a.cyclic;
        this.begin = FR.pick(a.begin, 0);
        this.finish = FR.pick(a.finish, 0);
        this.beginColor = a.beginColor;
        this.endColor = a.endColor;
        this.backgroundType = a.backgroundType || "GradientBackground"
    }, createRadialPaint: function (a, b) {
        var d = b.getCenterPoint();
        var c = a.createRadialGradient(d.x, d.y, b.getInnerRadius(), d.x, d.y, b.getOuterRadius());
        c.addColorStop(0, this.beginColor);
        c.addColorStop(1, this.endColor);
        return c
    }, createPaint: function (a, b) {
        var c = b.getBounds2D();
        var d;
        if (this.useCell) {
            if (this.direction == FR.Chart.GradientBackground.LEFT2RIGHT) {
                d = a.createLinearGradient(c.x, c.y, c.x + c.width, c.y)
            } else {
                if (this.direction == FR.Chart.GradientBackground.TOP2BOTTOM) {
                    d = a.createLinearGradient(c.x, c.y, c.x, c.y + c.height)
                }
            }
        } else {
            if (this.direction == FR.Chart.GradientBackground.LEFT2RIGHT) {
                d = a.createLinearGradient(this.begin, c.y, this.finish, c.y)
            } else {
                if (this.direction == FR.Chart.GradientBackground.TOP2BOTTOM) {
                    d = a.createLinearGradient(c.x, this.begin, c.x, this.finish)
                }
            }
        }
        d.addColorStop(0, this.beginColor);
        d.addColorStop(1, this.endColor);
        return d
    }, draw: function (a, b) {
        if (b == null || this.beginColor == null || this.endColor == null || !a) {
            return
        }
        a.save();
        a.strokeStyle = b.isNeedRadialGradient() ? this.createRadialPaint(a, b) : this.createPaint(a, b);
        b.draw(a);
        a.restore()
    }, paint: function (a, b) {
        if (b == null || this.beginColor == null || this.endColor == null || !a) {
            return
        }
        a.save();
        a.fillStyle = b.isNeedRadialGradient() ? this.createRadialPaint(a, b) : this.createPaint(a, b);
        b.paint(a);
        a.restore()
    }
});
$.extend(FR.Chart.GradientBackground, {TOP2BOTTOM: 1, LEFT2RIGHT: 0});
FR.Chart.ImageBackground = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            this.iesrc = a.iesrc
        } else {
            this.src = a.src
        }
        this.layout = FR.pick(a.layout, FR.Chart.Constants.IMAGE_TILED);
        this.specifiedImageHeight = FR.pick(a.specifiedImageHeight, -1);
        this.specifiedImageWidth = FR.pick(a.specifiedImageWidth, -1);
        this.imgWidth = a.imgWidth;
        this.imgHeight = a.imgHeight;
        this.backgroundType = FR.pick(a.backgroundType, "PatterBackground")
    }, draw: function (a, b) {
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            if (!this.iesrc || this.iesrc == "") {
                return
            }
        } else {
            if (!this.src || this.src == "") {
                return
            }
        }
        var d = new Image();
        var c = a.globalAlpha;
        d.onload = function () {
            a.globalAlpha = c;
            a.strokeStyle = a.createPattern(d, "repeat");
            b.draw(a)
        };
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            d.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.iesrc
        } else {
            d.src = this.src
        }
    }, paint: function (b, c) {
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            if (!this.iesrc || this.iesrc == "") {
                return
            }
        } else {
            if (!this.src || this.src == "") {
                return
            }
        }
        var a = this;
        var e = new Image();
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            e.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.iesrc
        } else {
            e.src = this.src
        }
        var d = b.globalAlpha;
        if (e.complete) {
            b.globalAlpha = d;
            a.paintImg(b, c, e, a)
        } else {
            e = new Image();
            e.onload = function () {
                b.globalAlpha = d;
                a.paintImg(b, c, e, a)
            };
            if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
                e.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.iesrc
            } else {
                e.src = this.src
            }
        }
    }, paintImg: function (v, b, p, r) {
        if (!v) {
            return
        }
        v.save();
        v.fillStyle = "rgba(255,255,255,0.01)";
        b.paint(v);
        v.clip();
        var e = b.getBounds2D();
        var s = e.width;
        var o = e.height;
        if (!r.imgWidth) {
            r.imgWidth = p.width
        }
        if (!r.imgHeight) {
            r.imgHeight = p.height
        }
        var g;
        if (r.specifiedImageWidth == -1) {
            g = r.imgWidth
        } else {
            g = r.specifiedImageWidth
        }
        var z;
        if (r.specifiedImageHeight == -1) {
            z = r.imgHeight
        } else {
            z = r.specifiedImageHeight
        }
        if (r.layout == FR.Chart.Constants.IMAGE_TILED) {
            if (g < 0 || z < 0) {
                return
            }
            for (var i = 0; i < s; i += g) {
                var a = s - i > g ? g : s - i;
                for (var h = 0; h < o; h += z) {
                    var q = o - h > z ? z : o - h;
                    v.drawImage(p, 0, 0, a, q, e.x + i, e.y + h, a, q)
                }
            }
        } else {
            if (r.layout == FR.Chart.Constants.IMAGE_CENTER) {
                var l, k, A, t, n, m, w, u;
                if (s < g) {
                    l = (g - s) * 0.5;
                    n = 0
                } else {
                    l = 0;
                    n = (s - g) * 0.5
                }
                if (o < z) {
                    k = (z - o) * 0.5;
                    m = 0
                } else {
                    k = 0;
                    m = (o - z) * 0.5
                }
                A = Math.min(s, r.imgWidth);
                w = Math.min(s, g);
                t = Math.min(o, r.imgHeight);
                u = Math.min(o, z);
                v.drawImage(p, l, k, A, t, e.x + n, e.y + m, w, u)
            } else {
                if (r.layout == FR.Chart.Constants.IMAGE_EXTEND) {
                    v.drawImage(p, e.x, e.y, s, o)
                } else {
                    if (r.layout == FR.Chart.Constants.IMAGE_DEFAULT) {
                        v.drawImage(p, 0, 0, Math.min(s, r.imgWidth), Math.min(o, r.imgHeight), e.x, e.y, Math.min(s, g), Math.min(o, z))
                    } else {
                        if (r.layout == FR.Chart.Constants.IMAGE_ADJUST) {
                            var f = r.imgWidth;
                            var C = r.imgHeight;
                            var B = s / f;
                            var d = o / C;
                            var i = e.x;
                            var h = e.y;
                            var j = s;
                            var c = o;
                            if (B > d) {
                                j = (s * d / B);
                                i = (s - j) / 2 + e.x
                            } else {
                                c = (o * B / d);
                                h = (o - c) / 2 + e.y
                            }
                            v.drawImage(p, i, h, j, c)
                        } else {
                            v.drawImage(p, e.x, e.y, s, o)
                        }
                    }
                }
            }
        }
        v.restore()
    }
});
FR.Chart.PatterBackground = FR.extend(FR.Chart.ImageBackground, {
    paint: function (a, b) {
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            if (!this.iesrc || this.iesrc == "") {
                return
            }
        } else {
            if (!this.src || this.src == "") {
                return
            }
        }
        if (!a) {
            return
        }
        a.save();
        var d = new Image();
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            d.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.iesrc
        } else {
            d.src = this.src
        }
        if (d.complete) {
            a.globalAlpha = c;
            a.fillStyle = a.createPattern(d, "repeat");
            b.paint(a)
        } else {
            d = new Image();
            var c = a.globalAlpha;
            var e = a.xylist;
            d.onload = function () {
                a.globalAlpha = c;
                a.fillStyle = a.createPattern(d, "repeat");
                if (e) {
                    for (var f = 0; f < e.length; f = f + 2) {
                        a.translate(e[f], e[f + 1])
                    }
                }
                b.paint(a);
                if (e) {
                    for (var f = 0; f < e.length; f = f + 2) {
                        a.translate(-e[f], -e[f + 1])
                    }
                }
            };
            if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
                d.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.iesrc
            } else {
                d.src = this.src
            }
        }
        a.restore()
    }
});
FR.Chart.HighLightChart = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        this.shape = null;
        this.isHorizontal = false
    }, paintStyle: function (n) {
        if (this.shape == null || FR.Chart.GraphHelper.isBoundsNaN(this.shape.getBounds2D())) {
            return
        }
        if (!n) {
            return
        }
        n.save();
        var l = this.shape.getBounds2D().x;
        var k = this.shape.getBounds2D().y;
        var b = this.shape.getBounds2D().width;
        var m = this.shape.getBounds2D().height;
        if (this.shape instanceof FR.Chart.Bounds) {
            var c;
            var d;
            if (this.isHorizontal) {
                c = n.createLinearGradient(l, k, l, k + m / 2);
                d = new FR.Chart.Bounds(l, k, b, m / 2)
            } else {
                c = n.createLinearGradient(l, k, l + b / 2, k);
                d = new FR.Chart.Bounds(l, k, b / 2, m)
            }
            c.addColorStop(0, "rgba(255, 255, 255, 0.4)");
            c.addColorStop(1, "rgba(255, 255, 255, 0.1)");
            n.fillStyle = c;
            d.paint(n)
        } else {
            if (this.shape instanceof FR.Chart.Arc2D) {
                var f = this.shape.x, e = this.shape.y;
                var a = this.shape.radius;
                var h = (f + a * Math.cos(330 * Math.PI / 180));
                var g = (e - a * Math.sin(330 * Math.PI / 180));
                var j = (f + a * Math.cos(60 * Math.PI / 180));
                var i = (e - a * Math.sin(60 * Math.PI / 180));
                var c = n.createRadialGradient(l, k, 0, l, k, a * 1.5);
                c.addColorStop(0, "rgba(255, 255, 255, 0.4)");
                c.addColorStop(1, "rgba(255, 255, 255, 0.1)");
                n.fillStyle = c;
                n.beginPath();
                n.moveTo(j, i);
                n.arc(f, e, a, 5 * Math.PI / 3, Math.PI * 2 / 3, true);
                n.quadraticCurveTo(h, g, j, i);
                n.fill()
            }
        }
        n.restore()
    }
});
FR.Chart.OuterLight = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.outerSize = a.outerSize == undefined ? 0 : a.outerSize;
        this.outerAlpha = a.outerAlpha == undefined ? 0 : a.outerAlpha;
        this.outerColor = a.outerColor || null
    }, paint: function (a, b, c) {
        if (FR.Browser.isIE()) {
            return
        }
        if (b == null || this.outerSize === 0 || this.outerAlpha === 0 || this.outerColor == null) {
            return
        }
        if (!a) {
            return
        }
        a.save();
        a.shadowBlur = this.outerSize / 2;
        a.shadowColor = "rgba(" + FR.Chart.Color.getColorArray(this.outerColor) + "," + this.outerAlpha + ")";
        a.shadowOffsetY = 0;
        a.shadowOffsetX = 0;
        if (c <= 0) {
            b.paint(a)
        } else {
            b.draw(a)
        }
        a.restore()
    }
});
FR.Chart.Shadow = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.shadowSize = a.shadowSize == undefined ? 0 : a.shadowSize;
        this.shadowAlpha = a.shadowAlpha == undefined ? 0 : a.shadowAlpha;
        this.shadowColor = a.shadowColor == undefined ? "gray" : a.shadowColor
    }, paint: function (a, c, d) {
        if (FR.Browser.isIE()) {
            return
        }
        if (c == null || this.shadowSize === 0 || this.shadowAlpha === 0 || this.shadowColor == null) {
            return
        }
        if (!a) {
            return
        }
        a.save();
        a.globalAlpha = this.shadowAlpha;
        var b = "rgba(" + FR.Chart.Color.getColorArray(this.shadowColor) + "," + this.shadowAlpha + ")";
        a.shadowColor = this.shadowColor;
        a.fillStyle = this.shadowColor;
        var f = this.shadowSize / 30 * 6;
        var e = this.shadowSize;
        a.shadowOffsetX = this.shadowSize / 2 - f;
        a.shadowOffsetY = this.shadowSize / 2 - f;
        if (e < 10) {
            e = this.shadowSize / 4
        }
        a.shadowBlur = e;
        a.shadowBlur = e / 3;
        if (d <= 0) {
            c.paint(a)
        } else {
            c.draw(a)
        }
        a.restore()
    }
});
FR.Chart.TransparentChart = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.avoidOriginDraw = !!a.avoidOriginDraw;
        this.axisReversed = a.axisReversed;
        this.alpha = a.alpha;
        this.borderColor = a.borderColor;
        this.borderWidth = a.borderWidth
    }, getPaintAlpha: function () {
        return this.alpha === undefined ? 0.33 : this.alpha
    }, getStrokeAlpha: function () {
        return this.alpha === undefined ? 0.7 : this.alpha
    }, getStrokeLineColor: function () {
        return this.borderColor === undefined ? this.color : this.borderColor
    }, getStrokeLineWidth: function () {
        return this.borderWidth === undefined ? 2 : this.borderWidth
    }
});
FR.Chart.BarTransparentChart = FR.extend(FR.Chart.TransparentChart, {
    initConstants: function (a) {
        a = a || {};
        this.rect = a.rect;
        this.newRect = this.rect;
        this.isHorizontal = !!a.isHorizontal;
        FR.Chart.BarTransparentChart.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.BarTransparentChart();
        a.rect = this.rect;
        a.isHorizontal = this.isHorizontal;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.fillStyle = this.color;
        a.globalAlpha = this.getPaintAlpha();
        this.newRect.paint(a);
        a.strokeStyle = this.getStrokeLineColor();
        a.globalAlpha = this.getStrokeAlpha();
        a.lineWidth = this.getStrokeLineWidth();
        if (this.axisReversed !== this.rect.isNigativeValue) {
            if (this.isHorizontal) {
                this.newRect.drawWithOutRight(a)
            } else {
                this.newRect.drawWithOutTop(a)
            }
        } else {
            if (this.isHorizontal) {
                this.newRect.drawWithOutLeft(a)
            } else {
                this.newRect.drawWithOutBottom(a)
            }
        }
        a.restore()
    }
});
FR.Chart.StackedBarTransparentChartStyle = FR.extend(FR.Chart.TransparentChart, {
    initConstants: function (a) {
        a = a || {};
        this.rect = a.rect;
        this.newRect = this.rect;
        this.totalRect = a.rect;
        this.isFirst = false;
        this.isHorizontal = !!a.isHorizontal;
        FR.Chart.StackedBarTransparentChartStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.StackedBarTransparentChartStyle();
        a.rect = this.rect;
        a.isHorizontal = this.isHorizontal;
        a.newRect = b;
        a.color = this.color;
        a.isFirst = this.isFirst;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.fillStyle = this.color;
        a.globalAlpha = this.getPaintAlpha();
        this.newRect.paint(a);
        a.strokeStyle = this.getStrokeLineColor();
        a.globalAlpha = this.getStrokeAlpha();
        a.lineWidth = this.getStrokeLineWidth();
        if (this.isHorizontal) {
            if (this.isFirst) {
                if (this.axisReversed) {
                    this.newRect.drawWithOutRight(a)
                } else {
                    this.newRect.drawWithOutLeft(a)
                }
            } else {
                this.newRect.drawTopAndBottom(a)
            }
        } else {
            if (this.isFirst) {
                if (this.axisReversed) {
                    this.newRect.drawWithOutTop(a)
                } else {
                    this.newRect.drawWithOutBottom(a)
                }
            } else {
                this.newRect.drawLeftAndRight(a)
            }
        }
        a.restore()
    }
});
FR.Chart.ArcTransparentChartStyle = FR.extend(FR.Chart.TransparentChart, {
    initConstants: function (a) {
        a = a || {};
        this.arcShape = a.arcShape;
        this.newArc = this.arcShape;
        FR.Chart.ArcTransparentChartStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.ArcTransparentChartStyle();
        a.arcShape = this.arcShape;
        a.newArc = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.fillStyle = this.color;
        a.globalAlpha = this.getPaintAlpha();
        this.newArc.paint(a);
        a.strokeStyle = this.getStrokeLineColor();
        a.globalAlpha = this.getStrokeAlpha();
        a.lineWidth = this.getStrokeLineWidth();
        this.newArc.draw(a);
        a.restore()
    }
});
FR.Chart.AreaTransparentChartStyle = FR.extend(FR.Chart.TransparentChart, {
    initConstants: function (a) {
        a = a || {};
        this.areaPath = a.areaPath;
        this.newArea = this.areaPath;
        FR.Chart.AreaTransparentChartStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.AreaTransparentChartStyle();
        a.areaPath = this.areaPath;
        a.newArea = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.fillStyle = this.color;
        a.globalAlpha = this.getPaintAlpha();
        this.newArea.paint(a);
        a.restore()
    }
});
FR.Chart.TopDownShadeChart = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.avoidOriginDraw = !!a.avoidOriginDraw;
        this.axisReversed = a.axisReversed;
        this.alpha = a.alpha;
        this.borderColor = a.borderColor;
        this.borderWidth = a.borderWidth
    }, getStartColor: function () {
        return this.color
    }, getEndColor: function () {
        var b = FR.Chart.Color.getColorArray(this.color);
        var a = FR.Chart.Color.RGB2HSB(b[0], b[1], b[2]);
        return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], 0.13, 0.94))
    }, getLineColor: function () {
        var b = FR.Chart.Color.getColorArray(this.color);
        var a = FR.Chart.Color.RGB2HSB(b[0], b[1], b[2]);
        return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], a[1] + 0.1, a[2] - 0.1))
    }
});
FR.Chart.BarTopDownShadeStyle = FR.extend(FR.Chart.TopDownShadeChart, {
    initConstants: function (a) {
        a = a || {};
        this.rect = a.rect;
        this.isHorizontal = !!a.isHorizontal;
        this.newRect = this.rect;
        FR.Chart.BarTopDownShadeStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.BarTopDownShadeStyle();
        a.rect = this.rect;
        a.isHorizontal = this.isHorizontal;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (a) {
        if (this.color) {
            if (FR.Chart.GraphHelper.isBoundsNaN(this.rect)) {
                return
            }
            if (!a) {
                return
            }
            a.save();
            if (this.isHorizontal) {
                this.horizontalPaint(a);
                this.horizontalDraw(a)
            } else {
                this.verticalPaint(a);
                this.verticalDraw(a)
            }
            a.restore()
        }
    }, horizontalPaint: function (b) {
        if (!b) {
            return
        }
        b.save();
        var c = this.rect.width;
        var a = this.rect.x;
        var e = this.rect.y;
        var d;
        if (this.axisReversed) {
            if (this.rect.isNigativeValue) {
                d = b.createLinearGradient(a + c, e, a, e)
            } else {
                d = b.createLinearGradient(a, e, a + c, e)
            }
        } else {
            if (this.rect.isNigativeValue) {
                d = b.createLinearGradient(a, e, a + c, e)
            } else {
                d = b.createLinearGradient(a + c, e, a, e)
            }
        }
        d.addColorStop(0, this.getStartColor());
        d.addColorStop(1, this.getEndColor());
        b.fillStyle = d;
        this.newRect.paint(b);
        b.restore()
    }, horizontalDraw: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.strokeStyle = this.getLineColor();
        a.lineWidth = 1;
        if (this.axisReversed) {
            if (this.rect.isNigativeValue) {
                this.newRect.drawWithOutLeft(a)
            } else {
                this.newRect.drawWithOutRight(a)
            }
        } else {
            if (this.rect.isNigativeValue) {
                this.newRect.drawWithOutRight(a)
            } else {
                this.newRect.drawWithOutLeft(a)
            }
        }
        a.restore()
    }, verticalPaint: function (c) {
        if (!c) {
            return
        }
        c.save();
        var b = this.rect.height;
        var a = this.rect.x;
        var e = this.rect.y;
        var d;
        if (this.axisReversed) {
            if (this.rect.isNigativeValue) {
                d = c.createLinearGradient(a, e, a, e + b)
            } else {
                d = c.createLinearGradient(a, e + b, a, e)
            }
        } else {
            if (this.rect.isNigativeValue) {
                d = c.createLinearGradient(a, e + b, a, e)
            } else {
                d = c.createLinearGradient(a, e, a, e + b)
            }
        }
        d.addColorStop(0, this.getStartColor());
        d.addColorStop(1, this.getEndColor());
        c.fillStyle = d;
        this.newRect.paint(c);
        c.restore()
    }, verticalDraw: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.strokeStyle = this.getLineColor();
        a.lineWidth = 1;
        if (this.axisReversed) {
            if (this.rect.isNigativeValue) {
                this.newRect.drawWithOutBottom(a)
            } else {
                this.newRect.drawWithOutTop(a)
            }
        } else {
            if (this.rect.isNigativeValue) {
                this.newRect.drawWithOutTop(a)
            } else {
                this.newRect.drawWithOutBottom(a)
            }
        }
        a.restore()
    }
});
FR.Chart.StackedBarTopDownShadeStyle = FR.extend(FR.Chart.TopDownShadeChart, {
    initConstants: function (a) {
        a = a || {};
        this.rect = a.rect;
        this.totalRect = a.rect;
        this.isHorizontal = !!a.isHorizontal;
        this.newRect = this.rect;
        FR.Chart.StackedBarTopDownShadeStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.StackedBarTopDownShadeStyle();
        a.rect = this.rect;
        a.isHorizontal = this.isHorizontal;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.totalRect = this.totalRect;
        a.isFirst = this.isFirst;
        a.axisReversed = this.axisReversed;
        return a
    }, paintStyle: function (i) {
        if (!i) {
            return
        }
        i.save();
        if (this.animateGlyph) {
            this.animateGlyph.drawWithOutStyle(i)
        }
        var d = "rgba(255, 255, 255, 0)";
        var b = "rgba(255, 255, 255,0.73)";
        if (this.isFirst) {
            var c;
            var g = this.totalRect.x;
            var f = this.totalRect.y;
            var a = this.totalRect.width;
            var h = this.totalRect.height;
            if (this.axisReversed) {
                if (this.isHorizontal) {
                    c = i.createLinearGradient(g, f, g + a, f)
                } else {
                    c = i.createLinearGradient(g, f + h, g, f)
                }
            } else {
                if (this.isHorizontal) {
                    c = i.createLinearGradient(g + a, f, g, f)
                } else {
                    c = i.createLinearGradient(g, f, g, f + h)
                }
            }
            c.addColorStop(0, d);
            c.addColorStop(1, b);
            i.fillStyle = c;
            this.totalRect.paint(i)
        }
        var g = this.newRect.x;
        var f = this.newRect.y;
        var a = this.newRect.width;
        var h = this.newRect.height;
        var e = new FR.Chart.Bounds(g - 1, f - 1, a + 1, h + 1);
        i.strokeStyle = this.getLineColor();
        i.lineWidth = 1;
        if (this.isFirst) {
            if (this.axisReversed) {
                if (this.isHorizontal) {
                    e.drawWithOutRight(i)
                } else {
                    e.drawWithOutTop(i)
                }
            } else {
                if (this.isHorizontal) {
                    e.drawWithOutLeft(i)
                } else {
                    e.drawWithOutBottom(i)
                }
            }
        } else {
            if (this.isHorizontal) {
                e.drawTopAndBottom(i)
            } else {
                e.drawLeftAndRight(i)
            }
        }
        i.restore()
    }
});
FR.Chart.ArcTopDownShadeStyle = FR.extend(FR.Chart.TopDownShadeChart, {
    initConstants: function (a) {
        a = a || {};
        this.arcShape = a.arcShape;
        this.newArc = this.arcShape;
        this.totalRadius = FR.pick(a.totalRadius, 0);
        this.categoryCount = FR.pick(a.count, 1);
        FR.Chart.ArcTopDownShadeStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.ArcTopDownShadeStyle();
        a.arcShape = this.arcShape;
        a.newArc = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.totalRadius = this.totalRadius;
        a.categoryCount = this.categoryCount;
        return a
    }, paintStyle: function (b) {
        if (!b) {
            return
        }
        b.save();
        var e, d, h;
        if (this.arcShape.getExtent() <= 180 || this.categoryCount !== 1) {
            var g = this.arcShape.x;
            var f = this.arcShape.y;
            var a = (this.totalRadius === 0 ? this.arcShape.getRadius() : this.totalRadius);
            h = b.createRadialGradient(g, f, 0, g, f, a);
            h.addColorStop(0, this.getEndColor());
            h.addColorStop(1, this.getStartColor())
        } else {
            var c = this.arcShape.getHalfAngle();
            if (c >= 45 && c < 135) {
                e = this.arcShape.getPointWithAngle(90);
                d = this.arcShape.getBottomPoint();
                d.x = e.x
            } else {
                if (c >= 135 && c < 225) {
                    e = this.arcShape.getPointWithAngle(180);
                    d = this.arcShape.getLeftMostPoint();
                    d.y = e.y
                } else {
                    if (c >= 225 && c < 315) {
                        e = this.arcShape.getPointWithAngle(270);
                        d = this.arcShape.getTopPoint();
                        d.x = e.x
                    } else {
                        e = this.arcShape.getPointWithAngle(360);
                        d = this.arcShape.getRightMostPoint();
                        d.y = e.y
                    }
                }
            }
            h = b.createLinearGradient(e.x, e.y, d.x, d.y);
            h.addColorStop(0, this.getStartColor());
            h.addColorStop(1, this.getEndColor())
        }
        b.fillStyle = h;
        this.newArc.paint(b);
        b.strokeStyle = this.getLineColor();
        b.lineWidth = 1;
        this.newArc.draw(b);
        b.restore()
    }, getStartColor: function () {
        return this.color
    }, getEndColor: function () {
        return FR.Chart.Color.brighterWithFactor(this.color, 0.4)
    }
});
FR.Chart.AreaTopDownShadeStyle = FR.extend(FR.Chart.TopDownShadeChart, {
    initConstants: function (a) {
        a = a || {};
        this.areaPath = a.areaPath;
        this.newArea = this.areaPath;
        FR.Chart.AreaTopDownShadeStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.AreaTopDownShadeStyle();
        a.areaPath = this.areaPath;
        a.newArea = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        return a
    }, getStartColor: function () {
        var a = FR.Chart.Color.getColorArray(this.color);
        return "rgba(" + a + ",0.4" + ")"
    }, getEndColor: function () {
        var a = FR.Chart.Color.getColorArray(this.color);
        return "rgba(" + a + ",0" + ")"
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        var b = this.newArea.getBounds2D();
        var c;
        if (this.axisReversed) {
            c = a.createLinearGradient(b.x, b.y + b.height, b.x, b.y)
        } else {
            c = a.createLinearGradient(b.x, b.y, b.x, b.y + b.height)
        }
        c.addColorStop(0, this.getStartColor());
        c.addColorStop(1, this.getEndColor());
        a.fillStyle = c;
        this.newArea.paint(a);
        a.restore()
    }
});
FR.Chart.BarStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.rect = a.rect;
        this.newRect = this.rect;
        this.axisReversed = a.axisReversed;
        this.avoidOriginDraw = !!a.avoidOriginDraw;
        this.alpha = a.alpha;
        this.borderColor = a.borderColor;
        this.borderWidth = a.borderWidth
    }, getStrokeColor: function () {
        var b = FR.Chart.Color.getColorArray(this.color);
        var a = FR.Chart.Color.RGB2HSB(b[0], b[1], b[2]);
        return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], a[1] - 0.1, a[2] + 0.1))
    }, getShadeStartColor: function () {
        return FR.Chart.Color.getShadeStartColor(this.color, 0.35)
    }, getShadeEndColor: function () {
        return FR.Chart.Color.getShadeEndColor(this.color, 0.35)
    }, getInnerStrokeColor: function () {
        return "rgba(255, 255, 255, 0.33)"
    }
});
FR.Chart.StackedBar3DStyle = FR.extend(FR.Chart.BarStyle, {
    initConstants: function (a) {
        a = a || {};
        this.isHorizontal = !!a.isHorizontal;
        this.totalRect = a.rect;
        FR.Chart.StackedBar3DStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.StackedBar3DStyle();
        a.rect = this.rect;
        a.newRect = b;
        a.isFirst = this.isFirst;
        a.totalRect = this.totalRect;
        a.color = this.color;
        a.isHorizontal = this.isHorizontal;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (c) {
        if (this.color && this.newRect) {
            if (FR.Chart.GraphHelper.isBoundsNaN(this.rect)) {
                return
            }
            if (this.axisReversed) {
                this.drawWhenAxisReversed(c);
                return
            }
            if (!c) {
                return
            }
            c.save();
            var e = this.newRect.width;
            var b = this.newRect.height;
            var a = this.newRect.x;
            var h = this.newRect.y;
            var g;
            if (this.isHorizontal) {
                c.shadowOffsetX = 0;
                c.shadowOffsetY = 3;
                c.shadowColor = "rgba(0, 0, 0, 0.2)";
                c.shadowBlur = 2;
                g = c.createLinearGradient(a, h, a, h + b)
            } else {
                c.shadowOffsetX = 3;
                c.shadowOffsetY = 0;
                c.shadowColor = "rgba(0, 0, 0, 0.2)";
                c.shadowBlur = 2;
                g = c.createLinearGradient(a, h, a + e, h)
            }
            g.addColorStop(0, this.getShadeStartColor());
            g.addColorStop(1, this.getShadeEndColor());
            c.fillStyle = g;
            this.newRect.paint(c);
            c.restore();
            if (!c) {
                return
            }
            c.save();
            c.strokeStyle = this.getStrokeColor();
            c.lineWidth = 1;
            if (e > 4 && b > 4) {
                if (this.isHorizontal) {
                    if (this.isFirst) {
                        this.newRect.drawWithOutLeft(c)
                    } else {
                        this.newRect.drawTopAndBottom(c)
                    }
                } else {
                    if (this.isFirst) {
                        this.newRect.drawWithOutBottom(c)
                    } else {
                        this.newRect.drawLeftAndRight(c)
                    }
                }
            }
            if (this.isFirst) {
                var d = FR.Chart.GraphHelper.dealRectShape4JSDraw(this.totalRect);
                a = d.x;
                h = d.y;
                e = d.width;
                b = d.height;
                c.strokeStyle = this.getInnerStrokeColor();
                var f = new FR.Chart.GeneralPath();
                if (this.isHorizontal) {
                    f.moveTo(a + 1, h + 1);
                    f.lineTo(a + e - 1, h + 1);
                    f.lineTo(a + e - 1, h + b - 1)
                } else {
                    f.moveTo(a + 1, h + b - 1);
                    f.lineTo(a + 1, h + 1);
                    f.lineTo(a + e - 1, h + 1)
                }
                f.draw(c)
            }
            c.restore()
        }
    }, drawWhenAxisReversed: function (c) {
        if (!c) {
            return
        }
        c.save();
        var e = this.newRect.width;
        var b = this.newRect.height;
        var a = this.newRect.x;
        var h = this.newRect.y;
        var g;
        if (this.isHorizontal) {
            c.shadowOffsetX = 0;
            c.shadowOffsetY = -3;
            c.shadowColor = "rgba(0, 0, 0, 0.2)";
            c.shadowBlur = 2;
            g = c.createLinearGradient(a, h, a, h + b)
        } else {
            c.shadowOffsetX = 3;
            c.shadowOffsetY = 0;
            c.shadowColor = "rgba(0, 0, 0, 0.2)";
            c.shadowBlur = 2;
            g = c.createLinearGradient(a, h, a + e, h)
        }
        g.addColorStop(0, this.getShadeStartColor());
        g.addColorStop(1, this.getShadeEndColor());
        c.fillStyle = g;
        this.newRect.paint(c);
        c.restore();
        if (!c) {
            return
        }
        c.save();
        c.strokeStyle = this.getStrokeColor();
        c.lineWidth = 1;
        if (e > 4 && b > 4) {
            if (this.isHorizontal) {
                if (this.isFirst) {
                    this.newRect.drawWithOutRight(c)
                } else {
                    this.newRect.drawTopAndBottom(c)
                }
            } else {
                if (this.isFirst) {
                    this.newRect.drawWithOutTop(c)
                } else {
                    this.newRect.drawLeftAndRight(c)
                }
            }
        }
        if (this.isFirst) {
            var d = FR.Chart.GraphHelper.dealRectShape4JSDraw(this.totalRect);
            a = d.x;
            h = d.y;
            e = d.width;
            b = d.height;
            c.strokeStyle = this.getInnerStrokeColor();
            var f = new FR.Chart.GeneralPath();
            if (this.isHorizontal) {
                f.moveTo(a + 1, h + b - 1);
                f.lineTo(a + 1, h + 1);
                f.lineTo(a + e - 1, h + 1)
            } else {
                f.moveTo(a + 1, h + 1);
                f.lineTo(a + 1, h + b - 1);
                f.lineTo(a + e - 1, h + b - 1)
            }
            f.draw(c)
        }
        c.restore()
    }
});
FR.Chart.BarHorizontal3DStyle = FR.extend(FR.Chart.BarStyle, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.BarHorizontal3DStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.BarHorizontal3DStyle();
        a.rect = this.rect;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (c) {
        if (this.color) {
            if (FR.Chart.GraphHelper.isBoundsNaN(this.rect)) {
                return
            }
            var b = this.newRect.x;
            var h = this.newRect.y;
            var e = this.newRect.width;
            var a = this.newRect.height;
            if (e < 4 || a < 4) {
                if (!c) {
                    return
                }
                c.save();
                c.fillStyle = this.color;
                this.newRect.paint(c);
                c.strokeStyle = this.color;
                this.newRect.draw(c);
                c.restore();
                return
            }
            if (!c) {
                return
            }
            c.save();
            c.shadowOffsetX = 0;
            c.shadowOffsetY = 3;
            c.shadowColor = "rgba(0, 0, 0, 0.2)";
            c.shadowBlur = 2;
            var g = c.createLinearGradient(b, h, b, h + a);
            g.addColorStop(0, this.getShadeStartColor());
            g.addColorStop(1, this.getShadeEndColor());
            c.fillStyle = g;
            this.newRect.paint(c);
            c.restore();
            c.save();
            c.strokeStyle = this.getStrokeColor();
            c.lineWidth = 1;
            this.newRect.draw(c);
            var d = FR.Chart.GraphHelper.dealRectShape4JSDraw(this.newRect);
            c.strokeStyle = this.getInnerStrokeColor();
            b = d.x;
            h = d.y;
            e = d.width;
            a = d.height;
            var f = new FR.Chart.GeneralPath();
            if (this.axisReversed) {
                f.moveTo(b + 1, h + a - 1);
                f.lineTo(b + 1, h + 1);
                f.lineTo(b + e - 1, h + 1)
            } else {
                f.moveTo(b + 1, h + 1);
                f.lineTo(b + e - 1, h + 1);
                f.lineTo(b + e - 1, h + a - 1)
            }
            f.draw(c);
            c.restore()
        }
    }
});
FR.Chart.BarVertical3DStyle = FR.extend(FR.Chart.BarStyle, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.BarVertical3DStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.BarVertical3DStyle();
        a.rect = this.rect;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (c) {
        if (this.color) {
            if (FR.Chart.GraphHelper.isBoundsNaN(this.rect)) {
                return
            }
            if (!c) {
                return
            }
            var b = this.newRect.x;
            var h = this.newRect.y;
            var e = this.newRect.width;
            var a = this.newRect.height;
            if (e < 4 || a < 4) {
                c.save();
                c.fillStyle = this.color;
                this.newRect.paint(c);
                c.strokeStyle = this.color;
                this.newRect.draw(c);
                c.restore();
                return
            }
            c.save();
            c.shadowOffsetX = 3;
            c.shadowOffsetY = 0;
            c.shadowColor = "rgba(0, 0, 0, 0.2)";
            c.shadowBlur = 2;
            var g = c.createLinearGradient(b, h, b + e, h);
            g.addColorStop(0, this.getShadeStartColor());
            g.addColorStop(1, this.getShadeEndColor());
            c.fillStyle = g;
            this.newRect.paint(c);
            c.restore();
            c.save();
            c.strokeStyle = this.getStrokeColor();
            c.lineWidth = 1;
            this.newRect.draw(c);
            var d = FR.Chart.GraphHelper.dealRectShape4JSDraw(this.newRect);
            c.strokeStyle = this.getInnerStrokeColor();
            b = d.x;
            h = d.y;
            e = d.width;
            a = d.height;
            var f = new FR.Chart.GeneralPath();
            if (this.axisReversed) {
                f.moveTo(b + 1, h + 1);
                f.lineTo(b + 1, h + a - 1);
                f.lineTo(b + e - 1, h + a - 1)
            } else {
                f.moveTo(b + 1, h + a - 1);
                f.lineTo(b + 1, h + 1);
                f.lineTo(b + e - 1, h + 1)
            }
            f.draw(c);
            c.restore()
        }
    }
});
FR.Chart.HighLightStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.rect = a.rect;
        this.newRect = this.rect;
        this.avoidOriginDraw = !!a.avoidOriginDraw;
        this.axisReversed = a.axisReversed;
        this.alpha = a.alpha;
        this.borderColor = a.borderColor;
        this.borderWidth = a.borderWidth
    }, getPaintStartColor: function () {
        return FR.Chart.Color.brighter(this.color)
    }, getPaintEndColor: function () {
        return this.color
    }, getHighLightStartColor: function () {
        return "rgba(255,255,255, 0.6)"
    }, getHighLightEndColor: function () {
        return "rgba(255,255,255, 0)"
    }, getHighLightShape: function (d) {
        var e = new FR.Chart.GeneralPath();
        var b = d.x;
        var f = d.y;
        var a = d.height;
        var c = d.width;
        if (this.axisReversed) {
            e.moveTo(b, f);
            e.lineTo(b, f + a);
            e.lineTo(b + c * 2 / 3, f + a)
        } else {
            e.moveTo(b, f + a);
            e.lineTo(b, f);
            e.lineTo(b + c * 2 / 3, f)
        }
        e.closePath();
        return e
    }, getHighLightHorizontalShape: function (d) {
        var e = new FR.Chart.GeneralPath();
        var b = d.x;
        var f = d.y;
        var a = d.height;
        var c = d.width;
        if (this.axisReversed) {
            e.moveTo(b, f + a * 2 / 3);
            e.lineTo(b, f);
            e.lineTo(b + c, f)
        } else {
            e.moveTo(b, f);
            e.lineTo(b + c, f);
            e.lineTo(b + c, f + a * 2 / 3)
        }
        e.closePath();
        return e
    }
});
FR.Chart.BarHighLightStyle = FR.extend(FR.Chart.HighLightStyle, {
    initConstants: function (a) {
        a = a || {};
        this.isHorizontal = !!a.isHorizontal;
        FR.Chart.BarHighLightStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.BarHighLightStyle();
        a.rect = this.rect;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.isHorizontal = this.isHorizontal;
        a.plotBounds = this.plotBounds;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (d) {
        if (!d) {
            return
        }
        if (this.rect.width < 6 || this.rect.height < 6) {
            d.save();
            d.fillStyle = this.color;
            this.newRect.paint(d);
            d.restore();
            return
        }
        d.save();
        d.fillStyle = "rgba(255,255,255,0.00)";
        this.plotBounds.paint(d);
        d.clip();
        var e = FR.Chart.Color.brighter(this.color);
        d.shadowColor = "rgba(" + FR.Chart.Color.getColorArray(e) + ",0.75)";
        d.shadowBlur = 6;
        d.fillStyle = "white";
        this.newRect.paint(d);
        d.restore();
        d.save();
        var b = this.newRect.x;
        var g = this.newRect.y;
        var f = this.newRect.width;
        var a = this.newRect.height;
        var c;
        if (this.axisReversed) {
            if (this.isHorizontal) {
                c = d.createLinearGradient(b, g, b + f, g)
            } else {
                c = d.createLinearGradient(b, g + a, b, g)
            }
        } else {
            if (this.isHorizontal) {
                c = d.createLinearGradient(b + f, g, b, g)
            } else {
                c = d.createLinearGradient(b, g, b, g + a)
            }
        }
        c.addColorStop(0, this.getPaintStartColor());
        c.addColorStop(1, this.getPaintEndColor());
        d.fillStyle = c;
        this.newRect.paint(d);
        c = d.createLinearGradient(b, g, b, g + a);
        c.addColorStop(0, this.getHighLightStartColor());
        c.addColorStop(1, this.getHighLightEndColor());
        d.fillStyle = c;
        if (this.isHorizontal) {
            this.getHighLightHorizontalShape(this.newRect).paint(d)
        } else {
            this.getHighLightShape(this.newRect).paint(d)
        }
        d.strokeStyle = "rgb(255,255,255)";
        d.lineWidth = 1;
        this.newRect.draw(d);
        d.restore()
    }
});
FR.Chart.StackedBarHighLightStyle = FR.extend(FR.Chart.HighLightStyle, {
    initConstants: function (a) {
        a = a || {};
        this.totalRect = a.rect;
        this.isHorizontal = !!a.isHorizontal;
        FR.Chart.StackedBarHighLightStyle.superclass.initConstants.apply(this, [a])
    }, clone: function (b) {
        var a = new FR.Chart.StackedBarHighLightStyle();
        a.rect = this.rect;
        a.newRect = b;
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.isHorizontal = this.isHorizontal;
        a.plotBounds = this.plotBounds;
        a.totalRect = this.totalRect;
        a.isFirst = this.isFirst;
        a.axisReversed = this.axisReversed;
        a.alpha = this.alpha;
        a.borderColor = this.borderColor;
        a.borderWidth = this.borderWidth;
        return a
    }, paintStyle: function (d) {
        if (!d) {
            return
        }
        if (this.rect.width < 6 || this.rect.height < 6) {
            d.save();
            d.fillStyle = this.color;
            this.newRect.paint(d);
            d.restore();
            return
        }
        d.save();
        d.fillStyle = "rgba(255,255,255,0.00)";
        this.plotBounds.paint(d);
        d.clip();
        d.shadowColor = "rgba(197,197,197, 0.75)";
        d.shadowBlur = 6;
        d.fillStyle = "white";
        this.newRect.paint(d);
        d.restore();
        d.save();
        var b = this.totalRect.x;
        var f = this.totalRect.y;
        var e = this.totalRect.width;
        var a = this.totalRect.height;
        var c;
        if (this.axisReversed) {
            if (this.isHorizontal) {
                c = d.createLinearGradient(b, f, b + e, f)
            } else {
                c = d.createLinearGradient(b, f + a, b, f)
            }
        } else {
            if (this.isHorizontal) {
                c = d.createLinearGradient(b + e, f, b, f)
            } else {
                c = d.createLinearGradient(b, f, b, f + a)
            }
        }
        c.addColorStop(0, this.getPaintStartColor());
        c.addColorStop(1, this.getPaintEndColor());
        d.fillStyle = c;
        this.newRect.paint(d);
        d.restore()
    }, paintHighLight: function (c) {
        if (this.isFirst) {
            c.save();
            var b = this.totalRect.x;
            var e = this.totalRect.y;
            var d = this.totalRect.width;
            var a = this.totalRect.height;
            if (d < 6 || a < 6) {
                return
            }
            if (this.axisReversed) {
                grd = c.createLinearGradient(b, e + a, b, e);
                grd.addColorStop(0, this.getHighLightStartColor());
                grd.addColorStop(1, this.getHighLightEndColor());
                c.fillStyle = grd;
                if (this.isHorizontal) {
                    this.getHighLightHorizontalShape(this.totalRect).paint(c)
                } else {
                    this.getHighLightShape(this.totalRect).paint(c)
                }
            } else {
                grd = c.createLinearGradient(b, e, b, e + a);
                grd.addColorStop(0, this.getHighLightStartColor());
                grd.addColorStop(1, this.getHighLightEndColor());
                c.fillStyle = grd;
                if (this.isHorizontal) {
                    this.getHighLightHorizontalShape(this.totalRect).paint(c)
                } else {
                    this.getHighLightShape(this.totalRect).paint(c)
                }
            }
            c.strokeStyle = "rgb(255,255,255)";
            c.lineWidth = 1;
            this.totalRect.draw(c);
            c.restore()
        }
    }
});
FR.Chart.DonutOuterStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.arcShape = a.arcShape;
        this.newArc = this.arcShape;
        this.totalRadius = a.totalRadius
    }, clone: function (b) {
        var a = new FR.Chart.DonutOuterStyle();
        a.arcShape = this.arcShape;
        a.newArc = b;
        a.color = this.color;
        a.totalRadius = this.totalRadius;
        return a
    }, paintStyle: function (b) {
        if (!b) {
            return
        }
        b.save();
        var d = this.getShadeStartPoint();
        var c = this.getShadeEndPoint();
        var a = b.createLinearGradient(d.x, d.y, c.x, c.y);
        a.addColorStop(0, this.getPaintStartColor());
        a.addColorStop(1, this.getPaintEndColor());
        b.fillStyle = a;
        this.newArc.paint(b);
        b.restore()
    }, getShadeStartPoint: function () {
        var a = this.arcShape.x - this.totalRadius * Math.cos(Math.PI * 135 / 180);
        var b = this.arcShape.y - this.totalRadius * Math.sin(Math.PI * 135 / 180);
        return new FR.Chart.Point2D(a, b)
    }, getShadeEndPoint: function () {
        var a = this.arcShape.x - this.totalRadius * Math.cos(Math.PI * 315 / 180);
        var b = this.arcShape.y - this.totalRadius * Math.sin(Math.PI * 315 / 180);
        return new FR.Chart.Point2D(a, b)
    }, getPaintStartColor: function () {
        return FR.Chart.Color.brighterWithFactor(this.color, 0.5)
    }, getPaintEndColor: function () {
        return this.color
    }
});
FR.Chart.AreaHighLightStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.color = a.color;
        this.areaPath = a.areaPath;
        this.newArea = this.areaPath;
        this.axisReversed = a.axisReversed
    }, clone: function (b) {
        var a = new FR.Chart.AreaHighLightStyle();
        a.areaPath = this.areaPath;
        a.newArea = b;
        a.color = this.color;
        a.axisReversed = this.axisReversed;
        return a
    }, getStartColor: function () {
        var a = FR.Chart.Color.getColorArray(this.color);
        return "rgba(" + a + ",0.33" + ")"
    }, getEndColor: function () {
        var a = FR.Chart.Color.getColorArray(this.color);
        return "rgba(" + a + ",0" + ")"
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        var b = this.newArea.getBounds2D();
        if (isNaN(b.x) || isNaN(b.y) || isNaN(b.width) || isNaN(b.height)) {
            return
        }
        var c;
        if (this.axisReversed) {
            c = a.createLinearGradient(b.x, b.y + b.height, b.x, b.y)
        } else {
            c = a.createLinearGradient(b.x, b.y, b.x, b.y + b.height)
        }
        c.addColorStop(0, this.getStartColor());
        c.addColorStop(1, this.getEndColor());
        a.fillStyle = c;
        this.newArea.paint(a);
        a.restore()
    }
});
FR.Chart.AreaPlane3DStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.areaPath = a.areaPath;
        this.newArea = this.areaPath;
        this.color = a.color;
        this.avoidOriginDraw = !!a.avoidOriginDraw;
        this.axisReversed = a.axisReversed
    }, clone: function (b) {
        var a = new FR.Chart.AreaPlane3DStyle();
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.areaPath = this.areaPath;
        a.newArea = b;
        a.axisReversed = this.axisReversed;
        return a
    }, getShadeColor: function () {
        var b = FR.Chart.Color.getColorArray(this.color);
        var a = FR.Chart.Color.RGB2HSB(b[0], b[1], b[2]);
        return FR.Chart.Color.getColor(FR.Chart.Color.HSB2RGB(a[0], a[1] * 2, a[2] / 2))
    }, paintStyle: function (a) {
        if (!a) {
            return
        }
        if (this.animateGlyph) {
            a.save();
            if (this.axisReversed) {
                a.shadowOffsetY = 3
            } else {
                a.shadowOffsetY = -3
            }
            a.shadowOffsetX = 3;
            a.shadowColor = "rgb(122,122,122)";
            a.shadowBlur = 3;
            this.animateGlyph.info.paint(a, this.animateGlyph.getOutline4Fill());
            a.restore()
        }
    }
});
FR.Chart.ArcPlane3DStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.arcShape = a.arcShape;
        this.newArc = this.arcShape;
        this.color = a.color;
        this.avoidOriginDraw = !!a.avoidOriginDraw;
        this.totalRadius = FR.pick(a.totalRadius, 0);
        this.categoryCount = FR.pick(a.count, 1);
        this.paintCount = 0
    }, clone: function (b) {
        var a = new FR.Chart.ArcPlane3DStyle();
        a.color = this.color;
        a.avoidOriginDraw = this.avoidOriginDraw;
        a.arcShape = this.arcShape;
        a.newArc = b;
        a.totalRadius = this.totalRadius;
        a.categoryCount = this.categoryCount;
        a.paintCount = this.paintCount;
        return a
    }, getShadeStartColor: function () {
        return FR.Chart.Color.getShadeStartColor(this.color, 0.35)
    }, getShadeEndColor: function () {
        return FR.Chart.Color.getShadeEndColor(this.color, 0.35)
    }, paintStyle: function (b) {
        if (!b) {
            return
        }
        b.save();
        if (this.paintCount % 2 === 0) {
            b.shadowOffsetX = 3;
            b.shadowOffsetY = -3;
            b.shadowColor = "rgba(0, 0, 0, 0.25)";
            b.shadowBlur = 3;
            this.paintCount++
        }
        var e, d, h;
        if (this.arcShape.getExtent() <= 180 || this.categoryCount !== 1) {
            var g = this.arcShape.x;
            var f = this.arcShape.y;
            var a = (this.totalRadius === 0 ? this.arcShape.getRadius() : this.totalRadius);
            h = b.createRadialGradient(g, f, 0, g, f, a);
            h.addColorStop(0, this.getShadeStartColor());
            h.addColorStop(1, this.getShadeEndColor())
        } else {
            var c = this.arcShape.getHalfAngle();
            if (c >= 45 && c < 135) {
                e = this.arcShape.getPointWithAngle(90);
                d = this.arcShape.getBottomPoint();
                d.x = e.x
            } else {
                if (c >= 135 && c < 225) {
                    e = this.arcShape.getPointWithAngle(180);
                    d = this.arcShape.getLeftMostPoint();
                    d.y = e.y
                } else {
                    if (c >= 225 && c < 315) {
                        e = this.arcShape.getPointWithAngle(270);
                        d = this.arcShape.getTopPoint();
                        d.x = e.x
                    } else {
                        e = this.arcShape.getPointWithAngle(360);
                        d = this.arcShape.getRightMostPoint();
                        d.y = e.y
                    }
                }
            }
            h = b.createLinearGradient(e.x, e.y, d.x, d.y);
            h.addColorStop(0, this.getShadeEndColor());
            h.addColorStop(1, this.getShadeStartColor())
        }
        b.fillStyle = h;
        this.newArc.paint(b);
        b.restore()
    }
});
FR.Chart.Arc3DStyleBase = function (a) {
    this.baseShape = a
};
$.extend(FR.Chart.Arc3DStyleBase.prototype, {
    paintStyle: function (a) {
        if (!a) {
            return
        }
        a.save();
        a.shadowOffsetY = -5;
        a.shadowOffsetX = -5;
        a.shadowColor = "rgba(0, 0, 0, 0.45)";
        a.shadowBlur = 8;
        var d = this.baseShape.getPointWithAngle(45);
        var c = this.baseShape.getPointWithAngle(225);
        var b = a.createLinearGradient(d.x, d.y, c.x, c.y);
        b.addColorStop(0, "rgb(232, 229, 226)");
        b.addColorStop(1, "rgb(185, 182, 177)");
        a.fillStyle = b;
        this.baseShape.paint(a);
        a.restore()
    }
});
FR.Chart.ArcOuterBase = function (a, c, b) {
    this.radius = a;
    this.centerPoint = c;
    this.innerRadius = FR.pick(b, 0)
};
$.extend(FR.Chart.ArcOuterBase.prototype, {
    paintStyle: function (i) {
        if (!i) {
            return
        }
        var h = this.centerPoint.x;
        var g = this.centerPoint.y;
        var e = FR.Chart.Color.getColorArray("rgb(134,149,157)");
        var d = FR.Chart.Color.getColorArray("rgb(84,101,125)");
        var b = FR.Chart.Color.getColorArray("rgb(189,189,189)");
        i.save();
        if (this.innerRadius === 0) {
            var c = i.createRadialGradient(h, g, 0, h, g, this.radius);
            c.addColorStop(0, FR.Chart.Color.getColorWithAlpha(e, 0));
            c.addColorStop(0.85, FR.Chart.Color.getColorWithAlpha(e, 0));
            c.addColorStop(0.98, FR.Chart.Color.getColorWithAlpha(d, 0.1));
            c.addColorStop(1, FR.Chart.Color.getColorWithAlpha(d, 0.3));
            i.fillStyle = c;
            var a = new FR.Chart.Arc2D(h, g, this.radius, 0, 360);
            a.paint(i)
        } else {
            if (this.innerRadius / this.radius > 0.15) {
                var f = (this.innerRadius - 0.1 * this.radius) / this.radius;
                var c = i.createRadialGradient(h, g, 0, h, g, this.radius);
                c.addColorStop(0, FR.Chart.Color.getColorWithAlpha(b, 0));
                c.addColorStop(f, FR.Chart.Color.getColorWithAlpha(b, 0));
                c.addColorStop(f, FR.Chart.Color.getColorWithAlpha(b, 0.15));
                c.addColorStop(this.innerRadius / this.radius, FR.Chart.Color.getColorWithAlpha(b, 0));
                c.addColorStop(0.9, FR.Chart.Color.getColorWithAlpha(b, 0.05));
                c.addColorStop(1, FR.Chart.Color.getColorWithAlpha(b, 0.2));
                i.fillStyle = c;
                var a = new FR.Chart.Arc2D(h, g, this.radius, 0, 360);
                a.paint(i)
            }
        }
        i.restore()
    }
});
FR.Chart.Arc3DStyle = function (a) {
    this.arc2D = a
};
$.extend(FR.Chart.Arc3DStyle.prototype, {
    paintStyle: function (e) {
        if (!e) {
            return
        }
        if (this.arc2D && this.arc2D.getBounds2D()) {
            var g = this.arc2D.getBounds2D();
            if (FR.Chart.GraphHelper.isBoundsNaN(g)) {
                return
            }
            var f = g.width;
            var d = g.height;
            if (f < 10 || d < 10) {
                return
            }
            e.save();
            var c = parseInt(g.x);
            var h = parseInt(g.y);
            var b = parseInt(f / 2);
            var a = e.createRadialGradient(c + b, h + b, 0, c + b, h + b, b);
            a.addColorStop(0, "rgba(0, 0, 0, 0)");
            a.addColorStop(0.88, "rgba(0, 0, 0, 0)");
            a.addColorStop(0.92, "rgba(0, 0, 0, 0.3)");
            a.addColorStop(1, "rgba(0, 0, 0, 0.8)");
            e.fillStyle = a;
            this.arc2D.paint(e);
            e.restore()
        }
    }
});
FR.Chart.ArcHighLightChart = function (a) {
    this.shape = a
};
$.extend(FR.Chart.ArcHighLightChart.prototype, {
    paintStyle: function (n) {
        if (this.shape) {
            var a = this.shape.getBounds2D();
            if (FR.Chart.GraphHelper.isBoundsNaN(a)) {
                return
            }
            if (a.width < 4 || a.height < 4) {
                return
            }
            if (!n) {
                return
            }
            n.save();
            var l = this.shape.x;
            var k = this.shape.y;
            var b = a.width;
            var g = b / 2;
            var m = n.createRadialGradient(l, k, 0, l, k, g);
            m.addColorStop(0, "rgba(255, 255, 255, 0.2)");
            m.addColorStop(1, "rgba(255, 255, 255, 0)");
            n.fillStyle = m;
            this.shape.paint(n);
            var c = n.createRadialGradient(l - g, k, 0, l - g, k, b);
            c.addColorStop(0, "rgba(255, 255, 255, 0.4)");
            c.addColorStop(0.75, "rgba(255, 255, 255, 0.1)");
            c.addColorStop(1, "rgba(255, 255, 255, 0)");
            n.fillStyle = c;
            n.beginPath();
            var i = Math.atan(159 / 17) * 180 / Math.PI;
            var h = i * Math.PI / 180;
            var e = (360 - i) * Math.PI / 180;
            n.arc(l, k, g, h, e, false);
            var f = Math.acos(3 / 4) * 180 / Math.PI;
            var j = f * Math.PI / 180;
            var d = (360 - f) * Math.PI / 180;
            n.arc(l - g, k, g * 1.5, d, j, false);
            n.fill();
            n.restore()
        }
    }
});
FR.Chart.GeneralInfo = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesAttrAlpha = new FR.Chart.AttrAlpha(FR.pick(a.seriesAttrAlpha, {alpha: a.alpha}));
        this.seriesAttrBorder = new FR.Chart.AttrBorder(FR.pick(a.border, a.seriesAttrBorder));
        this.seriesAttrBackground = new FR.Chart.AttrBackground(FR.pick(a.brush, a.seriesAttrBackground))
    }, getBackground: function () {
        return this.seriesAttrBackground.seriesBackground
    }, setBackground: function (a) {
        this.seriesAttrBackground.seriesBackground = a
    }, getBorderStyle: function () {
        return this.seriesAttrBorder.getBorderStyle()
    }, setBorderStyle: function (a) {
        this.seriesAttrBorder.setBorderStyle(a)
    }, getBorderColor: function () {
        return this.seriesAttrBorder.borderColor
    }, setBorderColor: function (a) {
        this.seriesAttrBorder.borderColor = a
    }, isRoundBorder: function () {
        return this.seriesAttrBorder.isRoundBorder
    }, setRoundBorder: function (a) {
        this.seriesAttrBorder.isRoundBorder = a
    }, getAlpha: function () {
        return this.seriesAttrAlpha.alpha
    }, setAlpha: function (a) {
        this.seriesAttrAlpha.alpha = a
    }, paint: function (a, b) {
        if (!a) {
            return
        }
        if (b) {
            a.save();
            a.globalAlpha = this.seriesAttrAlpha.alpha;
            if (this.seriesAttrBackground.seriesBackground) {
                this.seriesAttrBackground.seriesBackground.paint(a, b)
            }
            if (this.seriesAttrBorder.borderStyle != FR.Chart.Constants.LINE_NONE && this.seriesAttrBorder.borderColor != null) {
                a.strokeStyle = this.seriesAttrBorder.borderColor;
                a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.seriesAttrBorder.borderStyle);
                b.draw(a)
            }
            a.restore()
        }
    }, paintWithOutBorder: function (a, b) {
        if (!a) {
            return
        }
        if (b) {
            a.save();
            a.globalAlpha = this.seriesAttrAlpha.alpha;
            if (!this.seriesAttrBackground) {
                return
            }
            if (this.seriesAttrBackground.seriesBackground) {
                this.seriesAttrBackground.seriesBackground.paint(a, b)
            }
            a.restore()
        }
    }, paintOnlyBorder: function (a, b) {
        if (!a) {
            return
        }
        if (b) {
            a.save();
            a.globalAlpha = this.seriesAttrAlpha.alpha;
            if (!this.seriesAttrBorder) {
                return
            }
            if (this.seriesAttrBorder.borderStyle != FR.Chart.Constants.LINE_NONE && this.seriesAttrBorder.borderColor != null) {
                a.strokeStyle = this.seriesAttrBorder.borderColor;
                a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.seriesAttrBorder.borderStyle);
                b.draw(a)
            }
            a.restore()
        }
    }, dealCondition: function (f, b, a) {
        var e = f.getConditionAttr(new FR.Chart.AttrAlpha(), b);
        this.seriesAttrAlpha = e;
        var d = f.getConditionAttr(new FR.Chart.AttrBackground(), b, a);
        this.seriesAttrBackground = d;
        var c = f.getConditionAttr(new FR.Chart.AttrBorder(), b, a);
        this.seriesAttrBorder = c
    }, dealColorCondition: function (f, c, a) {
        var e = f.getConditionAttr(new FR.Chart.AttrAlpha(), c);
        this.seriesAttrAlpha = e;
        var b = f.getConditionAttr(new FR.Chart.AttrColor(), c, a);
        this.seriesAttrBackground = new FR.Chart.AttrBackground();
        this.seriesAttrBackground.seriesBackground = FR.Chart.ColorBackground.getInstance(b.getSeriesColor());
        var d = f.getConditionAttr(new FR.Chart.AttrBorder(), c, a);
        this.seriesAttrBorder = d
    }, dealConditionWithSeriesColor: function (d, b, a) {
        var c = d.getAttr(b).isContains(new FR.Chart.AttrBackground());
        if (c == null) {
            c = d.defaultAttr.isContains(new FR.Chart.AttrBackground());
            if (c == null) {
                c = FR.Chart.ConditionAttrFactory.createConditionAttr(new FR.Chart.AttrBackground(), b.categoryIndex, a)
            }
        }
        this.seriesAttrBackground = c
    }
});
FR.Chart.LineStyleInfo = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.seriesAttrAlpha = new FR.Chart.AttrAlpha(a.seriesAttrAlpha);
        this.seriesAttrBorder = new FR.Chart.AttrBorder(a.seriesAttrBorder);
        this.attrLineColor = new FR.Chart.AttrColor(a.attrLineColor);
        this.attrLineStyle = new FR.Chart.AttrLineStyle(a.attrLineStyle)
    }, paint: function (a, b) {
        if (!a) {
            return
        }
        if (b) {
            a.save();
            var c = FR.Chart.GraphHelper.getLineStyleSize(this.attrLineStyle.lineStyle);
            if (this.shadow != null && c > 0) {
                this.shadow.paint(a, b, c)
            }
            if (this.outerLight && c > 0) {
                this.outerLight.paint(a, b, c)
            }
            a.globalAlpha = this.seriesAttrAlpha.alpha;
            if (this.seriesAttrBorder && this.seriesAttrBorder.borderStyle != FR.Chart.Constants.LINE_NONE && this.seriesAttrBorder.borderColor != null) {
                a.strokeStyle = this.seriesAttrBorder.borderColor;
                a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.seriesAttrBorder.borderStyle);
                b.draw(a)
            }
            if (this.attrLineColor && this.attrLineColor.seriesColor != null && this.attrLineStyle && this.attrLineStyle.lineStyle != FR.Chart.Constants.LINE_NONE) {
                a.strokeStyle = this.attrLineColor.seriesColor;
                a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.attrLineStyle.lineStyle);
                b.draw(a)
            }
            a.restore()
        }
    }, dealCondition: function (f, c, b) {
        var d = f.getConditionAttr(new FR.Chart.AttrColor(), c, b);
        this.attrLineColor = d;
        var a = f.getConditionAttr(new FR.Chart.AttrLineStyle(), c, b);
        this.attrLineStyle = a;
        var e = f.getConditionAttr(new FR.Chart.AttrAlpha(), c, b);
        this.seriesAttrAlpha = e
    }
});
FR.Chart.ColorInfo = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function () {
        this.seriesAttrAlpha = new FR.Chart.AttrAlpha();
        this.seriesAttrBorder = new FR.Chart.AttrBorder();
        this.seriesAttrColor = new FR.Chart.AttrColor()
    }, setSeriesColor: function (a) {
        this.seriesAttrColor.setSeriesColor(a)
    }, getSeriesColor: function () {
        return this.seriesAttrColor.getSeriesColor()
    }, paint: function (a, b) {
        if (!a) {
            return
        }
        if (b) {
            a.save();
            a.globalAlpha = this.seriesAttrAlpha.getAlpha();
            if (this.getSeriesColor() != null) {
                a.fillStyle = this.getSeriesColor();
                b.paint(a)
            }
            if (this.seriesAttrBorder.borderStyle != FR.Chart.Constants.LINE_NONE && this.seriesAttrBorder.borderColor != null) {
                a.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.seriesAttrBorder.borderStyle);
                a.strokeStyle = this.seriesAttrBorder.borderColor;
                b.draw(a)
            }
            a.restore()
        }
    }, dealCondition: function (f, d, a) {
        var b = f.getConditionAttr(new FR.Chart.AttrColor(), d, a);
        this.setSeriesColor(b.getSeriesColor());
        var c = f.getConditionAttr(new FR.Chart.AttrBorder(), d, a);
        this.seriesAttrBorder.setBorderColor(c.getBorderColor());
        this.seriesAttrBorder.setBorderStyle(c.getBorderStyle());
        var e = f.getConditionAttr(new FR.Chart.AttrAlpha(), d);
        this.seriesAttrAlpha.alpha = e.alpha
    }
});
FR.Chart.ChartGlyphLayout = function () {
};
$.extend(FR.Chart.ChartGlyphLayout.prototype, {
    DEFAULT_WIDTH: 507,
    DEFAULT_HEIGHT: 340,
    DEFAULT_GAP: 8,
    MIN_GAP: 4,
    MAX_GAP: 16,
    INCRE_ONE_PIX: 100,
    WIDTH_GAP: 8,
    HEIGHT_GAP: 8,
    HEIGHT_GAP_SCALE: 0.02,
    doLayout: function (b) {
        if (b == null || b.getBounds() == null) {
            return
        }
        var a = new FR.Chart.Bounds(b.getBounds().x, b.getBounds().y, b.getBounds().width, b.getBounds().height);
        this.componentHeightGap = a.height * this.HEIGHT_GAP_SCALE;
        this.componentHeightGap = Math.min(this.MAX_GAP, this.componentHeightGap);
        this.componentHeightGap = Math.max(this.MIN_GAP, this.componentHeightGap);
        this._preMoreChangeChart(b, a);
        this._preGap4ChartBorder(b, a);
        this._preGap4ChartInPadding(a);
        this._pre4TimeSwitchSize(a);
        this._pre4DemoHeight(a);
        this._titleGlyphDoLayout(a, b.titleGlyph);
        this._calculatorDataSheetCateUnitLength(a, b);
        this._legendDoLayoutWithLeftBounds(a, b);
        this._makeSureDataSheetBounds(a, b);
        this._preTimeSwitchHeight4LeftBounds(a, b);
        this._preDemoChart4LeftBoundsHeight(a, b);
        this._plotDoLayout(a, b);
        this._dataSheetDoLayoutWithPlotGlyph(b)
    },
    _preMoreChangeChart: function (b, c) {
        if (b.isUseChangeChart || b.isUseDragRefresh) {
            var a = 20;
            c.y = c.y + a;
            c.height = c.height - a
        }
    },
    _preGap4ChartBorder: function (a, c) {
        var b = FR.Chart.GraphHelper.getLineStyleSize(a.info.seriesAttrBorder.borderStyle);
        c.x = c.x + b;
        c.y = c.y + b;
        c.width = c.width - b * 2;
        c.height = c.height - b * 2
    },
    _preGap4ChartInPadding: function (c) {
        var a = this.DEFAULT_GAP + (c.width - this.DEFAULT_WIDTH) / this.INCRE_ONE_PIX;
        this.WIDTH_GAP = Math.min(this.MAX_GAP, Math.max(this.MIN_GAP, a));
        var b = this.DEFAULT_GAP + (c.height - this.DEFAULT_HEIGHT) / this.INCRE_ONE_PIX;
        this.HEIGHT_GAP = Math.min(this.MAX_GAP, Math.max(this.MIN_GAP, b));
        c.x = c.x + this.WIDTH_GAP;
        c.y = c.y + this.HEIGHT_GAP;
        c.width = c.width - this.WIDTH_GAP * 2;
        c.height = c.height - this.HEIGHT_GAP * 2
    },
    _pre4TimeSwitchSize: function (c) {
        var a = c.height * FR.Chart.TimeSwitchGlyph.WIDGET_HEIGHT_SCALE;
        a = (a > FR.Chart.TimeSwitchGlyph.MIN_WIDGET_HEIGHT) ? a : FR.Chart.TimeSwitchGlyph.MIN_WIDGET_HEIGHT;
        this.timeSwitchHeight = (a < FR.Chart.TimeSwitchGlyph.MAX_WIDGET_HEIGHT) ? a : FR.Chart.TimeSwitchGlyph.MAX_WIDGET_HEIGHT;
        var b = c.width * FR.Chart.TimeSwitchGlyph.BUTTON_WIDTH_SCALE;
        b = (b > FR.Chart.TimeSwitchGlyph.BUTTOM_MIN_WIDTH) ? b : FR.Chart.TimeSwitchGlyph.BUTTOM_MIN_WIDTH;
        this.switchButtonWidth = (b < FR.Chart.TimeSwitchGlyph.BUTTON_MAX_WIDTH) ? b : FR.Chart.TimeSwitchGlyph.BUTTON_MAX_WIDTH
    },
    _pre4DemoHeight: function (b) {
        var a = b.height * FR.Chart.GlobalDemoGlyph.DEMO_HEIGHT_SCALE;
        a = (a > FR.Chart.GlobalDemoGlyph.MIN_DEMO_HEIGHT) ? a : FR.Chart.GlobalDemoGlyph.MIN_DEMO_HEIGHT;
        this.demoHeight = (a < FR.Chart.GlobalDemoGlyph.MAX_DEMO_HEIGHT) ? a : FR.Chart.GlobalDemoGlyph.MAX_DEMO_HEIGHT
    },
    _timeSwitchGlyphDoLayout: function (d) {
        var c = d.plotGlyph;
        if (!c || !c.xAxisGlyph || !c.xAxisGlyph.isZoom || !c.isNeedTimeSwitchWidget()) {
            return
        }
        var b = c.bounds;
        var a = b.x;
        if (c.yAxisGlyph && c.yAxisGlyph.bounds && !c.xAxisGlyph.axisReversed) {
            a = c.yAxisGlyph.bounds.x
        }
        if (c.secondAxisGlyph && c.secondAxisGlyph.bounds && c.xAxisGlyph.axisReversed) {
            a = c.secondAxisGlyph.bounds.x
        }
        if (!d.timeSwitchGlyph) {
            d.timeSwitchGlyph = new FR.Chart.TimeSwitchGlyph();
            d.timeSwitchGlyph.xAxisGlyph = c.xAxisGlyph;
            d.timeSwitchGlyph.timeSwitchArray = c.xAxisGlyph.timeSwitchArray
        }
        d.timeSwitchGlyph.bounds = new FR.Chart.Bounds(a, b.y - this.timeSwitchHeight - this.componentHeightGap, b.width, this.timeSwitchHeight);
        d.timeSwitchGlyph.switchButtonWidth = this.switchButtonWidth;
        d.timeSwitchGlyph.doLayout()
    },
    _titleGlyphDoLayout: function (e, a) {
        if (a == null || !a.text || !a.visible) {
            return
        }
        var d = a.preferredDimension(e.width, e.height);
        var b = 0;
        if (a.position == FR.Chart.Constants.LEFT) {
            b = e.x
        } else {
            if (a.position == FR.Chart.Constants.RIGHT) {
                b = e.x + e.width - d.width
            } else {
                b = e.x + (e.width - d.width) / 2
            }
        }
        var c = new FR.Chart.Bounds(b, e.y, d.width, d.height);
        a.bounds = FR.Chart.ChartUtils.rectangle2RoundRectangle(c, a.isRoundBorder());
        e.y = e.y + d.height + this.HEIGHT_GAP;
        e.height = e.height - d.height - this.HEIGHT_GAP
    },
    _makeSureDataSheetBounds: function (e, b) {
        var d = b.dataSheetGlyph;
        if (d == null) {
            return
        }
        var a = d.getPrefferedSize(b).height;
        var c = new FR.Chart.Bounds(e.x, e.y + e.height - a, e.width, a);
        e.height = e.height - a;
        d.bounds = c
    },
    _calculatorDataSheetCateUnitLength: function (h, b) {
        var d = b.dataSheetGlyph;
        if (d == null) {
            return
        }
        var g = new FR.Chart.Bounds(h.x, h.y, h.width, h.height);
        this._legendDoLayoutWithLeftBounds(g, b);
        this._justAxisDoLayout(g, b);
        var e = b.plotGlyph;
        var a = d.getBounds();
        var i = 0;
        if (e instanceof FR.Chart.CategoryPlotGlyph) {
            var f = e.xAxisGlyph.position;
            if (f == FR.Chart.Constants.TOP || f == FR.Chart.Constants.BOTTOM) {
                i = e.xAxisGlyph.getBounds().width / e.getCategoryCount()
            } else {
                var c = e.yAxisGlyph.getBounds().x + e.getBounds().x;
                i = (a.x + a.width - c) / e.getCategoryCount()
            }
        } else {
            if (e instanceof FR.Chart.StockPlotGlyph) {
                i = e.xAxisGlyph.unitLength
            }
        }
        d.setUnitLength(i)
    },
    _justAxisDoLayout: function (h, a) {
        var e = a.plotGlyph;
        if (e == null) {
            return
        }
        var i = e.getPreGap4AxisRightUnit();
        var c = e.getPreGap4AxisTopUnit();
        var d = a.dataSheetGlyph;
        var j = 0;
        if (d) {
            var k = e.getPreLeft4DataSheet();
            var b = d.getPrefferedSize(a).width;
            j = k > b ? 0 : b - k
        }
        var g = 0;
        if (e.xAxisGlyph && e.xAxisGlyph.isArrowShow) {
            g = 10
        }
        var f = 0;
        if (e.yAxisGlyph && e.yAxisGlyph.isArrowShow) {
            f = 5
        }
        e.bounds = new FR.Chart.Bounds(h.x + j, h.y + c + f, h.width - j - i - g, h.height - c - f);
        e.layoutAxisGlyph(-1)
    },
    _plotDoLayout: function (c, b) {
        var a = b.plotGlyph;
        if (a == null) {
            return
        }
        this._justAxisDoLayout(c, b);
        a.isStockChart = a.xAxisGlyph && a.xAxisGlyph.isZoom && a.isNeedTimeSwitchWidget();
        a.layoutDataSeriesGlyph();
        a.bounds = FR.Chart.ChartUtils.rectangle2RoundRectangle(a.bounds, a.isRoundBorder());
        this._timeSwitchGlyphDoLayout(b);
        this.demoPlotDoLayoutWithPlotBounds(b)
    },
    _dataSheetDoLayoutWithPlotGlyph: function (a) {
        var b = a.dataSheetGlyph;
        if (b) {
            b.doLayout(a.plotGlyph)
        }
    },
    _legendDoLayoutWithLeftBounds: function (t, k) {
        var g = k.legendGlyph;
        if (g == null) {
            return
        }
        if (k.plotGlyph && !FR.isEmpty(k.plotGlyph.mapName)) {
            var b = k.plotGlyph;
            var f = b.mapType != FR.Chart.MapType.Map_Normal;
            var j = b.isHeatMap;
            var r = b.isSvgMap;
            if (!r || (f && !j)) {
                g.layoutLegendAndRefreshChartBounds(t, this.WIDTH_GAP, this.HEIGHT_GAP);
                return
            }
            var s = g.position;
            var m = b.mapAreaColor;
            var l = new FR.Chart.TextAttr();
            if (g.font != null) {
                l.frFont = g.font
            } else {
                l.frFont = new FR.Chart.FRFont({fontName: "Microsoft YaHei"})
            }
            var c = this._getControlBarDimension(s, m, t, l);
            var d = false;
            var n = new FR.Chart.Bounds();
            if (s == FR.Chart.Constants.TOP || s == FR.Chart.Constants.BOTTOM) {
                var i = c.width + this.WIDTH_GAP * 2 + 30;
                d = i < t.width;
                n = new FR.Chart.Bounds(t.x, t.y, t.width - i, t.height)
            } else {
                var a = c.height + this.HEIGHT_GAP * 2 + 30;
                d = a < t.height;
                n = new FR.Chart.Bounds(t.x, t.y, t.width, t.height - a)
            }
            if (d) {
                var e = new FR.Chart.Dimension2D(g._getLegendWidth(n), g._getLegendHeight(n));
                var p = this._getLegendStartX(s, c, e, t);
                var o = this._getLegendStartY(s, c, e, t);
                var h = new FR.Chart.Bounds(p, o, c.width, c.height);
                var q;
                if (s == FR.Chart.Constants.TOP || s == FR.Chart.Constants.BOTTOM) {
                    q = new FR.Chart.Bounds(h.x + c.width + 22, h.y, e.width, e.height)
                } else {
                    q = new FR.Chart.Bounds(h.x, h.y + c.height + 22, e.width, e.height)
                }
                g.changeLegendBounds(q);
                this._makeBoundsInCenter(h, q, s);
                s = s == FR.Chart.Constants.RIGHT_TOP ? FR.Chart.Constants.RIGHT : s;
                k.mapControlBar = new FR.Chart.HeatMapControlBar(h, s, m, b.dataSeries, l);
                this._refreshChartBoundsWithControlBar(s, t, h, q)
            } else {
                g.layoutLegendAndRefreshChartBounds(t, this.WIDTH_GAP, this.HEIGHT_GAP)
            }
        } else {
            g.layoutLegendAndRefreshChartBounds(t, this.WIDTH_GAP, this.HEIGHT_GAP)
        }
    },
    _makeBoundsInCenter: function (c, g, a) {
        if (a == FR.Chart.Constants.TOP || a == FR.Chart.Constants.BOTTOM) {
            var f = c.height;
            var b = g.height;
            if (f > b) {
                g.y = c.y + (f - b) / 2
            } else {
                c.y = g.y + (b - f) / 2
            }
        } else {
            var d = c.width;
            var e = g.width;
            if (d > e) {
                g.x = c.x + (d - e) / 2
            } else {
                c.x = g.x + (e - d) / 2
            }
        }
    },
    _getControlBarDimension: function (a, c, d, b) {
        if (a == FR.Chart.Constants.TOP || a == FR.Chart.Constants.BOTTOM) {
            return this._getControlBarDimensionTopAndBottom(c, d, b)
        } else {
            return this._getControlBarDimensionLeftAndRight(c, d, b)
        }
    },
    _getControlBarDimensionTopAndBottom: function (h, f, i) {
        var b = FR.Chart.HeatMapControlBar.BAR_LONG;
        var n = FR.Chart.HeatMapControlBar.BAR_SHORT;
        var l = FR.Chart.HeatMapControlBar.BAR_GAP;
        var g = h.getAreaNumber();
        var d = i.frFont.size;
        var a = h.getMaxLabelWithIndex(0);
        var j = h.getMinLabelWithIndex(g - 1);
        var k = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, i).width;
        var e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(j, i).width;
        var c = (k + e) / 2 + b * g + l * (g - 1);
        var m = d * 2 + 10 + n;
        return new FR.Chart.Dimension2D(c, m)
    },
    _getControlBarDimensionLeftAndRight: function (g, d, h) {
        var a = FR.Chart.HeatMapControlBar.BAR_SHORT;
        var m = FR.Chart.HeatMapControlBar.BAR_LONG;
        var k = FR.Chart.HeatMapControlBar.BAR_GAP;
        var e = g.getAreaNumber();
        var b = h.frFont.size;
        var l = m * e + k * (e - 1) + b;
        var o = 0;
        var f = g.getNumberLabels();
        for (var c = 0; c < f.length; c++) {
            var j = f[c];
            o = Math.max(FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(j, h).width, o)
        }
        var n = o + 5 + a;
        n = Math.min(FR.Chart.LegendGlyph.MAX_LEFT_WIDTH * d.width, n);
        return new FR.Chart.Dimension2D(n, l)
    },
    _getLegendStartX: function (a, b, c, e) {
        var d = 22;
        if (a == FR.Chart.Constants.TOP || a == FR.Chart.Constants.BOTTOM) {
            return e.x + (e.width - b.width - c.width - 22) / 2
        } else {
            if (a == FR.Chart.Constants.LEFT) {
                return e.x
            } else {
                return e.x + e.width - Math.max(b.width, c.width)
            }
        }
    },
    _getLegendStartY: function (a, b, c, e) {
        var d = 22;
        if (a == FR.Chart.Constants.LEFT || a == FR.Chart.Constants.RIGHT) {
            return e.y + (e.height - b.height - c.height - 22) / 2
        } else {
            if (a == FR.Chart.Constants.RIGHT_TOP || a == FR.Chart.Constants.TOP) {
                return e.y
            } else {
                if (a == FR.Chart.Constants.BOTTOM) {
                    return e.y + e.height - Math.max(b.height, c.height)
                }
            }
        }
    },
    _refreshChartBoundsWithControlBar: function (a, d, b, c) {
        if (a == FR.Chart.Constants.TOP || a == FR.Chart.Constants.BOTTOM) {
            this._refreshChartBoundsWithControlBarTopAndBottom(a, d, b, c)
        } else {
            this._refreshChartBoundsWithControlBarLeftAndRight(a, d, b, c)
        }
    },
    _refreshChartBoundsWithControlBarTopAndBottom: function (b, e, c, d) {
        var a = Math.max(c.height, d.height);
        if (b == FR.Chart.Constants.TOP) {
            e.y += a
        }
        e.height -= a
    },
    _refreshChartBoundsWithControlBarLeftAndRight: function (a, e, b, d) {
        var c = Math.max(b.width, d.width);
        if (a == FR.Chart.Constants.LEFT) {
            e.x += c
        }
        e.width -= c
    },
    _preDemoChart4LeftBoundsHeight: function (c, b) {
        var a = b.plotGlyph;
        if (a && a.xAxisGlyph && a.xAxisGlyph.isZoom) {
            c.height = c.height - this.demoHeight
        }
    },
    _preTimeSwitchHeight4LeftBounds: function (c, b) {
        var a = b.plotGlyph;
        if (!a || !a.xAxisGlyph || !a.xAxisGlyph.isZoom || !a.isNeedTimeSwitchWidget()) {
            return
        }
        c.y += this.timeSwitchHeight + this.componentHeightGap;
        c.height -= this.timeSwitchHeight + this.componentHeightGap
    },
    demoPlotDoLayoutWithPlotBounds: function (a) {
        var f = a.plotGlyph;
        if (f && f.xAxisGlyph && f.xAxisGlyph.isZoom) {
            var i = new FR.Chart.GlobalDemoGlyph();
            if (a.timeSwitchGlyph) {
                i.timeSwitchGlyph = a.timeSwitchGlyph
            }
            if (a.preChartGlyph) {
                i.dragStyle = a.preChartGlyph.dragStyle;
                i.isScroll = a.preChartGlyph.isScroll
            }
            i.demoPlot = a.smallDemoPlotGlyph;
            i.xAxisGlyph = f.xAxisGlyph;
            i.yAxisGlyph = f.yAxisGlyph;
            a.preChartGlyph = i;
            var d = f.bounds;
            var c = i.demoPlot;
            var b = 0;
            if (f.xAxisGlyph && f.xAxisGlyph.bounds) {
                b = f.xAxisGlyph.position == FR.Chart.Constants.TOP ? 0 : f.xAxisGlyph.bounds.height
            }
            var h = new FR.Chart.Bounds(d.x, d.y + d.height + b + FR.Chart.PreChartGlyph.PRE_CATE_GAP, d.width, this.demoHeight);
            c.bounds = h;
            c.bounds.height = c.bounds.height - FR.Chart.PreChartGlyph.MOVE_BACKGROUND_HEIGHT;
            c.layoutAxisGlyph(-1);
            c.layoutDemoGlyph();
            i.bounds = new FR.Chart.Bounds(a.plotGlyph.xAxisGlyph.bounds.x, h.y, a.plotGlyph.xAxisGlyph.bounds.width, h.height);
            var g = f.yAxisGlyph.position;
            var e = f.yAxisGlyph.bounds;
            if (g == FR.Chart.Constants.LEFT) {
                i.bounds.x = e.x + e.width
            } else {
                if (g == FR.Chart.Constants.RIGHT) {
                    i.bounds.x = e.x - f.yAxisGlyph.axisGridLength
                }
            }
            i.doLayout()
        }
    }
});
FR.Chart.ChartAlertValue = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.formula = a.formula;
        this.attrLineColor = new FR.Chart.AttrColor(a.attrLineColor);
        this.attrLineStyle = new FR.Chart.AttrLineStyle(a.attrLineStyle);
        this.alertPosition = FR.pick(FR.Chart.ChartUtils.getPosition(a.alertPosition), FR.Chart.Constants.LEFT);
        this.alertContent = FR.pick(a.alertContent, FR.i18nText("Chart-Chart_Alert"));
        this.alertLineAlpha = FR.pick(a.alertLineAlpha, 1);
        this.alertFont = a.alertFont == undefined ? "" : new FR.Chart.FRFont(a.alertFont)
    }
});
FR.Chart.ConditionAttr = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (d) {
        d = d || {};
        this.attrList = [];
        if (d.attrList) {
            var c = d.attrList;
            for (var b = 0; b < c.length; b++) {
                this.attrList.push(new FR.Chart[c[b].attrType](c[b].attr))
            }
        }
        this.name = d.name;
        this.conditions = [];
        this.joins = [];
        if (d.attrConditions) {
            var a = d.attrConditions;
            if (a.conditions) {
                for (var b = 0; b < a.conditions.length; b++) {
                    var e = new FR.Chart.Condition(a.conditions[b]);
                    this.conditions.push(e)
                }
            }
            if (a.joins) {
                for (var b = 0; b < a.joins.length; b++) {
                    var e = new FR.Chart.Condition(a.joins[b]);
                    this.joins.push(e)
                }
            }
        }
        this.conditionDataSeries = d.ConditionDataSeries == undefined ? null : this.initsConditionDataSeries(d.ConditionDataSeries);
        this.conditionDataPoint = d.ConditionDataPoint == undefined ? null : this.initsConditionDataPoint(d.ConditionDataPoint)
    }, initConditionSeriesAndPoints: function (e) {
        var h = [];
        var j = [];
        for (var f = 0; f < e.length; f++) {
            var g = e[f];
            if (this.equalsAllConditions(g)) {
                h.push(g.seriesIndex)
            }
            for (var d = 0, b = g.getDataPointCount(); d < b; d++) {
                var a = g.points[d];
                if (this.equalsAllConditions(a)) {
                    var c = {series: g.seriesIndex, category: a.categoryIndex};
                    j.push(c)
                }
            }
        }
        this.conditionDataSeries = this.initsConditionDataSeries(h);
        this.conditionDataPoint = this.initsConditionDataPoint(j)
    }, equalsAllConditions: function (result) {
        var flag = false;
        var count = this.conditions.length;
        for (var i = 0; i < count; i++) {
            var condition = this.conditions[i];
            var join = 0;
            if (i !== 0) {
                join = this.joins[i]
            }
            if (i === 0) {
                flag = condition.eval(result)
            } else {
                if (join === 0) {
                    flag = flag && condition.eval(result)
                } else {
                    flag = flag || condition.eval(result)
                }
            }
        }
        return flag
    }, initsConditionDataSeries: function (c) {
        var a = [];
        for (var b = 0; b < c.length; b++) {
            a[b] = c[b]
        }
        return a
    }, initsConditionDataPoint: function (d) {
        var a = [];
        for (var b = 0; b < d.length; b++) {
            var c = d[b];
            a[b] = [];
            a[b][0] = c.series;
            a[b][1] = c.category
        }
        return a
    }, getAttr: function (a) {
        if (a >= this.attrList.length) {
            return null
        }
        return this.attrList[a]
    }, addAttr: function (a) {
        this.attrList.push(a)
    }, isContains: function (b) {
        for (var a = 0; a < this.attrList.length; a++) {
            if (this.getAttr(a) != null && this.getAttr(a).equals(b)) {
                return this.getAttr(a)
            }
        }
        return null
    }, removeAttr: function (b) {
        for (var a = 0; a < this.attrList.length; a++) {
            if (this.getAttr(a) != null && this.getAttr(a).equals(b)) {
                this.attrList.splice(a, 1)
            }
        }
    }, eval: function (b) {
        if (b instanceof FR.Chart.DataPoint) {
            for (var a = 0; this.conditionDataPoint && a < this.conditionDataPoint.length; a++) {
                if (this.conditionDataPoint[a][0] == b.seriesIndex && this.conditionDataPoint[a][1] == b.categoryIndex) {
                    return true
                }
            }
        } else {
            if (b instanceof FR.Chart.DataSeries) {
                for (var a = 0; this.conditionDataSeries && a < this.conditionDataSeries.length; a++) {
                    if (this.conditionDataSeries[a] == b.seriesIndex) {
                        return true
                    }
                }
            } else {
                if (typeof(b) == typeof(0)) {
                    for (var a = 0; this.conditionDataSeries && a < this.conditionDataSeries.length; a++) {
                        if (this.conditionDataSeries[a] == b) {
                            return true
                        }
                    }
                }
            }
        }
        return false
    }
});
FR.Chart.CustomAttr = FR.extend(FR.Chart.ConditionAttr, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.CustomAttr.superclass.initConstants.apply(this, [a]);
        this.renderer = FR.pick(a.renderer, 1);
        this.useRenderer = FR.pick(a.useRenderer, this.renderer)
    }, isStackedBarShape: function () {
        return this.renderer == FR.Chart.CustomAttr.BAR_STACK || this.renderer == FR.Chart.CustomAttr.BAR3D_STACK
    }, getAxisPosition: function () {
        var a = this.getAttr(0);
        return a == null ? FR.Chart.CustomAttr.Axis_LEFT : a.axisPosition
    }, getStackedSeriesList: function (series) {
        var seriesList = [];
        if (this.isStackedBarShape()) {
            for (var i = 0; i < series.length; i++) {
                var dataSeries = series[i];
                if (this.eval(dataSeries)) {
                    seriesList.push(dataSeries.seriesIndex)
                }
            }
        }
        return seriesList
    }
});
$.extend(FR.Chart.CustomAttr, {
    BAR_RENDERER: 1,
    LINE_RENDERER: 2,
    AREA_RENDERER: 4,
    BAR_STACK: 3,
    LINE_STACK: 5,
    AREA_STACK: 6,
    BAR3D: 7,
    BAR3D_STACK: 8,
    Axis_LEFT: "LEFT",
    Axis_RIGHT: "RIGHT"
});
FR.Chart.MapHotAreaColor = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (b) {
        b = b || {};
        this.areaColors = [];
        if (b.areaColors) {
            for (var a = 0; a < b.areaColors.length; a++) {
                this.areaColors[a] = new FR.Chart.AreaColor(b.areaColors[a])
            }
        }
        FR.Chart.MapHotAreaColor.superclass.initConstants.apply(this, [b])
    }, getAreaNumber: function () {
        return this.areaColors.length
    }, getNumberLabels: function () {
        var c = [];
        for (var b = 0; b < this.areaColors.length; b++) {
            var a = this.areaColors[b];
            c.push(Math.max(a.maxValue, a.minValue));
            if (b == this.areaColors.length - 1) {
                c.push(Math.min(a.minValue, a.maxValue))
            }
        }
        return c
    }, getColors: function () {
        var a = [];
        for (var b = 0; b < this.areaColors.length; b++) {
            a.push(this.areaColors[b].color)
        }
        return a
    }, getLabelWithIndex: function (c) {
        var b = this.areaColors[c];
        var d = b.minValue;
        var a = b.maxValue;
        return d + "--" + a
    }, getMaxLabelWithIndex: function (a) {
        if (this.areaColors && this.areaColors[a]) {
            return this.areaColors[a].maxValue
        }
    }, getMinLabelWithIndex: function (a) {
        if (this.areaColors && this.areaColors[a]) {
            return this.areaColors[a].minValue
        }
    }, getColorWithValue: function (e) {
        var b = "rgb(255, 255, 255)";
        for (var c = 0; c < this.areaColors.length; c++) {
            var a = this.areaColors[c];
            var d = Math.min(a.minValue, a.maxValue);
            var f = Math.max(a.minValue, a.maxValue);
            if (d <= e && e <= f) {
                b = a.color;
                break
            }
        }
        return b
    }, getColorIndexWithValue: function (e) {
        var b = 0;
        for (var c = 0; c < this.areaColors.length; c++) {
            var a = this.areaColors[c];
            var d = Math.min(a.minValue, a.maxValue);
            var f = Math.max(a.minValue, a.maxValue);
            if (d <= e && e <= f) {
                b = c;
                break
            }
        }
        return b
    }, getColorByIndex: function (a) {
        if (a < this.areaColors.length) {
            return this.areaColors[a].color
        }
        return "rgb(255,255,255)"
    }
});
FR.Chart.AreaColor = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.minValue = FR.pick(a.minValue, 0);
        this.maxValue = FR.pick(a.maxValue, 0);
        this.color = FR.pick(a.color, "rgb(0, 0, 0)");
        FR.Chart.AreaColor.superclass.initConstants.apply(this, [a])
    }
});
FR.Chart.MapAreaValue = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (b) {
        b = b || {};
        this.titleValues = [];
        if (b.titleValues && b.titleValues.length > 0) {
            for (var a = 0; a < b.titleValues.length; a++) {
                this.titleValues[a] = new FR.Chart.MapTitleValue(b.titleValues[a])
            }
        }
    }, isTitleValueNull: function () {
        if (this.titleValues.length <= 0) {
            return true
        }
        var b = true;
        for (var d = 0, c = this.titleValues.length; d < c; d++) {
            var a = this.titleValues[d];
            if (!FR.isEmpty(a.title)) {
                b = false;
                break
            }
        }
        return b
    }, getTitleValueByIndex: function (a) {
        return this.titleValues[a]
    }, getFirstTitleValue: function () {
        if (this.getTitleValueByIndex(0)) {
            return this.getTitleValueByIndex(0).value
        }
        return 0
    }, titleValueSize: function () {
        return this.titleValues.length
    }, getMaxValueExcept: function (a) {
        var d = 0;
        for (var b = 0, c = this.titleValueSize(); b < c; b++) {
            if (b != a) {
                d = Math.max(d, this.titleValues[b].value)
            }
        }
        return d
    }, addTitleValue: function (a) {
        this.titleValues.push(a)
    }
});
FR.Chart.MapTitleValue = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.title = a.title;
        this.value = a.value;
        this.percentValue = a.percentValue
    }
});
FR.Chart.ConditionCollection = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.attrList = new FR.Chart.HashMap(a.conditionAttrList);
        if (a.defaultAttr) {
            if (a.defaultAttr.conditionAttrType) {
                if (a.defaultAttr.conditionAttrType == "CustomAttr") {
                    this.defaultAttr = new FR.Chart.CustomAttr(a.defaultAttr)
                } else {
                    this.defaultAttr = new FR.Chart.ConditionAttr(a.defaultAttr)
                }
            }
        } else {
            this.defaultAttr = new FR.Chart.ConditionAttr()
        }
    }, add: function (a) {
        this.attrList.add(a)
    }, addAll: function (b, d) {
        for (var c = 0; c < b.length; c++) {
            var e = b[c];
            var a = new FR.Chart[e.conditionAttrType](e);
            a.initConditionSeriesAndPoints(d);
            this.attrList.add(a)
        }
    }, addAllWithDefault: function (c, e) {
        if (!c || !c.length || !e) {
            return
        }
        var b = c[0];
        this.defaultAttr = new FR.Chart[b.conditionAttrType](b);
        for (var d = 1; d < c.length; d++) {
            var f = c[d];
            var a = new FR.Chart[f.conditionAttrType](f);
            a.initConditionSeriesAndPoints(e);
            this.attrList.add(a)
        }
    }, getAttr: function (obj) {
        var ret = this.defaultAttr;
        for (var i = 0; i < this.attrList.length; i++) {
            if (this.attrList.get(i).eval(obj)) {
                ret = this.attrList.get(i)
            }
        }
        return ret
    }, getUnUsedSeriesIndex: function (series) {
        var seriesList = [];
        for (var seriesIndex = 0; seriesIndex < series.length; seriesIndex++) {
            var dataSeries = series[seriesIndex];
            var unUsed = true;
            for (var i = 0, count = this.getAttrSize(); i < count; i++) {
                var attr = this.getAttrByIndex(i);
                if (attr.eval(dataSeries)) {
                    unUsed = false;
                    break
                }
            }
            if (unUsed) {
                seriesList.push(dataSeries.seriesIndex)
            }
        }
        return seriesList
    }, getAttrSize: function () {
        return this.attrList.length
    }, getAttrByIndex: function (a) {
        return this.attrList.get(a)
    }, getAttrContainsCondition: function (obj, conditionInstance) {
        var ret = this.defaultAttr;
        for (var i = 0; i < this.attrList.length; i++) {
            if (this.attrList.get(i).eval(obj)) {
                if (this.attrList.get(i).isContains(conditionInstance) !== null) {
                    ret = this.attrList.get(i)
                }
            }
        }
        return ret
    }, isContainsAttr: function (obj, conditionInstance) {
        for (var i = 0; i < this.attrList.length; i++) {
            if (this.attrList.get(i).eval(obj)) {
                if (this.attrList.get(i).isContains(conditionInstance) !== null) {
                    return true
                }
            }
        }
        return false
    }, getConditionAttr: function (a, d, b) {
        var c = this.getAttrContainsCondition(d, a).isContains(a);
        if (c == null) {
            c = this.defaultAttr.isContains(a);
            if (c == null) {
                c = FR.Chart.ConditionAttrFactory.createConditionAttr(a, d, b)
            }
        }
        return c
    }
});
FR.Chart.LineMarkerIcon = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.lineStyle = a.lineStyle;
        this.alpha = FR.pick(a.alpha, 1);
        if (a.markerType) {
            this.marker = new FR.Chart[a.markerType](a.marker)
        } else {
            this.marker = null
        }
        this.iconSize = 6;
        this.background = FR.Chart.AbstractBackground.initBackground(a.background)
    }, setBackground: function (a) {
        this.background = a
    }, getBackground: function () {
        return this.background
    }, paint: function (k, i, h, f) {
        if (!k) {
            return
        }
        k.save();
        k.globalAlpha = this.alpha;
        var c = true;
        var b = this.background;
        var g = this.iconSize;
        if (f) {
            k.globalAlpha = 0.8;
            b = FR.Chart.ColorBackground.getInstance("rgb(128,128,128)")
        }
        var d = this.marker && this.marker.getMarkerType() == FR.Chart.Marker.NullMarker;
        var a = this.lineStyle && this.lineStyle != FR.Chart.Constants.LINE_NONE;
        if (d && a && b != null) {
            k.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.lineStyle);
            var j = new FR.Chart.Line2D(new FR.Chart.Point2D(i, h + g / 2), new FR.Chart.Point2D(i + g, h + g / 2));
            FR.Chart.GraphHelper.dealLine4JSDraw(j);
            b.draw(k, j, this.lineStyle);
            c = false
        }
        if (this.marker) {
            var e = this.marker.background;
            if (f) {
                this.marker.background = b
            }
            this.marker.size = g / 2;
            this.marker.paint(k, i + g / 2, h + g / 2);
            this.marker.background = e;
            c = false
        }
        if (c && b != null) {
            b.paint(k, new FR.Chart.Bounds(i, h, g, g))
        }
        k.restore()
    }
});
FR.Chart.LegendItem = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.label = a.label;
        this.lineMarkerIcon = a.lineMarkerIcon == undefined ? null : new FR.Chart.LineMarkerIcon(a.lineMarkerIcon);
        this.fontColor = a.fontColor;
        this.bounds = new FR.Chart.Bounds(a.bounds);
        this.LABEL_MARKER_GAP = 4;
        this.disable = false
    }, getBounds: function () {
        return this.bounds
    }, findOnMoveGlyph: function (a, c) {
        var b = this.getBounds();
        if (b && b.containsPoint(a.x, a.y)) {
            c.cursor = ChartHandler.POINTER;
            c._hasfound = true;
            c._lastHover = this
        }
    }, doOnMove: function (c, a) {
        var b = null;
        if (this.fontColor) {
            b = new FR.Chart.ColorBackground();
            b.color = this.fontColor
        } else {
            if (this.lineMarkerIcon) {
                b = this.lineMarkerIcon.background
            }
        }
        FR.Chart.Tooltip.dataPointTip(c, this.label, a, b)
    }, draw: function (h, c) {
        if (!this.bounds || !this.bounds.x || !this.bounds.y || !this.bounds.width || !this.bounds.height) {
            return
        }
        if (this.lineMarkerIcon) {
            this.lineMarkerIcon.paint(h, this.bounds.x, this.bounds.y, this.disable)
        }
        if (!h) {
            return
        }
        if (this.label) {
            h.save();
            var j = parseInt(c.size);
            h.font = c.style + " " + j + "px " + c.fontName;
            if (this.fontColor) {
                h.fillStyle = this.fontColor
            } else {
                h.fillStyle = c.color
            }
            h.globalAlpha = 1;
            if (this.disable) {
                h.globalAlpha = 0.8;
                h.fillStyle = "rgb(128,128,128)"
            }
            var b = this.prefferedSize(c);
            var a = this.label;
            var d = this.bounds.width;
            var f = this.bounds.x + c.size + this.LABEL_MARKER_GAP;
            var e = this.bounds.y;
            if (d < b.width) {
                if (this.drawInCutOrNot) {
                    a = this.getTextWhenNotEnoughWidth(a, d - c.size / 2 - this.LABEL_MARKER_GAP, c)
                }
            } else {
            }
            var g = FR.Chart.PaintUtils.isOffSetY4SomeFont(h, c);
            if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
                g = 0
            }
            var i = $("<div>" + a + "</div>").css("position", "absolute").css("font", h.font).css("z-index", 1).css("color", FR.Chart.Color.rgb2hex(h.fillStyle)).css("left", f).css("top", e + g);
            FR.Chart.DivCon.addDiv(FR.Chart.currentDivKey, i[0]);
            h.restore()
        }
    }, getTextWhenNotEnoughWidth: function (g, b, h) {
        if (!g) {
            return FR.Chart.Constants.ESP
        }
        var a = FR.Chart.GraphHelper.stringDimension("…", h, 0);
        if (a.width > b) {
            return FR.Chart.Constants.ESP
        }
        var j = b - a.width;
        var k = "";
        for (var e = 0; e < g.length; e++) {
            var f = g.charAt(e);
            var c = FR.Chart.GraphHelper.stringDimension(k, h, 0);
            var d = FR.Chart.GraphHelper.stringDimension(f, h, 0);
            if (c.width + d.width > j) {
                break
            }
            k += f
        }
        return k + FR.Chart.Constants.ESP
    }, prefferedSize: function (b) {
        var a = FR.Chart.GraphHelper.stringDimension(this.label, b, 0);
        a.width = Math.floor(a.width + b.size + this.LABEL_MARKER_GAP);
        a.height = Math.max(b.size, a.height);
        if (this.lineMarkerIcon) {
            this.lineMarkerIcon.iconSize = b.size
        }
        return a
    }
});
$.extend(FR.Chart.LegendItem, {});
FR.Chart.Projection = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.mode = a.mode || 2;
        this.elevation = a.elevation || 15;
        this.rotation = a.rotation || 20;
        this.focus = a.focus || 800;
        this.need_cal = FR.pick(a.need_cal, true);
        this.sin_theta_alpha = a.sin_theta_alpha || 0;
        this.cos_theta_alpha = a.cos_theta_alpha || 0;
        this.sin_theta_beta = a.sin_theta_beta || 0;
        this.cos_theta_beta = a.cos_theta_beta || 0
    }, setElevation: function (a) {
        this.elevation = a;
        this.need_cal = true
    }, setRotation: function (a) {
        this.rotation = a;
        this.need_cal = true
    }, projectee: function (a, c, b) {
        this.calculateSINCOS();
        if (this.mode == FR.Chart.Projection.ORTHO) {
            return this.ortho_projectee(a, c, b)
        } else {
            if (this.mode == FR.Chart.Projection.PERSPECTIVE) {
                return this.perspective_projectee(a, c, b)
            } else {
                if (this.mode == FR.Chart.Projection.RIGHT_ANGLE) {
                    return this.right_angle_projectee(a, c, b)
                } else {
                    return new FR.Chart.Point2D(a, c)
                }
            }
        }
    }, projecteeArc: function (g, d, f, c, b) {
        this.calculateSINCOS();
        var a = this.focus / (this.sin_theta_alpha * g + this.focus);
        var e = new FR.Chart.Ellipse(-d * a, -d * a * this.sin_theta_alpha + g * this.cos_theta_alpha * a, 2 * d * a, 2 * d * a * this.sin_theta_alpha, f + this.rotation, c, !!b);
        return e
    }, calculateSINCOS: function () {
        if (!this.need_cal) {
            return
        }
        this.sin_theta_alpha = Math.sin(this.elevation * Math.PI / 180);
        this.cos_theta_alpha = Math.cos(this.elevation * Math.PI / 180);
        this.sin_theta_beta = Math.sin(-this.rotation * Math.PI / 180);
        this.cos_theta_beta = Math.cos(-this.rotation * Math.PI / 180);
        this.need_cal = false
    }, perspective_projectee: function (a, f, e) {
        var c = a * this.cos_theta_beta + e * this.sin_theta_beta;
        var b = -a * this.sin_theta_alpha * this.sin_theta_beta + f * this.cos_theta_alpha + e * this.sin_theta_alpha * this.cos_theta_beta;
        var d = this.focus / (this.cos_theta_alpha * this.sin_theta_beta * a + this.sin_theta_alpha * f - this.cos_theta_alpha * this.cos_theta_beta * e + this.focus);
        return new FR.Chart.Point2D(c * d, b * d)
    }, ortho_projectee: function (a, e, d) {
        var c = a * this.cos_theta_beta + d * this.sin_theta_beta;
        var b = -a * this.sin_theta_alpha * this.sin_theta_beta + e * this.cos_theta_alpha + d * this.sin_theta_alpha * this.cos_theta_beta;
        return new FR.Chart.Point2D(c, b)
    }, right_angle_projectee: function (a, e, d) {
        var c = a + d * this.sin_theta_beta * 0.5;
        var b = e + d * this.sin_theta_alpha * 0.5;
        return new FR.Chart.Point2D(c, b)
    }, projecteeDeep: function (a) {
        this.calculateSINCOS();
        if (this.sin_theta_alpha < 0.01) {
            return a * 2
        } else {
            return a * 2 / this.sin_theta_alpha
        }
    }, projecteeRY: function (a, c, b) {
        this.calculateSINCOS();
        if (this.mode == FR.Chart.Projection.ORTHO) {
            return (c + a * this.sin_theta_alpha * this.sin_theta_beta - b * this.sin_theta_alpha * this.cos_theta_beta) / this.cos_theta_alpha
        } else {
            if (this.mode == FR.Chart.Projection.PERSPECTIVE) {
                return (a * c * this.cos_theta_alpha * this.sin_theta_beta + c * this.focus - b * c * this.cos_theta_alpha * this.cos_theta_beta + a * this.sin_theta_alpha * this.focus - b * this.sin_theta_alpha * this.cos_theta_beta * this.focus) / (this.focus * this.cos_theta_alpha - this.sin_theta_alpha * c)
            } else {
                if (this.mode == FR.Chart.Projection.RIGHT_ANGLE) {
                    return c - b * this.sin_theta_alpha * 0.5
                } else {
                    return c
                }
            }
        }
    }, projecteeRX: function (a, c, b) {
        this.calculateSINCOS();
        if (this.mode == FR.Chart.Projection.ORTHO) {
            return (a - b * this.sin_theta_beta) / this.cos_theta_beta
        } else {
            if (this.mode == FR.Chart.Projection.PERSPECTIVE) {
                return (a * (this.focus + this.sin_theta_alpha * c - this.cos_theta_alpha * this.cos_theta_beta) - b * this.sin_theta_beta * this.focus) / (cos_theta_beta * focus - a * cos_theta_alpha * sin_theta_beta)
            } else {
                if (this.mode == FR.Chart.Projection.RIGHT_ANGLE) {
                    return a - b * this.sin_theta_beta * 0.5
                } else {
                    return a
                }
            }
        }
    }
});
$.extend(FR.Chart.Projection, {ORTHO: 0, PERSPECTIVE: 1, RIGHT_ANGLE: 2});
FR.Chart.Condition = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        this.leftValue = FR.pick(a.leftValue, "");
        this.rightValue = FR.pick(a.rightValue, "");
        this.compare = FR.pick(a.compare, FR.Chart.Compare.EQUALS)
    }, eval: function (a) {
        var b = a.toResult(this.leftValue);
        switch (this.compare) {
            case FR.Chart.Compare.EQUALS:
                return b == this.rightValue;
                break;
            case FR.Chart.Compare.NOT_EQUAL:
                return b != this.rightValue;
                break;
            case FR.Chart.Compare.GREATER_THAN:
                return b > this.rightValue;
                break;
            case FR.Chart.Compare.GREATER_THAN_OR_EQUAL:
                return b >= this.rightValue;
                break;
            case FR.Chart.Compare.LESS_THAN:
                return b < this.rightValue;
                break;
            case FR.Chart.Compare.LESS_THAN_OR_EQUAL:
                return b <= this.rightValue;
                break;
            default:
                return false
        }
    }
});
FR.Chart.AxisGlyph = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.titleGlyph = a.titleGlyph == undefined ? null : new FR.Chart.TextGlyph(a.titleGlyph);
        this.isZoom = FR.pick(a.isZoom, false);
        if (FR.Browser.isIE8Before()) {
            this.isZoom = false
        }
        this.axisReversed = FR.pick(a.axisReversed, false);
        this.tickMarkType = FR.pick(a.tickMarkType, FR.Chart.Constants.TICK_MARK_OUTSIDE);
        this.secTickMarkType = FR.pick(a.secTickMarkType, FR.Chart.Constants.TICK_MARK_NONE);
        this.position = FR.pick(FR.Chart.ChartUtils.getPosition(a.position), FR.Chart.Constants.BOTTOM);
        this.mainGridStyle = FR.pick(a.mainGridStyle, FR.Chart.Constants.LINE_NONE);
        this.mainGridColor = a.mainGridColor;
        this.lineColor = FR.pick(a.lineColor, "rgb(176,176,176)");
        this.lineStyle = FR.pick(a.lineStyle, FR.Chart.Constants.LINE_THIN);
        this.textAttr = new FR.Chart.TextAttr(a.textAttr);
        if (a.font) {
            this.textAttr.frFont = new FR.Chart.FRFont(a.font);
            this.textAttr.rotation = FR.pick(a.rotation, 0);
            this.textAttr.alignText = FR.pick(a.alignText, 0)
        }
        this.format = a.format;
        this.labelNumber = FR.pick(a.labelNumber, a.gap, 0);
        this.isShowAxisLabel = FR.pick(a.isShowAxisLabel, true);
        this.isLabelWrap = FR.pick(a.isLabelWrap, false);
        this.isArrowShow = a.isArrowShow;
        this.isCustomMinValue = a.isCustomMinValue;
        this.minValue = FR.pick(a.minValue, 0);
        this.isCustomMaxValue = a.isCustomMaxValue;
        this.maxValue = FR.pick(a.maxValue, 0);
        this.isCustomMainUnit = a.isCustomMainUnit;
        this.tickLength = FR.pick(a.tickLength, 0);
        this.isCustomSecUnit = a.isCustomSecUnit;
        this.smallTickLength = FR.pick(a.smallTickLength, 0);
        this.drawBetweenTick = a.drawBetweenTick;
        this.titleDim = new FR.Chart.Dimension2D(0, 0);
        this.startLabelDim = new FR.Chart.Dimension2D(0, 0);
        this.endLabelDim = new FR.Chart.Dimension2D(0, 0);
        this.plotZeroBounds = null;
        this.plotLastBounds = null;
        this.tooltipLabelBoundsList = [];
        this.tooltipLabelList = [];
        this.MAX_AXIS_LABEL_HEIGHT = 0.28;
        this.MAX_AXIS_LABEL_WIDTH = 0.28;
        this.TOP_AND_DOWN_GAP = 6;
        this.ELLIPSIS = "...";
        this.unitLengthNoScale = null;
        this.bounds = null;
        this.originPoint = null;
        this.zoomForward = 0;
        this.zoomBackward = 0;
        this.unitLength = 0;
        this.axisLength = 0;
        this.axisGridLength = 0;
        this.axisLabelWidth = 8
    }, configLabels: function () {
    }, configAxisLabelsWithOptionData: function () {
    }, isNeedTimeSwitch: function () {
        return false
    }, dealPlotBoundsWithAxisLabel: function (b) {
        var a = this.getCateLabelWidth(b);
        if (a > 0) {
            a += FR.Chart.AxisGlyph.LINE_LABEL_GAP
        }
        a += this.getTickLengthShow();
        this.axisLabelWidth = a;
        this.calculateTitleDimesion();
        if (this.bounds == null) {
            this.bounds = b
        }
        this.calculateBoundsWidthOrientationAndTitle(b, a, this.titleDim);
        this.calBoundsWithMoreLabel4Cate(b)
    }, dealWithPlotBounds: function () {
        return 0
    }, dealPlotBoundsWithAxisTitle: function (a) {
        this.calculateTitleDimesion();
        if (this.bounds == null) {
            this.bounds = a
        }
        this.calculateBoundsWidthOrientationAndTitle(a, 0, this.titleDim);
        this.calBoundsWithMoreLabel4Cate(a)
    }, dealPlotBoundsWithLabel: function (b) {
        var a = this.getCateLabelWidth(b);
        if (a > 0) {
            a += FR.Chart.AxisGlyph.LINE_LABEL_GAP
        }
        a += this.getTickLengthShow();
        this.axisLabelWidth = a;
        this.calculateBoundsWidthOrientationAndTitle(b, a)
    }, getCateLabelWidth: function (b) {
        var a = this.getMaxLabelWidthAndInitStartEndLabelDim();
        if (this.shouldBeHeight()) {
            return Math.min(b.height * this.MAX_AXIS_LABEL_HEIGHT, a)
        } else {
            return Math.min(b.width * this.MAX_AXIS_LABEL_WIDTH, a)
        }
    }, dealPlotBoundsWithLabelInHorizontal: function (a) {
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            this._dealPlotBoundsLabelLeftRight(a)
        } else {
            this._dealPlotBoundsLabelTopBottom(a)
        }
    }, dealPlotBounds4AreaWrapInHorizontal: function (b) {
        var e = this.getOriginalArrowValue() - this.getOriginalCrossValue();
        if (e <= 0) {
            return
        }
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            var a = b.y - this.plotZeroBounds.y;
            var d = b.height / e;
            if (d / 2 > a) {
                b.y += d / 2 - a;
                b.height -= d / 2 - a
            }
            var f = this.plotZeroBounds.y + this.plotZeroBounds.height - b.y - b.height;
            if (d / 2 > f && Math.round(f) > 0) {
                b.height += d / 2 - f
            }
        } else {
            var c = this.plotZeroBounds.x + this.plotZeroBounds.width - b.x - b.width;
            var d = b.width / e;
            if (d / 2 > c) {
                b.width -= d / 2 - c
            }
            var f = b.x - this.plotZeroBounds.x;
            if (d / 2 > f) {
                b.x += d / 2 - f;
                b.width -= d / 2 - f
            }
        }
    }, _dealPlotBoundsLabelLeftRight: function (c) {
        var d = this.endLabelDim.height / 2;
        var b = c.y - this.plotZeroBounds.y;
        if (d > b) {
            c.y = c.y + d - b;
            c.height = c.height - d + b
        }
        var a = this.startLabelDim.height / 2;
        var e = this.plotZeroBounds.y + this.plotZeroBounds.height - c.y - c.height;
        if (a > e && Math.round(e) > 0) {
            c.height = c.height - a + e
        }
    }, _dealPlotBoundsLabelTopBottom: function (b) {
        var d = this.endLabelDim.width / 2;
        var c = this.plotZeroBounds.x + this.plotZeroBounds.width - b.x - b.width;
        if (d > c) {
            b.width = b.width - d + c
        }
        var a = this.startLabelDim.width / 2;
        var e = b.x - this.plotZeroBounds.x;
        if (a > e) {
            b.x = b.x + a - e;
            b.width = b.width - a + e
        }
    }, getTickLengthShow: function () {
        return Math.max(this._dealTickLengthInShow(this.tickMarkType, FR.Chart.AxisGlyph.MAIN_TICK_LENGTH), this._dealTickLengthInShow(this.secTickMarkType, FR.Chart.AxisGlyph.SEC_TICK_LENGTH))
    }, _dealTickLengthInShow: function (c, b) {
        var a = 0;
        switch (c) {
            case FR.Chart.Constants.TICK_MARK_OUTSIDE:
                a = b;
                break;
            case FR.Chart.Constants.TICK_MARK_CROSS:
                a = b / 2;
            default:
                break
        }
        return a
    }, calculateAxisGlyph: function (a) {
        this.init(a);
        this.calculateAxisLengthUnit();
        this.plotLastBounds = a
    }, calculateTitleDimesion: function () {
        if (this.titleGlyph) {
            this.titleDim = this.titleGlyph.preferredDimension()
        }
    }, calBoundsWithMoreLabel4Cate: function (a) {
    }, calculateBoundsWidthOrientationAndTitle: function (e, d, b) {
        var a = 0;
        var c = 0;
        if (b) {
            a = (b.width > 0) ? b.width + FR.Chart.AxisGlyph.LINE_LABEL_GAP : 0;
            c = (b.height > 0) ? b.height + FR.Chart.AxisGlyph.LINE_LABEL_GAP : 0
        }
        switch (this.position) {
            case FR.Chart.Constants.LEFT:
                e.x = e.x + a + d;
                e.width = e.width - d - a;
                break;
            case FR.Chart.Constants.BOTTOM:
                e.height = e.height - d - c;
                break;
            case FR.Chart.Constants.RIGHT:
                e.width = e.width - d - a;
                break;
            default:
                e.height = e.height - d - c;
                e.y = e.y + d + c;
                break
        }
    }, init: function (e) {
        var c = null;
        var a, b;
        var d = null;
        switch (this.position) {
            case FR.Chart.Constants.LEFT:
                a = e.height;
                b = e.width;
                d = new FR.Chart.Bounds(e.x - this.axisLabelWidth, e.y, this.axisLabelWidth, e.height);
                if (!this.axisReversed) {
                    c = new FR.Chart.Point2D(e.x, e.y + e.height)
                } else {
                    c = new FR.Chart.Point2D(e.x, e.y)
                }
                break;
            case FR.Chart.Constants.BOTTOM:
                a = e.width;
                b = e.height;
                d = new FR.Chart.Bounds(e.x, e.y + e.height, e.width, this.axisLabelWidth);
                if (!this.axisReversed) {
                    c = new FR.Chart.Point2D(e.x, e.y + e.height)
                } else {
                    c = new FR.Chart.Point2D(e.x + e.width, e.y + e.height)
                }
                break;
            case FR.Chart.Constants.RIGHT:
                a = e.height;
                b = e.width;
                d = new FR.Chart.Bounds(e.x + e.width, e.y, this.axisLabelWidth, e.height);
                if (!this.axisReversed) {
                    c = new FR.Chart.Point2D(e.x + e.width, e.y + e.height)
                } else {
                    c = new FR.Chart.Point2D(e.x + e.width, e.y)
                }
                break;
            default:
                a = e.width;
                b = e.height;
                d = new FR.Chart.Bounds(e.x, e.y - this.axisLabelWidth, e.width, this.axisLabelWidth);
                if (!this.axisReversed) {
                    c = new FR.Chart.Point2D(e.x, e.y)
                } else {
                    c = new FR.Chart.Point2D(e.x + e.width, e.y)
                }
                break
        }
        this.bounds = d;
        this.originPoint = c;
        this.axisLength = a;
        this.axisGridLength = b
    }, value2String: function (b) {
        var c = this.format;
        if (b > -1e-10 && b < 1e-10) {
            b = 0
        }
        b = FR.Chart.ChartUtils.accNumber(b);
        var a;
        if (c != null) {
            a = FR.contentFormat(b, c)
        } else {
            a = FR.Chart.ChartUtils.generalFormat(b)
        }
        return a
    }, getAxisLabelWidth: function (b) {
        var a = this.getAxisLabelDim(b);
        return this.shouldBeHeight() ? a.height : a.width
    }, getAxisLabelDim: function (b) {
        if (b == null) {
            return 0
        }
        var a = this.textAttr;
        if (a == null) {
            a = new FR.Chart.TextAttr()
        }
        return FR.Chart.TextUtils.calculateTextDimensionWithRotation(b, a)
    }, shouldBeHeight: function () {
        return this.position == FR.Chart.Constants.TOP || this.position == FR.Chart.Constants.BOTTOM
    }, getBounds: function () {
        return this.bounds
    }, getPointInBounds: function (a) {
        if (a < this.getCrossValue()) {
            a = this.getCrossValue()
        }
        if (a > this.getArrowValue()) {
            a = this.getArrowValue()
        }
        return this.getPoint2D(a)
    }, get2ValueLength: function (d, a) {
        var c = this.getPointInBounds(d);
        var b = this.getPointInBounds(a);
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            return Math.abs(c.y - b.y)
        } else {
            return Math.abs(c.x - b.x)
        }
    }, getTickIndex4Value: function (a) {
        return a
    }, getPoint2D: function (c) {
        var d = null;
        c = c - (this.isDraw4Demo ? this.minValue : this.getCrossValue());
        if (this.originPoint == null) {
            d = new FR.Chart.Point2D(this.bounds.x, this.bounds.y)
        }
        var b = this.isDraw4Demo ? this.unitLengthNoScale : this.unitLength;
        if (this.position == FR.Chart.Constants.LEFT) {
            if (this.bounds.y == this.originPoint.y || this.axisReversed) {
                d = new FR.Chart.Point2D(this.originPoint.x, this.originPoint.y + b * c)
            } else {
                d = new FR.Chart.Point2D(this.originPoint.x, this.originPoint.y - b * c)
            }
        } else {
            if (this.position == FR.Chart.Constants.RIGHT) {
                var e = this.axisReversed ? b * c : -b * c;
                d = new FR.Chart.Point2D(this.originPoint.x, this.originPoint.y + e)
            } else {
                var a = this.axisReversed ? -b * c : b * c;
                d = new FR.Chart.Point2D(this.originPoint.x + a, this.originPoint.y)
            }
        }
        return d
    }, getTickLine: function (d, b, c) {
        var a = this.getPoint2D(d);
        return this.getTickLineByCenterPoint(a, b, c)
    }, getTickLineByCenterPoint: function (g, e, j) {
        var c = new FR.Chart.Point2D(g.x - e, g.y);
        var f = new FR.Chart.Point2D(g.x + e, g.y);
        var b = new FR.Chart.Point2D(g.x, g.y - e);
        var h = new FR.Chart.Point2D(g.x, g.y + e);
        if (j == FR.Chart.Constants.TICK_MARK_CROSS) {
            var k = new FR.Chart.Point2D(g.x - e / 2, g.y);
            var a = new FR.Chart.Point2D(g.x + e / 2, g.y);
            var i = new FR.Chart.Point2D(g.x, g.y - e / 2);
            var d = new FR.Chart.Point2D(g.x, g.y + e / 2);
            if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
                return new FR.Chart.Line2D(k, a)
            } else {
                return new FR.Chart.Line2D(i, d)
            }
        } else {
            if (j == FR.Chart.Constants.TICK_MARK_INSIDE) {
                if (this.position == FR.Chart.Constants.LEFT) {
                    return new FR.Chart.Line2D(g, f)
                } else {
                    if (this.position == FR.Chart.Constants.TOP) {
                        return new FR.Chart.Line2D(g, h)
                    } else {
                        if (this.position == FR.Chart.Constants.RIGHT) {
                            return new FR.Chart.Line2D(g, c)
                        } else {
                            return new FR.Chart.Line2D(g, b)
                        }
                    }
                }
            } else {
                if (j == FR.Chart.Constants.TICK_MARK_OUTSIDE) {
                    if (this.position == FR.Chart.Constants.LEFT) {
                        return new FR.Chart.Line2D(g, c)
                    } else {
                        if (this.position == FR.Chart.Constants.TOP) {
                            return new FR.Chart.Line2D(g, b)
                        } else {
                            if (this.position == FR.Chart.Constants.RIGHT) {
                                return new FR.Chart.Line2D(g, f)
                            } else {
                                return new FR.Chart.Line2D(g, h)
                            }
                        }
                    }
                } else {
                    return new FR.Chart.Line2D(g, g)
                }
            }
        }
    }, findOnMoveGlyph: function (a, c) {
        this.tooltip = null;
        if (this.tooltipLabelBoundsList.length === 0) {
            return
        }
        for (var b = 0; b < this.tooltipLabelBoundsList.length; b++) {
            if (this.tooltipLabelBoundsList[b].containsPoint(a.x, a.y)) {
                c._hasfound = true;
                c._lastHover = this;
                this.tooltip = this.tooltipLabelList[b];
                return
            }
        }
    }, doOnMove: function (b, a) {
        FR.Chart.Tooltip.dataPointTip(b, this.tooltip, a, this.glyph && this.glyph.toolTipBackground)
    }, getLabelBounds4Point: function (j, d, b, i) {
        var h = this.textAttr;
        if (h == null) {
            h = new FR.Chart.TextAttr()
        }
        var e = FR.Chart.TextUtils.calculateTextDimensionWithRotation(b, h);
        var f = this.position;
        var c = FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow();
        var k = e.height;
        var a = e.width;
        if (this.shouldBeHeight()) {
            k = Math.min(k, this.axisLabelWidth - c)
        } else {
            a = Math.min(a, this.axisLabelWidth - c)
        }
        var g;
        if (f == FR.Chart.Constants.LEFT) {
            if (this.cubic && this instanceof FR.Chart.ValueAxisGlyph) {
                g = new FR.Chart.Bounds(i.x - this.bounds.width / 2 - a / 2, i.y - k / 2, a, k)
            } else {
                g = new FR.Chart.Bounds(i.x - a - c, i.y - k / 2, a, k)
            }
        } else {
            if (f == FR.Chart.Constants.TOP) {
                g = new FR.Chart.Bounds(i.x - a / 2, i.y - k - c, a, k)
            } else {
                if (f == FR.Chart.Constants.RIGHT) {
                    g = new FR.Chart.Bounds(i.x + c, i.y - k / 2, a, k)
                } else {
                    if (this.cubic && this instanceof FR.Chart.ValueAxisGlyph) {
                        g = new FR.Chart.Bounds(i.x - a / 2, i.y + this.bounds.height / 2 - k / 2, a, k)
                    } else {
                        g = new FR.Chart.Bounds(i.x - a / 2, i.y + c, a, k)
                    }
                }
            }
        }
        return g
    }, getLabelBounds: function (c, d, a) {
        var b = this.getPoint2D(c + d);
        return this.getLabelBounds4Point(c, d, a, b)
    }, drawLabel: function (a, d, e, b) {
        if (!this.isShowAxisLabel) {
            return
        }
        var c = this.getLabelBounds(d, e, b);
        this.drawLabelWithBounds(a, d, e, b, c)
    }, drawLabelWithPath: function (a, e, f, b, d) {
        if (!this.isShowAxisLabel) {
            return
        }
        var c = this.getLabelBounds(e, f, b);
        if (!d.isInteract(c)) {
            this.drawLabelWithBounds(a, e, f, b, c);
            d.addBounds(c, false)
        }
    }, drawLabelWithBounds: function (b, f, g, d, e) {
        b.useRight = this._isUseLabelStartRight();
        var a = this._isUseTooltip(d, e, this.textAttr);
        if (a) {
            var c = this._getFinalStringWithEs(d, this.textAttr, e);
            FR.Chart.PaintUtils.paintContent(b, c, this.textAttr, e.x, e.y, e.width, e.height);
            this.tooltipLabelBoundsList.push(e);
            this.tooltipLabelList.push(d)
        } else {
            FR.Chart.TextUtils.drawLabelWithRotation(b, d, this.textAttr, e)
        }
        b.useRight = false
    }, _getFinalStringWithEs: function (f, a, d) {
        var h = this.shouldBeHeight();
        var c = "";
        var g = "";
        for (var b = 0; b < f.length; b++) {
            c += f.charAt(b);
            var e = FR.Chart.TextUtils.calculateTextDimensionWithRotation(c, a);
            if (h) {
                if (e.height > d.height) {
                    if (g.length > 1) {
                        return g.substr(0, g.length - 1) + FR.Chart.Constants.ESP
                    } else {
                        return FR.Chart.Constants.ESP
                    }
                }
            } else {
                if (e.width > d.width) {
                    if (g.length > 1) {
                        return g.substr(0, g.length - 1) + FR.Chart.Constants.ESP
                    } else {
                        return FR.Chart.Constants.ESP
                    }
                }
            }
            g += f.charAt(b)
        }
        return g
    }, _isUseTooltip: function (b, c, a) {
        if (a == null) {
            a = new FR.Chart.TextAttr()
        }
        return FR.Chart.PaintUtils.isNeedToolTip4AxisLabel(b, a, c, this.shouldBeHeight())
    }, _isUseLabelStartRight: function () {
        if (this.position == FR.Chart.Constants.LEFT && FR.Browser.isIE8()) {
            if (this.textAttr && this.textAttr.rotation === 0) {
                return true
            }
        }
        return false
    }, drawTickLine: function (c, b, a) {
        if (!b || !this.lineColor || this.lineStyle == FR.Chart.Constants.LINE_NONE || b.startPoint == b.endPoint) {
            return
        }
        if (!c) {
            return
        }
        c.save();
        c.lineWidth = a;
        c.strokeStyle = this.lineColor;
        FR.Chart.GraphHelper.dealLine4JSDraw(b);
        b.draw(c);
        c.restore()
    }, getGridLine4Demo: function (d) {
        var c = this.getPoint2D(d);
        var a;
        if (this.position == FR.Chart.Constants.BOTTOM || this.position == FR.Chart.Constants.TOP) {
            var b = this.position == FR.Chart.Constants.TOP ? 0 : FR.Chart.PreChartGlyph.MOVE_BACKGROUND_HEIGHT + 12;
            a = new FR.Chart.Line2D(new FR.Chart.Point2D(c.x, c.y - this.demoGridLength + b), new FR.Chart.Point2D(c.x, c.y + b))
        }
        return [a]
    }, getGridLine: function (c) {
        var b = this.getPoint2D(c);
        var a;
        if (this.position == FR.Chart.Constants.LEFT) {
            a = new FR.Chart.Line2D(new FR.Chart.Point2D(b.x, b.y), new FR.Chart.Point2D(b.x + this.axisGridLength, b.y))
        } else {
            if (this.position == FR.Chart.Constants.RIGHT) {
                a = new FR.Chart.Line2D(new FR.Chart.Point2D(b.x - this.axisGridLength, b.y), new FR.Chart.Point2D(b.x, b.y))
            } else {
                if (this.position == FR.Chart.Constants.TOP) {
                    a = new FR.Chart.Line2D(new FR.Chart.Point2D(b.x, b.y + this.axisGridLength), new FR.Chart.Point2D(b.x, b.y))
                } else {
                    a = new FR.Chart.Line2D(new FR.Chart.Point2D(b.x, b.y - this.axisGridLength), new FR.Chart.Point2D(b.x, b.y))
                }
            }
        }
        return [a]
    }, draw: function (a) {
        this.drawAxisLine(a);
        this._drawAxisTitle(a)
    }, draw4Demo: function (a, b) {
        var c = this.textAttr;
        this.textAttr = b;
        this.isDraw4Demo = true;
        a.notUseDivText = true;
        this.drawOnlyLabels4Demo(a);
        a.notUseDivText = false;
        this.isDraw4Demo = false;
        this.textAttr = c
    }, drawOnlyLabels4Demo: function (a) {
    }, drawAlertValueLines: function (a) {
    }, getShape: function () {
        return this.getBounds()
    }, drawArrow: function (n, l, j) {
        if (this.isArrowShow) {
            if (!n) {
                return
            }
            n.save();
            n.strokeStyle = this.lineColor;
            n.fillStyle = this.lineColor;
            var p = new FR.Chart.Point2D(j.x - l.x, j.y - l.y);
            var m;
            var b = Math.sqrt(p.x * p.x + p.y * p.y);
            var a = 9;
            var q = 15;
            var k = 7;
            var i = 3;
            m = new FR.Chart.Point2D(a * p.x / b, a * p.y / b);
            var h = new FR.Chart.Point2D(j.x + m.x, j.y + m.y);
            m = new FR.Chart.Point2D(q * p.x / b, q * p.y / b);
            var g = new FR.Chart.Point2D(j.x + m.x, j.y + m.y);
            m = new FR.Chart.Point2D(k * p.x / b, k * p.y / b);
            var e = new FR.Chart.Point2D(j.x + m.x, j.y + m.y);
            var d = new FR.Chart.Point2D(e.x + p.y / b * i, e.y - p.x / b * i);
            var c = new FR.Chart.Point2D(e.x - p.y / b * i, e.y + p.x / b * i);
            var f = new FR.Chart.GeneralPath();
            f.moveTo(h.x, h.y);
            f.lineTo(d.x, d.y);
            f.lineTo(g.x, g.y);
            f.lineTo(c.x, c.y);
            f.closePath();
            var o = new FR.Chart.Line2D(j, h);
            FR.Chart.GraphHelper.dealLine4JSDraw(o);
            o.draw(n);
            f.draw(n);
            f.paint(n);
            n.restore()
        }
    }, _drawAxisTitle: function (b) {
        var a = this.titleGlyph;
        if (a) {
            var d = this._calculatorTitleBounds();
            a.bounds = d;
            var c = this.titleGlyph.rotation;
            if (a.textAttr.alignText == FR.Chart.Style.VERTICALTEXT) {
                if (this.position == FR.Chart.Constants.LEFT) {
                    a.textAttr.rotation = 90
                } else {
                    if (this.position == FR.Chart.Constants.RIGHT) {
                        a.textAttr.rotation = -90
                    }
                }
            }
            a.drawAxisTitle(b, FR.Chart.currentDivKey);
            if (a.textAttr.alignText == FR.Chart.Style.VERTICALTEXT) {
                a.textAttr.rotation = 0
            }
            this.titleGlyph.rotation = c
        }
    }, getPointValue: function (a) {
        var b = 0;
        if (this.originPoint == null) {
            return b
        }
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            if (this.position == FR.Chart.Constants.LEFT && this.bounds.y == this.originPoint.y) {
                b = (a.y - this.originPoint.y) / this.unitLength
            } else {
                if (!this.axisReversed) {
                    b = (this.originPoint.y - a.y) / this.unitLength
                } else {
                    b = (a.y - this.originPoint.y) / this.unitLength
                }
            }
        } else {
            if (!this.axisReversed) {
                b = (a.x - this.originPoint.x) / this.unitLength
            } else {
                b = (this.originPoint.x - a.x) / this.unitLength
            }
        }
        if (this.isLog && this.getCrossValue() > 0) {
            b = Math.pow(this.tickLength, b) * this.getCrossValue()
        } else {
            b = b + this.getCrossValue()
        }
        return b
    }, onZoomBarIncrease: function (b) {
        if (FR.Chart.ChartUtils.accNumber(this.zoomForward) <= -this.zoomTickLength) {
            if (b) {
                b = Math.min(b, Math.abs(this.zoomForward));
                this.zoomBackward -= b;
                this.zoomForward += b
            } else {
                var a = Math.min(this.zoomTickLength, Math.abs(this.zoomForward));
                this.zoomBackward -= a;
                this.zoomForward += a
            }
            this.zoomForward = Math.min(0, this.zoomForward);
            return true
        } else {
            if (this.zoomForward < 0) {
                var b = Math.abs(this.zoomForward);
                this.zoomForward = 0;
                this.zoomBackward -= b;
                return true
            }
        }
        return false
    }, onZoomBarDecrease: function (b) {
        if (FR.Chart.ChartUtils.accNumber(this.zoomBackward) <= -this.zoomTickLength) {
            if (b) {
                b = Math.min(b, Math.abs(this.zoomBackward));
                this.zoomBackward += b;
                this.zoomForward -= b
            } else {
                var a = Math.min(this.zoomTickLength, Math.abs(this.zoomBackward));
                this.zoomBackward += a;
                this.zoomForward -= a
            }
            this.zoomBackward = Math.min(this.zoomBackward, 0);
            return true
        } else {
            if (this.zoomBackward < 0) {
                var b = Math.abs(this.zoomBackward);
                this.zoomBackward = 0;
                this.zoomForward -= b;
                return true
            }
        }
        return false
    }, onZoomBarLeftUp: function (a) {
        if (FR.Chart.ChartUtils.accNumber(this.zoomBackward) <= -this.zoomTickLength) {
            if (a) {
                this.zoomBackward += a
            } else {
                this.zoomBackward += this.zoomTickLength
            }
            this.zoomBackward = Math.min(0, this.zoomBackward);
            return true
        } else {
            if (this.zoomBackward < 0) {
                this.zoomBackward = 0;
                return true
            }
        }
        return false
    }, _checZoomDown: function (b) {
        var a = Math.abs(this.maxValue - this.minValue) - Math.abs(this.zoomTickLength);
        var c = Math.abs(this.zoomForward + this.zoomBackward);
        if (c + b >= a) {
            b = a - c
        }
        return b
    }, onZoomBarLeftDown: function (b) {
        var c = this.getArrowValue() - this.getCrossValue();
        if (FR.Chart.ChartUtils.accNumber(c) > this.zoomTickLength) {
            var a = b ? b : this.zoomTickLength;
            a = this._checZoomDown(a);
            this.zoomBackward -= a;
            this.zoomBackward = Math.min(this.zoomBackward, 0);
            return true
        }
        return false
    }, onZoomBarRightUp: function (a) {
        if (FR.Chart.ChartUtils.accNumber(this.zoomForward) <= -this.zoomTickLength) {
            if (a) {
                this.zoomForward += a
            } else {
                this.zoomForward += this.zoomTickLength
            }
            this.zoomForward = Math.min(0, this.zoomForward);
            return true
        } else {
            if (this.zoomForward < 0) {
                this.zoomForward = 0;
                return true
            }
        }
        return false
    }, onZoomBarRightDown: function (b, d) {
        var c = this.getArrowValue() - this.getCrossValue();
        if (FR.Chart.ChartUtils.accNumber(c) > this.zoomTickLength) {
            var a = b ? b : this.zoomTickLength;
            a = d ? a : this._checZoomDown(a);
            this.zoomForward -= a;
            this.zoomForward = Math.min(this.zoomForward, 0);
            return true
        }
        return false
    }, _calculatorTitleBounds: function () {
        var b = null;
        var c = this.titleGlyph.preferredDimension();
        var a = this.titleGlyph.position;
        if (this.position == FR.Chart.Constants.TOP) {
            b = this._getTopTitleBounds(c, a)
        } else {
            if (this.position == FR.Chart.Constants.LEFT) {
                b = this._getLeftTitleBounds(c, a)
            } else {
                if (this.position == FR.Chart.Constants.BOTTOM) {
                    b = this._getBottomTitleBounds(c, a)
                } else {
                    if (this.position == FR.Chart.Constants.RIGHT) {
                        b = this._getRightTitleBounds(c, a)
                    }
                }
            }
        }
        b.x += this.bounds.x;
        b.y += this.bounds.y;
        return b
    }, _getTopTitleBounds: function (b, a) {
        return new FR.Chart.Bounds(this._getTopBottomX(a), -FR.Chart.AxisGlyph.LINE_LABEL_GAP - this.titleDim.height, b.width, b.height)
    }, _getTopBottomX: function (b) {
        var a = (this.axisLength - this.titleDim.width) / 2;
        if (b == FR.Chart.Constants.LEFT) {
            a = -12
        } else {
            if (b == FR.Chart.Constants.RIGHT) {
                a = this.axisLength - this.titleDim.width
            }
        }
        return a
    }, _getBottomTitleBounds: function (b, a) {
        return new FR.Chart.Bounds(this._getTopBottomX(a), this.axisLabelWidth + FR.Chart.AxisGlyph.LINE_LABEL_GAP, b.width, b.height)
    }, _getLeftTitleBounds: function (b, a) {
        return new FR.Chart.Bounds(-this.titleDim.width - FR.Chart.AxisGlyph.LINE_LABEL_GAP, this._getLeftRightY(a), b.width, b.height)
    }, _getLeftRightY: function (b) {
        var a = (this.axisLength - this.titleDim.height) / 2;
        if (b == FR.Chart.Constants.LEFT) {
            a = -12
        } else {
            if (b == FR.Chart.Constants.RIGHT) {
                a = this.axisLength - this.titleDim.height
            }
        }
        return a
    }, _getRightTitleBounds: function (b, a) {
        return new FR.Chart.Bounds(this.axisLabelWidth + FR.Chart.AxisGlyph.LINE_LABEL_GAP, this._getLeftRightY(a), b.width, b.height)
    }
});
$.extend(FR.Chart.AxisGlyph, {
    LINE_LABEL_GAP: 4,
    LABEL_TITLE_GAP: 1,
    MAIN_TICK_LENGTH: 5,
    SEC_TICK_LENGTH: 3,
    calculateIncrement: function (d, f) {
        if (d >= f) {
            return 1
        }
        var a = f - d;
        if (a === 1) {
            return 0.2
        }
        var b = 0;
        if (a > 0 && a < 1) {
            while (a < 1) {
                a = a * 10;
                b--
            }
        } else {
            if (a >= 10) {
                while (a >= 10) {
                    a = a / 10;
                    b++
                }
            }
        }
        var c = Math.pow(10, b);
        var e = parseInt((f - d) / c);
        if (e === 2 || e === 1) {
            return c / 2
        }
        if (e >= 3 && e <= 5) {
            return c
        }
        if (e >= 6 && e <= 7) {
            return c * 2
        }
        if (e >= 8) {
            return c * 3
        }
        return a
    }
});
FR.Chart.CategoryAxisGlyph = FR.extend(FR.Chart.AxisGlyph, {
    labelOffset: 0.5, initConstants: function (b) {
        b = b || {};
        this.categoryLabelList = [];
        if (b.categoryLabelList && b.categoryLabelList.length > 0) {
            for (var a = 0; a < b.categoryLabelList.length; a++) {
                this.categoryLabelList.push(b.categoryLabelList[a])
            }
        }
        this.secondLabels = [];
        if (b.secondLabels && b.secondLabels.length > 0) {
            for (var a = 0; a < b.secondLabels.length; a++) {
                this.secondLabels.push(b.secondLabels[a])
            }
        }
        this.thirdLabels = [];
        if (b.thirdLabels && b.thirdLabels.length > 0) {
            for (var a = 0; a < b.thirdLabels.length; a++) {
                this.thirdLabels.push(b.thirdLabels[a])
            }
        }
        this.timeSwitchArray = [];
        if (b.timeSwitchArray && b.timeSwitchArray.length > 0) {
            for (var a = 0; a < b.timeSwitchArray.length; a++) {
                this.timeSwitchArray.push(b.timeSwitchArray[a])
            }
        }
        this.zoomTickLength = 1;
        this.PRE_LABEL_HEIGHT = 20;
        FR.Chart.CategoryAxisGlyph.superclass.initConstants.apply(this, [b])
    }, isNeedTimeSwitch: function () {
        return this.timeSwitchArray && this.timeSwitchArray.length > 0
    }, configLabels: function (a) {
        this.categoryLabelList = a.category_array || [];
        this.secondLabels = a.secondCates || [];
        this.thirdLabels = a.thirdLabels || [];
        if (this.categoryLabelList) {
            this.maxValue = this.categoryLabelList.length;
            this.minValue = 0;
            this.tickLength = this.isCustomMainUnit ? this.tickLength : 1;
            this.smallTickLength = this.isCustomSecUnit ? this.smallTickLength : this.tickLength / 5
        }
    }, configAxisLabelsWithOptionData: function (a) {
        this.categoryLabelList = a.category || [];
        if (this.categoryLabelList) {
            this.maxValue = this.categoryLabelList.length;
            this.minValue = 0;
            this.tickLength = this.isCustomMainUnit ? this.tickLength : 1;
            this.smallTickLength = this.isCustomSecUnit ? this.smallTickLength : this.tickLength / 5
        }
    }, initConfig: function (a) {
        if (this.categoryLabelList) {
            this.maxValue = this.categoryLabelList.length;
            this.minValue = 0;
            this.tickLength = a.tickLength || 1;
            this.smallTickLength = this.tickLength / 5;
            this.drawBetweenTick = true
        }
    }, calculateAxisLengthUnit: function () {
        var a = this.getArrowValue() - this.getCrossValue();
        var b = this.maxValue - this.minValue;
        if (a <= 0) {
            this.unitLength = 1;
            return
        }
        if (this.drawBetweenTick) {
            this.unitLength = this.axisLength / a;
            this.unitLengthNoScale = this.axisLength / ((b) === 0 ? 1 : b)
        } else {
            this.unitLength = this.axisLength / Math.max(1, a - 1);
            this.unitLengthNoScale = this.axisLength / Math.max(1, b - 1)
        }
        if (b <= 0) {
            this.unitLengthNoScale = 1
        }
    }, calBoundsWithMoreLabel4Cate: function (b) {
        if (this.position == FR.Chart.Constants.BOTTOM && this.isShowAxisLabel) {
            var a = this.secondLabels.length === 0 ? 0 : this.PRE_LABEL_HEIGHT;
            a += this.thirdLabels.length === 0 ? 0 : this.PRE_LABEL_HEIGHT;
            b.height = b.height - a
        }
    }, dealWithPlotBounds: function () {
        var a = this.getMaxLength();
        if (a) {
            a += FR.Chart.AxisGlyph.LINE_LABEL_GAP
        }
        a += this.getTickLengthShow();
        if (this.shouldBeHeight()) {
            a = Math.min(this.plotZeroBounds.height * this.MAX_AXIS_LABEL_HEIGHT + FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow(), a)
        } else {
            a = Math.min(this.plotZeroBounds.width * this.MAX_AXIS_LABEL_WIDTH + FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow(), a)
        }
        var c = this.categoryLabelList;
        if (c.length > 0) {
            if (this.shouldBeHeight()) {
                var b = ((this.format == null) ? (c[0].toString()) : (FR.contentFormat(c[0].toString(), this.format)));
                this.startLabelDim = new FR.Chart.Dimension2D(this.dealWithStartAndEndDim(b), this.startLabelDim.height);
                var e = ((this.format == null) ? (c[c.length - 1].toString()) : (FR.contentFormat(c[c.length - 1].toString(), this.format)));
                this.endLabelDim = new FR.Chart.Dimension2D(this.dealWithStartAndEndDim(e), this.endLabelDim.height)
            } else {
                var b = ((this.format == null) ? (c[0].toString()) : (FR.contentFormat(c[0].toString(), this.format)));
                this.startLabelDim = new FR.Chart.Dimension2D(this.startLabelDim.width, this.dealWithStartAndEndDim(b));
                var e = ((this.format == null) ? (c[c.length - 1].toString()) : (FR.contentFormat(c[c.length - 1].toString(), this.format)));
                this.endLabelDim = new FR.Chart.Dimension2D(this.endLabelDim.width, this.dealWithStartAndEndDim(e))
            }
        }
        var d = a - this.axisLabelWidth;
        this.axisLabelWidth = a;
        return d
    }, dealWithStartAndEndDim: function (a) {
        var b = FR.Chart.TextUtils.calculateTextDimensionWithRotation("a", this.textAttr);
        var c = this.getAxisLabelDim(a);
        if (this.shouldBeHeight()) {
            return Math.min(c.width, this.unitLength - b)
        } else {
            return Math.min(this.unitLength - 6, c.height)
        }
    }, initMinMaxValue: function (b, a) {
        this.minValue = b;
        this.maxValue = a
    }, getMaxLength: function () {
        if (!this.isShowAxisLabel) {
            return 0
        }
        var b = 0;
        var e = this.categoryLabelList;
        for (var d = 0; d < e.length; d += 1) {
            var c = ((this.format == null) ? (e[d].toString()) : (FR.contentFormat(e[d].toString(), this.format)));
            var a = this.getAxisLabelMoreWidth(c);
            b = (a < b ? b : a)
        }
        return b
    }, getAxisLabelMoreWidth: function (j, c) {
        var d = this.getAxisLabelDim(j);
        var l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation("a", this.textAttr);
        if (this.textAttr.alignText == FR.Chart.Style.HORIZONTALTEXT) {
            if (this.shouldBeHeight()) {
                var m = this.unitLength - l.width;
                if (this.textAttr.rotation === 0) {
                    return this.calculateAllNeedHeight4Horizontal(j, m)
                } else {
                    var n = this.plotZeroBounds.height * this.MAX_AXIS_LABEL_HEIGHT;
                    var o = this.textAttr.rotation;
                    var b = o * Math.PI / 180;
                    var k = 0.5 * m / Math.abs(Math.cos(b));
                    var a = this.calculateAllNeedHeight4Horizontal(j, k);
                    var f = FR.Chart.TextUtils._calDimWithRotation(new FR.Chart.Dimension2D(k, a), this.textAttr).height;
                    if (f > n) {
                        var g = [];
                        var e = [];
                        f = FR.Chart.TextUtils._calDimWithRotation(this.calculateDimUsed4Rotation(j, n, m, g, e), this.textAttr).height
                    }
                    return f
                }
            } else {
                if (this.textAttr.rotation === 0) {
                    return d.width
                } else {
                    var m = this.plotZeroBounds.width * this.MAX_AXIS_LABEL_WIDTH;
                    var n = this.unitLength - this.TOP_AND_DOWN_GAP;
                    var o = this.textAttr.rotation;
                    var b = o * Math.PI / 180;
                    var k = 0.5 * n / Math.abs(Math.sin(b));
                    var a = this.calculateAllNeedHeight4Horizontal(j, k);
                    var h = FR.Chart.TextUtils._calDimWithRotation(new FR.Chart.Dimension2D(k, a), this.textAttr).width;
                    if (h > m) {
                        var g = [];
                        var e = [];
                        h = FR.Chart.TextUtils._calDimWithRotation(this.calculateDimUsed4Rotation(j, n, m, g, e), this.textAttr).width
                    }
                    return h
                }
            }
        } else {
            if (this.shouldBeHeight()) {
                return d.height
            } else {
                return this.calculateAllNeedWidth4Vertival(j, this.unitLength - this.TOP_AND_DOWN_GAP)
            }
        }
    }, calculateAllNeedHeight4Horizontal: function (f, g) {
        var h = 0;
        var d = f;
        var b = FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow();
        do {
            for (var c = 1; c <= d.length; c++) {
                var j = FR.Chart.TextUtils.calculateTextDimensionWithRotation(d.substring(0, c), this.textAttr);
                var e = j.width > g || j.height > this.axisLabelWidth - b;
                if (c === 1 && e) {
                    d = "";
                    j = FR.Chart.TextUtils.calculateTextDimensionWithRotation(this.ELLIPSIS, this.textAttr);
                    h += j.height;
                    break
                }
                var a = j.width;
                if (a > g && c !== 1) {
                    h += j.height;
                    d = d.substring(c - 1);
                    break
                } else {
                    if (c == d.length) {
                        d = "";
                        h += j.height;
                        break
                    }
                }
            }
        } while (d != "");
        return h
    }, calculateAllNeedWidth4Vertival: function (f, g) {
        var a = -this.TOP_AND_DOWN_GAP / 2;
        var d = f;
        var b = FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow();
        do {
            a += this.TOP_AND_DOWN_GAP / 2;
            for (var c = 1; c <= d.length;
                 c++) {
                var j = FR.Chart.TextUtils.calculateTextDimensionWithRotation(d.substring(0, c), this.textAttr);
                var e = j.width > this.axisLabelWidth - b || j.height > g;
                if (c === 1 && e) {
                    d = "";
                    j = FR.Chart.TextUtils.calculateTextDimensionWithRotation(this.ELLIPSIS, this.textAttr);
                    a += j.width;
                    break
                }
                var h = j.height;
                if (h > g && c !== 1) {
                    a += j.width;
                    d = d.substring(c - 1);
                    break
                } else {
                    if (c == d.length) {
                        d = "";
                        a += j.width;
                        break
                    }
                }
            }
        } while (d != "");
        return a
    }, getMaxLabelWidthAndInitStartEndLabelDim: function () {
        if (!this.isShowAxisLabel) {
            return 0
        }
        var b = 8;
        var e = this.categoryLabelList;
        var g = 1;
        for (var d = 0; d < e.length; d += g) {
            var c = ((this.format == null) ? (e[d].toString()) : (FR.contentFormat(e[d].toString(), this.format)));
            var f = this.getAxisLabelDim(c);
            if (d === 0) {
                this.startLabelDim = f
            } else {
                this.endLabelDim = f
            }
            var a = this.shouldBeHeight() ? f.height : f.width;
            b = (a < b ? b : a)
        }
        return b
    }, getPreLeftWidth4DataSheet: function () {
        this.calculateTitleDimesion();
        var b = 0;
        if (this.titleDim.width > 0) {
            b = this.titleDim.width + FR.Chart.AxisGlyph.LINE_LABEL_GAP
        }
        var a = this.getMaxLabelWidthAndInitStartEndLabelDim();
        return (this.position == FR.Chart.Constants.LEFT) ? a + b : 0
    }, addCategoryLabel: function (a) {
        this.categoryLabelList.push(a)
    }, getMaxTickValue: function () {
        var a = this.getArrowValue();
        if (!this.drawBetweenTick) {
            if (this.categoryLabelList && this.categoryLabelList.length > 1) {
                a = a - this.tickLength
            }
        }
        return a
    }, getTickNumber4CalDim: function () {
        var a = 15;
        var c = this.getMaxTickValue() - this.getCrossValue();
        var b = 1;
        var d = Math.abs(c);
        while (a < Math.ceil(d / (b * this.getDateTypeNumber()))) {
            b++
        }
        return b
    }, getTickSamplingTime: function () {
        return this.getTickIntervalCount(this.getMaxTickValue() - this.getCrossValue(), 15)
    }, getTickIntervalCount: function (c, a) {
        var b = 1;
        if (this.axisLength && this.tickLength && c && Math.abs(c) > 0 && a && this.axisLength > a) {
            var d = this.axisLength / a;
            var e = Math.abs(c);
            while (d < Math.ceil(e / (this.tickLength * b * this.getDateTypeNumber()))) {
                b++
            }
        }
        return b
    }, getDateTypeNumber: function () {
        return 1
    }, getMaxTickValueDemo: function () {
        var a = this.maxValue;
        if (!this.drawBetweenTick) {
            if (this.categoryLabelList && this.categoryLabelList.length > 1) {
                a = a - this.tickLength
            }
        }
        return a
    }, getTickSamplingTime4Demo: function () {
        return this.getTickIntervalCount(this.getMaxTickValueDemo() - this.minValue, 40)
    }, getLabelSamplingTime: function (f, d, g, b) {
        var c = f * g;
        var i = new FR.Chart.BoundsManager();
        for (var h = 0; h < this.categoryLabelList.length; h += c) {
            var a = this.getLabelString(h, d);
            var e = this.getLabelBounds(h, b, a);
            if (i.isInteract(e)) {
                g++;
                return this.getLabelSamplingTime(f, d, g, b)
            } else {
                i.addBounds(e)
            }
        }
        return g
    }, drawAxisGrid: function (c) {
        var e = this.getMaxTickValue();
        var a = this.getTickSamplingTime();
        if (!c) {
            return
        }
        c.save();
        if (this.mainGridStyle != FR.Chart.Constants.LINE_NONE && this.tickLength > 0 && this.mainGridColor != null) {
            c.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.mainGridStyle);
            c.strokeStyle = this.mainGridColor;
            for (var f = (this.tickLength + this.getCrossValue()) * a; f <= e; f += this.tickLength * a) {
                var b = this.getGridLine(f);
                for (var d = 0; d < b.length; d++) {
                    FR.Chart.GraphHelper.dealLine4JSDraw(b[d]);
                    b[d].draw(c)
                }
            }
        }
        c.restore()
    }, drawAxisLine: function (b) {
        if (!b) {
            return
        }
        b.save();
        if (this.lineColor && this.lineStyle != FR.Chart.Constants.LINE_NONE) {
            b.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.lineStyle);
            b.strokeStyle = this.lineColor;
            var a = new FR.Chart.Line2D(this.getPoint2D(this.getCrossValue()), this.getPoint2D(this.getMaxTickValue()));
            FR.Chart.GraphHelper.dealLine4JSDraw(a);
            a.draw(b);
            this.drawArrow(b, a.startPoint, a.endPoint)
        }
        this.drawTicks(b);
        this.drawMoreTickLabel(b);
        b.restore()
    }, drawMoreTickLabel: function (a) {
        if (!this.isShowAxisLabel) {
            return
        }
        this._drawMore(a, this.secondLabels, 0);
        this._drawMore(a, this.thirdLabels, 1);
        this._drawMoreTicks(a, 0);
        this._drawMoreTicks(a, 1)
    }, _drawMore: function (m, h, i) {
        if (h == null || h.length === 0) {
            return
        }
        var l = new FR.Chart.BoundsManager();
        var f = new FR.Chart.TextAttr();
        f.frFont = new FR.Chart.FRFont();
        f.frFont.fontName = "Microsoft YaHei";
        f.frFont.size = "12";
        for (var a = 0, n = h.length; a < n; a++) {
            var c = h[a];
            var e = FR.Chart.TextUtils.calculateTextDimensionWithRotation(c, f);
            var k = this.bounds.x + this._getSecondX(a, n);
            var d = k - e.width / 2;
            var b = this.bounds.y + this.axisLabelWidth + i * this.PRE_LABEL_HEIGHT + 7;
            var g = new FR.Chart.Bounds(d, b, e.width, e.height);
            if (!l.isInteract(g)) {
                l.addBounds(g);
                var j = this._isUseTooltip(c, g, f);
                if (j) {
                    c = this._getFinalStringWithEs(c, f, g)
                }
                FR.Chart.PaintUtils.paintContent(m, c, f, g.x, g.y, g.width, g.height)
            }
        }
    }, _drawMoreTicks: function (b, c) {
        var g = c === 0 ? this.secondLabels : this.thirdLabels;
        if (!g || g.length <= 0) {
            return
        }
        var e = (c + 1) * this.PRE_LABEL_HEIGHT + this.axisLabelWidth;
        var d = parseInt(this.categoryLabelList.length / g.length);
        for (var f = 0; f <= g.length; f++) {
            var a = this.getTickLine(f * d, e, FR.Chart.Constants.TICK_MARK_OUTSIDE);
            this.drawTickLine(b, a, FR.Chart.Constants.AxisTickWidth)
        }
    }, _getSecondX: function (a, b) {
        var c = this.bounds.width;
        return c * (a + 1 / 2) / b
    }, _getBottomTitleBounds: function (c, a) {
        var b = this.axisLabelWidth + FR.Chart.AxisGlyph.LINE_LABEL_GAP;
        if (this.secondLabels && this.secondLabels.length > 0) {
            b += this.PRE_LABEL_HEIGHT
        }
        if (this.thirdLabels && this.thirdLabels.length > 0) {
            b += this.PRE_LABEL_HEIGHT
        }
        return new FR.Chart.Bounds(this._getTopBottomX(a), b, c.width, c.height)
    }, isToNumber: function () {
        for (var a = 0; a < this.categoryLabelList.length; a++) {
            for (var c = 0; c < this.categoryLabelList[a].toString().length; c++) {
                var b = this.categoryLabelList[a].toString().charAt(c);
                if (isNaN(b) && b != ".") {
                    return false
                }
            }
        }
        return true
    }, getLabelString: function (b) {
        var a = this.categoryLabelList[b].toString();
        var c = this.format;
        if (c != null) {
            a = FR.contentFormat(a, c)
        }
        return a
    }, drawOnlyLabels4Demo: function (j) {
        if (this.axisLength <= 15) {
            return
        }
        if (this.tickLength > 0 && this.axisLength >= 40) {
            var h = this.getTickSamplingTime4Demo();
            for (var g = (this.tickLength + this.minValue) * h; g < this.maxValue; g += this.tickLength * h) {
                var k = this.getGridLine4Demo(g);
                for (var c = 0; c < k.length; c++) {
                    if (k[c]) {
                        FR.Chart.GraphHelper.dealLine4JSDraw(k[c]);
                        k[c].draw(j)
                    }
                }
            }
        }
        var e = this.getTickIntervalCount(this.getMaxTickValueDemo() - this.minValue, 15);
        var d = this.isToNumber();
        var b = (this.drawBetweenTick ? 0.5 : 0);
        var f = ((this.labelNumber > 0) ? this.labelNumber : e * this.getLabelSamplingTime(e, d, 1, b));
        for (var g = this.minValue < 0 ? 0 : this.minValue; g < this.categoryLabelList.length && g < this.maxValue; g += f) {
            var a = this.getLabelString(g, d);
            FR.Chart.CategoryAxisGlyph.superclass.drawLabel.apply(this, [j, g, b, a])
        }
    }, drawTicks: function (c) {
        if (this.axisLength <= 15) {
            return
        }
        var d = this.getMaxTickValue();
        var a = this.getTickSamplingTime();
        var e = this.secondLabels && this.secondLabels.length === 0 ? FR.Chart.AxisGlyph.MAIN_TICK_LENGTH : this.axisLabelWidth;
        for (var f = this.getCrossValue() + a; f <= d; f += a) {
            var b = this.getTickLine(f, e, this.tickMarkType);
            this.drawTickLine(c, b, FR.Chart.Constants.AxisTickWidth)
        }
        if (a <= 1 && Math.abs(this.smallTickLength) > 0) {
            for (var f = this.getCrossValue() + this.smallTickLength; f <= d; f += this.smallTickLength) {
                var b = this.getTickLine(f, FR.Chart.AxisGlyph.SEC_TICK_LENGTH, this.secTickMarkType);
                this.drawTickLine(c, b, FR.Chart.Constants.AxisTickWidth)
            }
        }
        this.drawTickLabel(c)
    }, drawTickLabel: function (b) {
        if (this.axisLength <= 15) {
            return
        }
        var a = this.getTickSamplingTime();
        var f = this.isToNumber();
        var g = (this.drawBetweenTick ? 0.5 : 0);
        var c = ((this.labelNumber > 0) ? this.labelNumber : a * this.getLabelSamplingTime(a, f, 1, g));
        if (this.isLabelWrap && c === 1) {
            for (var e = this.getCrossValue() < 0 ? 0 : this.getCrossValue(); e < this.categoryLabelList.length && e < this.getArrowValue(); e += c) {
                var d = this.getLabelString(e, f);
                this.drawLabelWrapWhenNeed(b, e, g, d)
            }
        } else {
            for (var e = this.getCrossValue() < 0 ? 0 : this.getCrossValue(); e < this.categoryLabelList.length && e < this.getArrowValue(); e += c) {
                var d = this.getLabelString(e, f);
                FR.Chart.CategoryAxisGlyph.superclass.drawLabel.apply(this, [b, e, g, d])
            }
        }
    }, drawLabelWrapWhenNeed: function (a, c, d, b) {
        if (!this.isShowAxisLabel) {
            return
        }
        if (this.textAttr.alignText == FR.Chart.Style.HORIZONTALTEXT && this.textAttr.rotation === 0) {
            this.drawTextHorizontalWrap(a, c, d, b)
        } else {
            if (this.textAttr.alignText == FR.Chart.Style.HORIZONTALTEXT && this.textAttr.rotation !== 0) {
                this.drawTextWithRotation4Wrap(a, c, d, b)
            } else {
                this.drawTextVerticalWrap(a, c, d, b)
            }
        }
    }, drawTextWithRotation4Wrap: function (p, n, e, B) {
        var k = FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow();
        var d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation("a", this.textAttr);
        var r = FR.Chart.TextUtils.calculateTextDimensionWithRotation(B, this.textAttr);
        var y = this.shouldBeHeight() ? this.unitLength - d.width : this.axisLabelWidth - k;
        if (r.width <= y) {
            var v = this.getLabelBounds(n, e, B);
            this.drawLabelWithBounds(p, n, e, B, v);
            return
        }
        var m = this.shouldBeHeight() ? this.axisLabelWidth : this.unitLength - this.TOP_AND_DOWN_GAP;
        var z = [];
        var b = [];
        var g = this.calculateDimUsed4Rotation(B, m, y, z, b);
        var q = this.getPoint2D(n + e);
        var a = this.textAttr.rotation;
        var c = Math.PI / 180;
        var t = FR.Chart.PaintUtils.isOffSetY4SomeFont(p, this.textAttr.frFont);
        var o = -a * c;
        if (this.position == FR.Chart.Constants.BOTTOM) {
            p.translate(q.x, q.y + k);
            if (a < 0) {
                p.translate(-2, -3)
            }
        } else {
            if (this.position == FR.Chart.Constants.TOP) {
                p.translate(q.x, q.y - g.height);
                var x = this.textAttr.rotation * Math.PI / 180;
                var h = g.width * Math.abs(Math.sin(x));
                p.translate(0, -h)
            } else {
                if (this.position == FR.Chart.Constants.LEFT) {
                    p.translate(q.x - k, q.y)
                } else {
                    p.translate(q.x + k + g.width, q.y)
                }
            }
        }
        p.rotate(o);
        if (this.shouldBeHeight()) {
            if (this.textAttr.rotation > 0) {
                for (var s = 0; s < z.length; s++) {
                    var f = z[s];
                    var l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(f, this.textAttr);
                    p.fillText(f, -g.width, t + k);
                    p.fillText(f, -g.width, t + k);
                    t += l.height
                }
            } else {
                for (var s = 0; s < z.length; s++) {
                    var f = z[s];
                    var l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(f, this.textAttr);
                    p.fillText(f, k, t + k);
                    p.fillText(f, k, t + k);
                    t += l.height
                }
            }
        } else {
            if (this.textAttr.rotation > 0) {
                for (var s = 0; s < z.length; s++) {
                    var f = z[s];
                    var l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(f, this.textAttr);
                    p.fillText(f, -g.width, t - g.height / 2);
                    p.fillText(f, -g.width, t - g.height / 2);
                    t += l.height
                }
            } else {
                for (var s = 0; s < z.length; s++) {
                    var f = z[s];
                    var l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(f, this.textAttr);
                    p.fillText(f, -g.width, t);
                    p.fillText(f, -g.width, t);
                    t += l.height
                }
            }
        }
        p.rotate(-o);
        if (this.position == FR.Chart.Constants.BOTTOM) {
            p.translate(-q.x, -q.y - k);
            if (a < 0) {
                p.translate(2, 3)
            }
        } else {
            if (this.position == FR.Chart.Constants.TOP) {
                p.translate(-q.x, -q.y + g.height);
                var x = this.textAttr.rotation * Math.PI / 180;
                var h = g.width * Math.abs(Math.sin(x));
                p.translate(0, h)
            } else {
                if (this.position == FR.Chart.Constants.LEFT) {
                    p.translate(-q.x + k, -q.y)
                } else {
                    p.translate(-q.x - k - g.width, -q.y)
                }
            }
        }
        var w = 0;
        var u = 0;
        var A = 0;
        var j = 0;
        if (this.shouldBeHeight()) {
            if (this.textAttr.rotation > 0) {
                w = q.x - y / 2;
                u = this.position == FR.Chart.Constants.BOTTOM ? q.y + k : q.y - k * 2 - g.height
            } else {
                w = q.x;
                u = this.position == FR.Chart.Constants.BOTTOM ? q.y + k : q.y - k * 2 - g.height
            }
            A = y / 2;
            j = m
        } else {
            if (this.textAttr.rotation > 0) {
                w = this.position == FR.Chart.Constants.LEFT ? q.x - k - y : q.x + k;
                u = q.y
            } else {
                w = this.position == FR.Chart.Constants.LEFT ? q.x - k - y : q.x + k;
                u = q.y - m / 2
            }
            A = y;
            j = m / 2
        }
        if (b.length > 0) {
            this.tooltipLabelBoundsList.push(new FR.Chart.Bounds(w, u, A, j));
            this.tooltipLabelList.push(B)
        }
    }, drawTextHorizontalWrap: function (m, l, e, u) {
        var h = FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow();
        var d = FR.Chart.TextUtils.calculateTextDimensionWithRotation("a", this.textAttr);
        var o = FR.Chart.TextUtils.calculateTextDimensionWithRotation(u, this.textAttr);
        var s = this.shouldBeHeight() ? this.unitLength - d.width : this.axisLabelWidth - h;
        if (o.width <= s) {
            var q = this.getLabelBounds(l, e, u);
            this.drawLabelWithBounds(m, l, e, u, q);
            return
        }
        var k = this.shouldBeHeight() ? this.axisLabelWidth - h : this.unitLength - this.TOP_AND_DOWN_GAP;
        var t = [];
        var a = [];
        var c = this.calculateHeightUsed4Horizontal(u, k, s, t, a);
        var r;
        var n = this.getPoint2D(l + e);
        if (!this.shouldBeHeight()) {
            r = n.y - c / 2
        } else {
            r = this.position == FR.Chart.Constants.BOTTOM ? n.y + h : n.y - h - c
        }
        for (var p = 0; p < t.length; p++) {
            var f = t[p];
            var j = FR.Chart.TextUtils.calculateTextDimensionWithRotation(f, this.textAttr);
            var g = this.shouldBeHeight() ? n.x - j.width / 2 : (this.position == FR.Chart.Constants.LEFT ? n.x - h - j.width : n.x + h);
            var b = new FR.Chart.Bounds(g, r, j.width, j.height);
            this.drawLabelWithBounds(m, l, e, f, b);
            if (a.length > 0) {
                this.tooltipLabelBoundsList.push(b);
                this.tooltipLabelList.push(u)
            }
            r += j.height
        }
    }, drawTextVerticalWrap: function (l, k, d, u) {
        var f = FR.Chart.AxisGlyph.LINE_LABEL_GAP + this.getTickLengthShow();
        var n = FR.Chart.TextUtils.calculateTextDimensionWithRotation(u, this.textAttr);
        var j = this.shouldBeHeight() ? this.axisLabelWidth - f : this.unitLength - this.TOP_AND_DOWN_GAP;
        if (n.height <= j) {
            var q = this.getLabelBounds(k, d, u);
            this.drawLabelWithBounds(l, k, d, u, q);
            return
        }
        var c = FR.Chart.TextUtils.calculateTextDimensionWithRotation("a", this.textAttr);
        var r = this.shouldBeHeight() ? this.unitLength - c.width : this.axisLabelWidth - f;
        var t = [];
        var a = [];
        var p = this.calculateWidthUsed4Vertical(u, j, r, t, a);
        var h;
        var m = this.getPoint2D(k + d);
        if (!this.shouldBeHeight()) {
            h = new FR.Chart.Point2D((this.position == FR.Chart.Constants.LEFT ? m.x - f : m.x + f + p), m.y - j / 2)
        } else {
            h = new FR.Chart.Point2D(m.x + p / 2, this.position == FR.Chart.Constants.BOTTOM ? m.y + f : m.y - f - j)
        }
        var s = h.x;
        for (var o = 0; o < t.length; o++) {
            var e = t[o];
            var g = FR.Chart.TextUtils.calculateTextDimensionWithRotation(e, this.textAttr);
            var b = new FR.Chart.Bounds(s - g.width, h.y, g.width, g.height);
            this.drawLabelWithBounds(l, k, d, e, b);
            if (a.length > 0) {
                this.tooltipLabelBoundsList.push(b);
                this.tooltipLabelList.push(u)
            }
            s -= g.width + this.TOP_AND_DOWN_GAP / 2
        }
    }, calculateDimUsed4Rotation: function (c, i, j, f, e) {
        var h = 0;
        var l = 0;
        var k = this.textAttr.rotation;
        var a = k * Math.PI / 180;
        if (this.shouldBeHeight()) {
            h = 0.5 * j / Math.abs(Math.cos(a));
            var b = h * Math.abs(Math.sin(a));
            b = i - b;
            l = b / Math.abs(Math.cos(a))
        } else {
            h = 0.5 * i / Math.abs(Math.sin(a));
            var g = h * Math.abs(Math.cos(a));
            g = j - g;
            g = g / Math.abs(Math.sin(a));
            way2 = 0.5 * i / Math.abs(Math.cos(a));
            l = Math.min(g, way2)
        }
        var d = this.calculateHeightUsed4Horizontal(c, l, h, f, e);
        if (f.length === 1 && f[0] === this.ELLIPSIS) {
            return FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(this.ELLIPSIS, this.textAttr)
        }
        return new FR.Chart.Dimension2D(h, d)
    }, calculateHeightUsed4Horizontal: function (b, j, k, g, c) {
        var d = 0;
        var f = 0;
        do {
            for (var a = 1; a <= b.length; a++) {
                var l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(b.substring(0, a), this.textAttr);
                var e = l.width > k || l.height > j;
                if (a === 1 && e) {
                    b = "";
                    c.push(true);
                    g.push(this.ELLIPSIS);
                    l = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(this.ELLIPSIS, this.textAttr);
                    d += l.height;
                    break
                }
                if (l.width > k && a !== 1) {
                    g.push(b.substring(0, a - 1));
                    b = b.substring(a - 1);
                    d += l.height;
                    f = l.height;
                    break
                } else {
                    if (a == b.length) {
                        g.push(b);
                        b = "";
                        d += l.height;
                        f = l.height;
                        break
                    }
                }
            }
        } while (d < j && !(b == ""));
        if (d <= j) {
            return d
        } else {
            g.pop();
            if (g.length === 0) {
                g.push(this.ELLIPSIS)
            } else {
                var h = g[g.length - 1];
                g.pop();
                g.push(this.calculateStrWithEllipse(k, h, true))
            }
            c.push(true);
            return d - f
        }
    }, calculateWidthUsed4Vertical: function (c, j, k, f, d) {
        var g = -this.TOP_AND_DOWN_GAP / 2;
        var a = 0;
        do {
            g += this.TOP_AND_DOWN_GAP / 2;
            for (var b = 1; b <= c.length; b++) {
                var m = FR.Chart.TextUtils.calculateTextDimensionWithRotation(c.substring(0, b), this.textAttr);
                var e = m.width > k || m.height > j;
                if (b === 1 && e) {
                    c = "";
                    d.push(true);
                    f.push(this.ELLIPSIS);
                    m = FR.Chart.TextUtils.calculateTextDimensionWithRotation(this.ELLIPSIS, this.textAttr);
                    g += m.width;
                    break
                }
                var l = m.height;
                if (l > j && b !== 1) {
                    f.push(c.substring(0, b - 1));
                    c = c.substring(b - 1);
                    g += m.width;
                    a = m.width;
                    break
                } else {
                    if (b == c.length) {
                        f.push(c);
                        c = "";
                        g += m.width;
                        a = m.width;
                        break
                    }
                }
            }
        } while (g < k && !(c == ""));
        if (g <= k) {
            return g
        } else {
            f.pop();
            if (f.length === 0) {
                f.push(this.ELLIPSIS)
            } else {
                var h = f[f.length - 1];
                f.pop();
                f.push(this.calculateStrWithEllipse(j, h, false))
            }
            d.push(true);
            return g - a - this.TOP_AND_DOWN_GAP / 2
        }
    }, calculateStrWithEllipse: function (b, c, f) {
        for (var d = 1; d <= c.length; d++) {
            var a = c.substring(0, d) + this.ELLIPSIS;
            var g = f ? FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, this.textAttr) : FR.Chart.TextUtils.calculateTextDimensionWithRotation(a, this.textAttr);
            var e = f ? g.width : g.height;
            if (e > b) {
                if (d === 0) {
                    return this.ELLIPSIS
                } else {
                    return c.substring(0, d - 1) + this.ELLIPSIS
                }
            }
        }
        return c + this.ELLIPSIS
    }, getOriginalCrossValue: function () {
        return this.minValue
    }, getOriginalArrowValue: function () {
        return this.maxValue
    }, getCrossValue: function () {
        return this.minValue - this.zoomBackward
    }, getArrowValue: function () {
        return this.maxValue + this.zoomForward
    }, draw4ThreeD: function (a) {
        this.drawTickLabel(a);
        this._drawAxisTitle(a)
    }
});
FR.Chart.NumberAxisGlyph = FR.extend(FR.Chart.AxisGlyph, {
    initConstants: function (b) {
        b = b || {};
        this.showUnit = b.showUnit;
        this.unitPadding = b.unitPadding || "";
        this.isPercentage = b.isPercentage;
        this.isLog = b.isLog;
        this.baseLog = FR.pick(b.baseLog, 10);
        this.alertValueList = [];
        if (b.alertList) {
            for (var a = 0; a < b.alertList.length;
                 a++) {
                this.alertValueList[a] = new FR.Chart.ChartAlertValue(b.alertList[a])
            }
        }
        this.zoomTickLength = FR.pick(b.smallTickLength, 1);
        FR.Chart.NumberAxisGlyph.superclass.initConstants.apply(this, [b]);
        this.oldMin = null;
        this.oldMax = null;
        this.oldTick = null
    }, initMinMaxValue: function (d, a) {
        if (this.isCustomMinValue) {
            d = this.minValue
        } else {
            this.minValue = d
        }
        if (this.isCustomMaxValue) {
            a = this.maxValue
        } else {
            this.maxValue = a
        }
        if (this.isLog) {
            if (this.isCustomMainUnit) {
                this.tickLength = this.tickLength
            } else {
                this.tickLength = this.baseLog
            }
            this.smallTickLength = this.tickLength / 5
        } else {
            if (a - d > 0) {
                if (this.isCustomMainUnit) {
                    if (this.isPercentage) {
                        this.tickLength = this.tickLength
                    }
                } else {
                    this.tickLength = FR.Chart.AxisGlyph.calculateIncrement(this.minValue, this.maxValue)
                }
                if (!this.isCustomSecUnit) {
                    this.smallTickLength = this.tickLength / 5
                }
            }
        }
        if (this.isLog) {
            if (!this.isCustomMinValue) {
                if (this.minValue <= 1e-10) {
                    this.minValue = 1
                } else {
                    if (this.minValue < 1) {
                        this.minValue = Math.pow(this.tickLength, Math.round(Math.log(this.minValue) / Math.log(this.tickLength) - 1))
                    } else {
                        if (this.minValue >= 1) {
                            this.minValue = 1
                        }
                    }
                }
            }
            if (!this.isCustomMaxValue) {
                if (this.maxValue <= 0) {
                    this.maxValue = 10
                }
            }
        } else {
            var c = parseInt(Math.abs(this.minValue) / this.tickLength);
            if (this.isCustomMinValue) {
            } else {
                if (this.minValue < 0) {
                    this.minValue = -(c + 1) * this.tickLength
                } else {
                    if (this.minValue > 0) {
                        this.minValue = c * this.tickLength
                    }
                }
            }
            var b = parseInt((this.maxValue - this.minValue) / this.tickLength);
            var e = (this.maxValue - this.minValue) / this.tickLength;
            if (e == b) {
                if (!this.isPercentage) {
                    b += 1
                }
            } else {
                b += 1
            }
            if (!this.isCustomMaxValue) {
                this.maxValue = this.minValue + b * this.tickLength
            }
        }
        if (this.minValue >= this.maxValue) {
            if (this.tickLength > 0) {
                this.maxValue = this.minValue + this.tickLength * 3
            } else {
                this.maxValue = this.minValue + 10;
                this.tickLength = 2;
                this.smallTickLength = this.tickLength / 5
            }
        }
        this.zoomTickLength = this.smallTickLength
    }
});
$.extend(FR.Chart.NumberAxisGlyph, {UNIT_HEIGHT: 16});
FR.Chart.ValueAxisGlyph = FR.extend(FR.Chart.NumberAxisGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.alignZeroValue = a.alignZeroValue;
        this.markAxisType = "valueaxis";
        this.AUTO_WRAP_WIDTH = 0.12;
        FR.Chart.ValueAxisGlyph.superclass.initConstants.apply(this, [a])
    }, initConfig: function (a) {
        this.minValue = a.minValue || 0;
        this.maxValue = a.maxValue || 0;
        this.tickLength = a.tickLength || 0;
        this.smallTickLength = this.tickLength / 5
    }, getMaxLabelWidthAndInitStartEndLabelDim: function () {
        if (!this.isShowAxisLabel) {
            return 0
        }
        var h = 8;
        var i = this.minValue;
        var e = this.maxValue;
        var j = 1;
        if (this.isCustomMainUnit) {
            j = this.tickLength
        } else {
            if (this.isLog) {
                j = this.baseLog
            } else {
                j = FR.Chart.AxisGlyph.calculateIncrement(i, e)
            }
        }
        if (j <= 0) {
            return h
        }
        var k = 1;
        var f = this.showUnit;
        if (f != null) {
            k = FR.Chart.ValueAxisGlyph.getDivideUnit(f)
        }
        j = this.checkIncrementNotTooSmall(j, e - i);
        for (var b = i; b <= e; b = this.isLog ? b * j : b + j) {
            var c = this.getAxisLabelDim(this.value2String(b / k));
            if (b == i) {
                this.startLabelDim = c
            } else {
                this.endLabelDim = c
            }
            var d = this.shouldBeHeight() ? c.height : c.width;
            h = (d < h ? h : d)
        }
        var a = this.getAxisLabelDim(this.value2String(this.tickLength));
        var g = this.shouldBeHeight() ? a.height : a.width;
        return Math.max(g, h)
    }, checkIncrementNotTooSmall: function (a, c) {
        if (!this.isLog) {
            var b = a * 1000;
            if (b < c) {
                return this.getTickSamplingTime()
            }
        }
        return a
    }, getMaxLabelWidth: function () {
        if (!this.isShowAxisLabel) {
            return 0
        }
        var c = 8;
        var e = this.minValue;
        var g = this.maxValue;
        var b = 1;
        if (this.isCustomMainUnit) {
            b = this.tickLength
        } else {
            if (this.isLog) {
                b = this.baseLog
            } else {
                b = FR.Chart.AxisGlyph.calculateIncrement(e, g)
            }
        }
        if (b <= 0) {
            return c
        }
        b = this.checkIncrementNotTooSmall(b, g - e);
        for (var d = e; d <= g; d = this.isLog ? d * b : d + b) {
            var f = this.getAxisLabelDim(this.value2String(d));
            var a = this.shouldBeHeight() ? f.width : f.height;
            c = (a < c ? c : a)
        }
        return c
    }, dealPlotBoundsWithAxisLabel: function (a) {
        FR.Chart.ValueAxisGlyph.superclass.dealPlotBoundsWithAxisLabel.apply(this, [a]);
        this.dealPlotBoundsWithAlert(a)
    }, dealPlotBoundsWithAlert: function (f) {
        this.dealAlertLabelWidth();
        var e = f.x, c = f.y;
        var g = ((this.maxLeftAlert > 0) ? this.maxLeftAlert + FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP : 0);
        var a = ((this.maxRightAlert > 0) ? this.maxRightAlert + FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP : 0);
        var h = ((this.showUnit || this.unitPadding) && this.isShowAxisLabel) ? this.getMaxLabelWidth() : 0;
        var d = this.getPreUnitPadding();
        h += d;
        var i = this.textAttr;
        var b = 0;
        if (i && i.frFont) {
            b = i.frFont.size
        }
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            f.x = e + g;
            f.width = f.width - g - a;
            if (this.axisReversed) {
                f.height = f.height - h - b / 2 - FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL
            }
        } else {
            f.y = c + a;
            f.height = f.height - a - g;
            f.width -= h;
            if (this.axisReversed) {
                f.x = e + h
            }
        }
    }, getPreUnitPadding: function () {
        var a = new FR.Chart.TextGlyph();
        a.text = this.unitPadding;
        var b = a.preferredDimension();
        return this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT ? b.height : b.width
    }, getPreLeftWidth4DataSheet: function () {
        this.calculateTitleDimesion();
        this.dealAlertLabelWidth();
        if (this.position == FR.Chart.Constants.LEFT) {
            return this.getMaxLabelWidthAndInitStartEndLabelDim() + this.maxLeftAlert + this.titleDim.width + this.getTickLengthShow()
        } else {
            if (this.position == FR.Chart.Constants.RIGHT) {
                return this.getTickLengthShow() + this.maxLeftAlert
            } else {
                return 0
            }
        }
    }, dealAlertLabelWidth: function () {
        this.maxLeftAlert = 0;
        this.maxRightAlert = 0;
        for (var g = 0; g < this.alertValueList.length; g++) {
            var d = this.alertValueList[g];
            var a = new FR.Chart.TextAttr();
            a.frFont = d.alertFont;
            var c = d.alertContent;
            var b = d.formula;
            var e = "";
            if (b != null) {
                if (b instanceof Array) {
                    for (var g = 0; g < b.length; g++) {
                        if (b[g] <= this.getArrowValue() && b[g] >= this.getCrossValue()) {
                            e = "(" + this.value2String(b[g]) + ")"
                        }
                    }
                } else {
                    if (b <= this.getArrowValue() && b >= this.getCrossValue()) {
                        e = "(" + this.value2String(b) + ")"
                    }
                }
            }
            if ((this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) && this.plotZeroBounds != null) {
                c = FR.Chart.ChartUtils.dealLabelStringAutoWrap(c + e, a, this.plotZeroBounds.width * this.AUTO_WRAP_WIDTH)
            }
            var h = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, a);
            var f = (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) ? h.width : h.height;
            if (d.alertPosition == FR.Chart.Constants.LEFT) {
                this.maxLeftAlert = Math.max(f, this.maxLeftAlert)
            } else {
                this.maxRightAlert = Math.max(f, this.maxRightAlert)
            }
        }
    }, calculateAxisLengthUnit: function () {
        if (this.isLog) {
            this.unitLength = this.axisLength / (Math.log(this.maxValue) / Math.log(this.tickLength) - Math.log(this.minValue) / Math.log(this.tickLength))
        } else {
            if (this.maxValue - this.minValue > 0) {
                this.unitLength = this.axisLength / (this.getArrowValue() - this.getCrossValue())
            }
        }
    }, getTickSamplingTime: function () {
        var d = 1;
        var c = (this.maxValue - this.minValue) / this.tickLength;
        if (this.isLog) {
            var b = Math.abs(this.maxValue - this.minValue);
            var a = 0;
            while (Math.pow(this.tickLength, a) < b) {
                if (Math.pow(this.tickLength, a + 1) > b) {
                    c = a;
                    break
                }
                a++
            }
        }
        var e = this.axisLength / 15;
        var f = Math.abs(c);
        while (e < Math.ceil(f / d)) {
            d++;
            if (d > 1000) {
                d = parseInt(c / 20);
                break
            }
        }
        return d
    }, getCrossValue: function () {
        return this.minValue - this.zoomBackward
    }, getArrowValue: function () {
        return this.maxValue + this.zoomForward
    }, getOriginalCrossValue: function () {
        return this.minValue
    }, getOriginalArrowValue: function () {
        return this.maxValue
    }, getPointInBounds: function (a) {
        if (!(this.isLog && this.getCrossValue() > 0)) {
            if (a < this.getCrossValue()) {
                a = this.getCrossValue()
            }
            if (a > this.getArrowValue()) {
                a = this.getArrowValue()
            }
        }
        return this.getPoint2D(a)
    }, getPointValue4TrendLine: function (a, b) {
        var d = this.getCrossValue();
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            if (a > this.bounds.height) {
                d = this.getCrossValue()
            }
            if (a < 0) {
                d = this.maxValue
            }
            d = (this.originPoint.y - a) / this.unitLength;
            if (this.isLog && this.getCrossValue() > 0) {
                d = Math.pow(Math.E, d * Math.log(this.tickLength) + Math.log(this.getCrossValue()))
            }
        } else {
            if (b > this.bounds.width) {
                d = this.maxValue
            }
            if (b < 0) {
                d = this.getCrossValue()
            }
            d = (b - this.originPoint.y) / this.unitLength;
            if (this.isLog && this.getCrossValue() > 0) {
                d = Math.pow(Math.E, d * Math.log(this.tickLength) + Math.log(this.getCrossValue()))
            }
        }
        var c = this.value2String(d);
        if (this.format == null) {
            c = FR.contentFormat(d, "#.##")
        }
        return c
    }, getPoint2D: function (b) {
        if (this.isLog && this.getCrossValue() > 0) {
            if (b <= 1e-10) {
                b = this.getCrossValue()
            }
            b = (Math.log(b) - Math.log((this.isDraw4Demo ? this.minValue : this.getCrossValue()))) / Math.log(this.tickLength)
        } else {
            b = b - (this.isDraw4Demo ? this.minValue : this.getCrossValue())
        }
        if (this.originPoint == null) {
            return new FR.Chart.Point2D(0, 0)
        }
        var a = this.axisReversed ? -this.unitLength * b : this.unitLength * b;
        var c = this.axisReversed ? this.unitLength * b : -this.unitLength * b;
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            return new FR.Chart.Point2D(this.originPoint.x, this.originPoint.y + c)
        } else {
            return new FR.Chart.Point2D(this.originPoint.x + a, this.originPoint.y)
        }
    }, drawAxisGrid: function (c) {
        if (this.axisLength <= 15) {
            return
        }
        var a = this.getTickSamplingTime();
        if (!c) {
            return
        }
        c.save();
        if (this.mainGridStyle != FR.Chart.Constants.LINE_NONE && this.tickLength > 0 && this.mainGridColor != null) {
            c.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.mainGridStyle);
            c.strokeStyle = this.mainGridColor;
            if (this.isLog) {
                if (this.tickLength > 1) {
                    for (var f = this.getCrossValue(), e = Math.log(f) / Math.log(this.tickLength); f <= this.getArrowValue(); f = Math.exp((++e) * Math.log(this.tickLength))) {
                        var b = this.getGridLine(f);
                        for (var d = 0; d < b.length; d++) {
                            FR.Chart.GraphHelper.dealLine4JSDraw(b[d]);
                            b[d].draw(c)
                        }
                    }
                }
            } else {
                for (var f = this.getCrossValue() * a; f <= this.getArrowValue(); f += this.tickLength * a) {
                    var b = this.getGridLine(f);
                    for (var e = 0; e < b.length; e++) {
                        FR.Chart.GraphHelper.dealLine4JSDraw(b[e]);
                        b[e].draw(c)
                    }
                }
            }
        }
        c.restore()
    }, drawAlertValueLines: function (c) {
        if (this.alertValueList) {
            if (!c) {
                return
            }
            c.save();
            for (var f = 0; f < this.alertValueList.length; f++) {
                var g = this.alertValueList[f];
                c.globalAlpha = g.alertLineAlpha;
                c.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(g.attrLineStyle.lineStyle);
                if (g.attrLineColor.seriesColor == null) {
                    continue
                }
                c.strokeStyle = g.attrLineColor.seriesColor;
                var b = g.formula;
                if (b != null) {
                    if (b instanceof Array) {
                        for (var e = 0; e < b.length; e++) {
                            if (b[e] <= this.getArrowValue() && b[e] >= this.getCrossValue()) {
                                var a = this.getGridLine(b[e]);
                                for (var d = 0; d < a.length; d++) {
                                    FR.Chart.GraphHelper.dealLine4JSDraw(a[d]);
                                    a[d].draw(c)
                                }
                            }
                        }
                    } else {
                        if (b <= this.getArrowValue() && b >= this.getCrossValue()) {
                            var a = this.getGridLine(b);
                            for (var e = 0; e < a.length; e++) {
                                FR.Chart.GraphHelper.dealLine4JSDraw(a[e]);
                                a[e].draw(c)
                            }
                        }
                    }
                }
            }
            c.restore()
        }
    }, drawAxisLine: function (b) {
        if (!b) {
            return
        }
        b.save();
        if (this.minValue == this.maxValue) {
            return
        }
        if (this.lineColor && this.lineStyle != FR.Chart.Constants.LINE_NONE) {
            b.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.lineStyle);
            b.strokeStyle = this.lineColor;
            var a = new FR.Chart.Line2D(this.getPoint2D(this.minValue), this.getPoint2D(this.maxValue));
            FR.Chart.GraphHelper.dealLine4JSDraw(a);
            a.draw(b);
            this.drawArrow(b, a.startPoint, a.endPoint)
        }
        this.drawTicks(b);
        b.restore()
    }, drawTicks: function (c) {
        if (this.axisLength <= 15) {
            return
        }
        var a = this.getTickSamplingTime();
        if (this.isLog) {
            if (this.tickLength > 1) {
                for (var g = this.getCrossValue(), f = Math.log(g) / Math.log(this.tickLength); g <= this.getArrowValue(); g = Math.exp((++f) * Math.log(this.tickLength))) {
                    var b = this.getTickLine(g, FR.Chart.AxisGlyph.MAIN_TICK_LENGTH, this.tickMarkType);
                    this.drawTickLine(c, b, FR.Chart.Constants.AxisTickWidth)
                }
            }
            if (this.smallTickLength > 1) {
                var g = this.getCrossValue(), f = 0;
                for (var d = 0; g <= this.getArrowValue(); g += f, d++) {
                    if (d % 5 === 0) {
                        f = (Math.pow(this.tickLength, Math.log(g) / Math.log(this.tickLength) + 1) - g) / 5;
                        continue
                    }
                    var b = this.getTickLine(g, FR.Chart.AxisGlyph.SEC_TICK_LENGTH, this.secTickMarkType);
                    this.drawTickLine(c, b, FR.Chart.Constants.AxisTickWidth)
                }
            }
        } else {
            if (this.getArrowValue() > this.getCrossValue() && this.tickLength > 0 && this.smallTickLength > 0) {
                var e = this.tickLength * a;
                for (var g = this.getCrossValue() + e; g <= this.getArrowValue(); g += e) {
                    var b = this.getTickLine(g, FR.Chart.AxisGlyph.MAIN_TICK_LENGTH, this.tickMarkType);
                    this.drawTickLine(c, b, FR.Chart.Constants.AxisTickWidth)
                }
                if (a === 1) {
                    for (var g = this.getCrossValue() + this.smallTickLength;
                         g <= this.getArrowValue(); g += this.smallTickLength) {
                        var b = this.getTickLine(g, FR.Chart.AxisGlyph.SEC_TICK_LENGTH, this.secTickMarkType);
                        this.drawTickLine(c, b, FR.Chart.Constants.AxisTickWidth)
                    }
                }
            }
        }
        this.drawTickLabel(c);
        this.drawAlertLinesLabel(c)
    }, drawTickLabel: function (c) {
        if (this.axisLength <= 15) {
            return
        }
        var e = 1;
        var b = this.getTickSamplingTime();
        var a = this.showUnit;
        if (a != null) {
            e = FR.Chart.ValueAxisGlyph.getDivideUnit(a)
        }
        this.drawUnitGlyph(c, a);
        var d = (this.labelNumber > 0 ? this.labelNumber : b);
        var h = new FR.Chart.BoundsManager();
        if (this.isLog) {
            if (this.tickLength > 1) {
                for (var f = this.getCrossValue(); FR.Chart.ChartUtils.compareDouble(f, this.getArrowValue(), FR.Chart.Compare.LESS_THAN_OR_EQUAL); f *= Math.pow(this.tickLength, d)) {
                    var g = f / e;
                    this.drawLabel(c, f, 0, this.value2String(g))
                }
            }
        } else {
            if (this.getArrowValue() > this.getCrossValue() && this.tickLength > 0 && this.smallTickLength > 0) {
                for (var f = this.getCrossValue(); FR.Chart.ChartUtils.compareDouble(f, this.getArrowValue(), FR.Chart.Compare.LESS_THAN_OR_EQUAL); f += (this.tickLength * d)) {
                    var g = f / e;
                    this.drawLabelWithPath(c, f, 0, this.value2String(g), h)
                }
            }
        }
    }, drawUnitGlyph: function (i, e) {
        e = e ? FR.Chart.ValueAxisGlyph.getUnitKye2Value(e) : "";
        var g = new FR.Chart.TextGlyph();
        g.text = e + this.unitPadding;
        var d = g.preferredDimension();
        var f = this.getMaxLabelWidth();
        var h = this.textAttr;
        var a = 0;
        if (h && h.frFont) {
            a = h.frFont.size
        }
        var c = null;
        if (this.position == FR.Chart.Constants.TOP) {
            if (this.axisReversed) {
                c = new FR.Chart.Bounds(-d.width - FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL - f / 2, d.height, d.width, d.height)
            } else {
                c = new FR.Chart.Bounds(this.bounds.width + f + FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL, +d.height, d.width, d.height)
            }
        } else {
            if (this.position == FR.Chart.Constants.LEFT) {
                if (this.axisReversed) {
                    c = new FR.Chart.Bounds(0, this.bounds.height + FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL + a / 2, d.width, d.height)
                } else {
                    c = new FR.Chart.Bounds(0, -d.height - FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL - a / 2, d.width, d.height)
                }
            } else {
                if (this.position == FR.Chart.Constants.BOTTOM) {
                    if (this.axisReversed) {
                        c = new FR.Chart.Bounds(-d.width - FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL - f / 2, -d.height / 2, d.width, d.height)
                    } else {
                        c = new FR.Chart.Bounds(this.bounds.width + f / 2 + FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL, -d.height / 2, d.width, d.height)
                    }
                } else {
                    if (this.position == FR.Chart.Constants.RIGHT) {
                        if (this.axisReversed) {
                            c = new FR.Chart.Bounds(f - d.width, this.bounds.height + FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL + a / 2, d.width, d.height)
                        } else {
                            c = new FR.Chart.Bounds(f - d.width, -d.height - FR.Chart.ValueAxisGlyph.UNIT_GAP_LABEL - a / 2, d.width, d.height)
                        }
                    }
                }
            }
        }
        var b = this.getBounds();
        c.x += b.x;
        c.y += b.y;
        g.bounds = c;
        g.draw(i)
    }, drawAlertLinesLabel: function (l) {
        if (this.alertValueList == null) {
            return
        }
        var b = [];
        for (var c = 0; c < this.alertValueList.length; c++) {
            var a = this.alertValueList[c];
            var e = a.formula;
            if (e != null) {
                if (e instanceof Array) {
                    for (var f = 0; f < e.length; f++) {
                        if (e[f] >= this.minValue && e[f] <= this.maxValue) {
                            this.addAlertValueInOrder(b, e[f], a)
                        }
                    }
                } else {
                    if (e >= this.minValue && e <= this.maxValue) {
                        this.addAlertValueInOrder(b, e, a)
                    }
                }
            }
        }
        var m = new FR.Chart.BoundsManager();
        var h = new FR.Chart.BoundsManager();
        for (var c = 0; c < b.length; c++) {
            var j = b[c];
            var g = j[0];
            var d = j[1];
            var k = a.alertPosition == FR.Chart.Constants.LEFT ? h : m;
            this.drawAlertValueLabel(l, g, d, k)
        }
    }, addAlertValueInOrder: function (f, d, c) {
        var b = [];
        b[0] = d;
        b[1] = c;
        for (var h = 0; h < f.length; h++) {
            var a = f[h];
            var g = a[0];
            if (g > d) {
                for (var e = f.length; e > h; e--) {
                    f[e] = f[e - 1]
                }
                f[h] = b;
                return
            }
        }
        f[f.length] = b
    }, drawAlertValueLabel: function (h, f, a, i) {
        var e = this.getPoint2D(f);
        var c = a.alertFont.color;
        var d = new FR.Chart.TextAttr();
        if (a.attrLineColor.seriesColor != null) {
            a.alertFont.color = a.attrLineColor.seriesColor
        }
        d.frFont = a.alertFont;
        var g = a.alertContent;
        if (g == "") {
            return
        }
        g = g + "(" + this.value2String(f) + ")";
        if ((this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) && this.plotZeroBounds != null) {
            g = FR.Chart.ChartUtils.dealLabelStringAutoWrap(g, d, this.plotZeroBounds.width * this.AUTO_WRAP_WIDTH)
        }
        var b = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(g, d);
        FR.Chart.TextUtils.drawLabelWithRotation(h, g, d, this.getAlertLabelBounds(e, b, i, a.alertPosition));
        a.alertFont.color = c
    }, getAlertLabelBounds: function (e, g, b, f) {
        var a = 0, h = 0;
        var d = this._getAlertBounds(f);
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            a = d.x;
            h = e.y - g.height / 2
        } else {
            a = e.x - g.width / 2;
            h = d.y
        }
        var c = new FR.Chart.Bounds(a, h, g.width, g.height);
        return this.dealIntersectsBounds(d, b, c)
    }, dealIntersectsBounds: function (c, b, a) {
        var e = true;
        if (this.position == FR.Chart.Constants.TOP || this.position == FR.Chart.Constants.BOTTOM) {
            if (a.x + a.width > c.x + c.width) {
                e = false
            }
        }
        var d = false;
        if (!b.isEmpty()) {
            while (b.isInteract(a) && !d) {
                d = this._moveResultBounds(a, e)
            }
        } else {
            while (!c.contains(a.x, a.y, a.width, a.height) && !d) {
                d = this._moveResultBounds(a, e)
            }
        }
        if (!c.contains(a.x, a.y, a.width, a.height)) {
            return null
        } else {
            b.addBounds(a)
        }
        return a
    }, _moveResultBounds: function (a, b) {
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            a.y = a.y - 4;
            if (this.bounds.y > a.y) {
                return true
            }
        } else {
            if (b) {
                a.x += 4;
                if (this.bounds.x + this.bounds.width < a.x) {
                    return true
                }
            } else {
                a.x -= 4;
                if (this.bounds.x > a.x) {
                    return true
                }
            }
        }
        return false
    }, _getAlertBounds: function (e) {
        var d = 20;
        var a = (this.titleDim.width === 0) ? 0 : this.titleDim.width + FR.Chart.AxisGlyph.LINE_LABEL_GAP;
        var c = (this.titleDim.height === 0) ? 0 : this.titleDim.height + FR.Chart.AxisGlyph.LINE_LABEL_GAP;
        var b = a + this.axisLabelWidth;
        var f = c + this.axisLabelWidth;
        if (this.position == FR.Chart.Constants.LEFT) {
            return this._getAlertBoundsWhenAtLeft(e, b, d)
        } else {
            if (this.position == FR.Chart.Constants.TOP) {
                return this._getAlertBoundsWhenAtTop(e, f, d)
            } else {
                if (this.position == FR.Chart.Constants.RIGHT) {
                    return this._getAlertBoundsWhenAtRight(e, b, d)
                } else {
                    return this._getAlertBoundsWhenOther(e, f, d)
                }
            }
        }
    }, _getAlertBoundsWhenAtLeft: function (d, b, c) {
        var a;
        if (d == FR.Chart.Constants.LEFT) {
            a = this.originPoint.x - this.maxLeftAlert - FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP - b
        } else {
            a = this.originPoint.x + this.plotZeroBounds.width - this.plotLastBounds.x + this.plotZeroBounds.x - this.maxRightAlert
        }
        return new FR.Chart.Bounds(a, this.bounds.y - c, d == FR.Chart.Constants.LEFT ? this.maxLeftAlert : this.maxRightAlert, this.bounds.height + c)
    }, _getAlertBoundsWhenAtTop: function (b, d, a) {
        var c;
        if (b == FR.Chart.Constants.LEFT) {
            c = this.originPoint.y
        } else {
            c = this.originPoint.y - this.maxRightAlert - FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP - d
        }
        return new FR.Chart.Bounds(this.bounds.x - this.maxLeftAlert, c, this.bounds.width + this.maxLeftAlert + this.maxRightAlert, b == FR.Chart.Constants.LEFT ? this.maxLeftAlert : this.maxRightAlert)
    }, _getAlertBoundsWhenAtRight: function (d, b, c) {
        var a;
        if (d == FR.Chart.Constants.LEFT) {
            a = this.plotZeroBounds.x
        } else {
            a = this.originPoint.x + b + FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP
        }
        return new FR.Chart.Bounds(a, this.bounds.y - c, d == FR.Chart.Constants.LEFT ? this.maxLeftAlert : this.maxRightAlert, this.bounds.height + c)
    }, _getAlertBoundsWhenOther: function (b, d, a) {
        var c;
        if (b == FR.Chart.Constants.LEFT) {
            c = this.originPoint.y + FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP + d
        } else {
            c = this.originPoint.y - this.axisGridLength - this.maxRightAlert - FR.Chart.ValueAxisGlyph.ALERT_LABEL_LINE_GAP
        }
        return new FR.Chart.Bounds(this.bounds.x - this.maxLeftAlert, c, this.bounds.width + this.maxLeftAlert + this.maxRightAlert, b == FR.Chart.Constants.LEFT ? this.maxLeftAlert : this.maxRightAlert)
    }, _drawValueAxisBackground: function (b) {
        if (!b) {
            return
        }
        b.save();
        b.globalAlpha = 0.18;
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            var a = b.createLinearGradient(this.bounds.x, this.bounds.y + this.bounds.height, this.bounds.x, this.bounds.y);
            a.addColorStop(0, "rgb(145,151,156)");
            a.addColorStop(1, "rgb(198,205,210)");
            b.fillStyle = a;
            this.bounds.paint(b)
        } else {
            if (this.position == FR.Chart.Constants.BOTTOM) {
                var a = b.createLinearGradient(this.bounds.x, this.bounds.y, this.bounds.x + this.bounds.width, this.bounds.y);
                a.addColorStop(0, "rgb(145,151,156)");
                a.addColorStop(1, "rgb(198,205,210)");
                b.fillStyle = a;
                this.bounds.paint(b)
            }
        }
        b.restore()
    }, draw4ThreeD: function (a) {
        this._drawValueAxisBackground(a);
        this.drawTickLabel(a);
        this._drawAxisTitle(a)
    }, getCateLabelWidth: function (b) {
        if (this.cubic) {
            var a = this.getMaxLabelWidthAndInitStartEndLabelDim();
            a += 2 * FR.Chart.ValueAxisGlyph.LABEL_GAP;
            a = Math.max(FR.Chart.ValueAxisGlyph.DEFAULT_WIDTH, a);
            if (this.shouldBeHeight()) {
                return Math.min(b.height * FR.Chart.ValueAxisGlyph.MAX_LABEL_PERCENT, a)
            } else {
                return Math.min(b.width * FR.Chart.ValueAxisGlyph.MAX_LABEL_PERCENT, a)
            }
        } else {
            return FR.Chart.ValueAxisGlyph.superclass.getCateLabelWidth.apply(this, [b])
        }
    }
});
$.extend(FR.Chart.ValueAxisGlyph, {
    UNIT_STRING: ["DataFunction_None", "Unit_Hundred", "Unit_Thousand", "Unit_Ten_Thousand", "Unit_Hundred_Thousand", "Unit_Million", "Unit_Ten_Million", "Unit_Hundred_Million", "Unit_Billion"],
    UNIT_STRING_VALUES: [FR.i18nText("Chart-DataFunction_None"), FR.i18nText("Chart-Unit_Hundred"), FR.i18nText("Chart-Unit_Thousand"), FR.i18nText("Chart-Unit_Ten_Thousand"), FR.i18nText("Chart-Unit_Hundred_Thousand"), FR.i18nText("Chart-Unit_Million"), FR.i18nText("Chart-Unit_Ten_Million"), FR.i18nText("Chart-Unit_Hundred_Million"), FR.i18nText("Chart-Unit_Billion")],
    unit: null,
    UNIT_GAP_LABEL: 3,
    ALERT_LABEL_LINE_GAP: 2,
    DEFAULT_WIDTH: 30,
    MAX_LABEL_PERCENT: 0.28,
    LABEL_GAP: 8,
    getUnitKye2Value: function (b) {
        if (!FR.Chart.ValueAxisGlyph.unitKey2Value) {
            FR.Chart.ValueAxisGlyph.unitKey2Value = new FR.Chart.HashMap();
            for (var a = 1; a < FR.Chart.ValueAxisGlyph.UNIT_STRING.length; a++) {
                FR.Chart.ValueAxisGlyph.unitKey2Value.put(FR.Chart.ValueAxisGlyph.UNIT_STRING[a], FR.Chart.ValueAxisGlyph.UNIT_STRING_VALUES[a])
            }
        }
        if (FR.Chart.ValueAxisGlyph.unit.containsKey(b)) {
            return FR.Chart.ValueAxisGlyph.unitKey2Value.get(b)
        }
        return FR.i18nText("Chart-DataFunction_None")
    },
    getDivideUnit: function (b) {
        if (!FR.Chart.ValueAxisGlyph.unit) {
            FR.Chart.ValueAxisGlyph.unit = new FR.Chart.HashMap();
            FR.Chart.ValueAxisGlyph.unit.put(FR.Chart.ValueAxisGlyph.UNIT_STRING[0], 1);
            var c = 100;
            for (var a = 1; a < FR.Chart.ValueAxisGlyph.UNIT_STRING.length; a++) {
                FR.Chart.ValueAxisGlyph.unit.put(FR.Chart.ValueAxisGlyph.UNIT_STRING[a], c);
                c *= 10
            }
            FR.Chart.ValueAxisGlyph.unit.put("10000", 10000);
            FR.Chart.ValueAxisGlyph.unit.put("100000", 100000);
            FR.Chart.ValueAxisGlyph.unit.put("10000000", 10000000);
            FR.Chart.ValueAxisGlyph.unit.put("100000000", 100000000)
        }
        if (FR.Chart.ValueAxisGlyph.unit.containsKey(b)) {
            return FR.Chart.ValueAxisGlyph.unit.get(b)
        }
        return 1
    }
});
FR.Chart.RadarAxisGlyph = FR.extend(FR.Chart.NumberAxisGlyph, {
    initConstants: function (b) {
        b = b || {};
        this.categoryCount = FR.pick(b.categoryCount, 0);
        this.labelList = [];
        if (b.labelList && b.labelList.length > 0) {
            for (var a = 0; a < b.labelList.length; a++) {
                this.labelList.push(b.labelList[a])
            }
        }
        this.radarMin = [];
        if (b.radarMin) {
            for (var a = 0; a < b.radarMin.length; a++) {
                this.radarMin[a] = b.radarMin[a]
            }
        }
        this.radarMax = [];
        if (b.radarMax) {
            for (var a = 0; a < b.radarMax.length; a++) {
                this.radarMax[a] = b.radarMax[a]
            }
        }
        this.isAllMaxMin = FR.pick(b.isAllMaxMin, true);
        FR.Chart.RadarAxisGlyph.superclass.initConstants.apply(this, [b]);
        this.D = 0;
        this.radian = 0
    }, configLabels: function (a) {
        this.labelList = a || [];
        this.categoryCount = a.length
    }, init: function (a) {
        this.bounds = a;
        this.originPoint = new FR.Chart.Point2D(a.x + a.width / 2, a.y + a.height / 2);
        this.D = Math.min(a.width, a.height);
        this.radian = Math.PI * 2 / this.categoryCount;
        this.axisLength = this.D / 2
    }, getMaxLabelWidthAndInitStartEndLabelDim: function () {
        if (!this.isShowAxisLabel) {
            return 0
        }
        var b = 8;
        for (var e = 0; e < this.categoryCount; e++) {
            var f = this._getCateMin(e);
            var c = this._getCateMax(e);
            var d = FR.Chart.AxisGlyph.calculateIncrement(f, c);
            if (d <= 0) {
                continue
            }
            for (var g = f; g <= c; g += d) {
                var a = this.getAxisLabelWidth(this.value2String(g));
                b = (a < b ? b : a)
            }
        }
        return b
    }, dealPlotBoundsWithAxisLabel: function (h) {
        var a = 8;
        var d = 8;
        var e = this.labelList.length;
        for (var c = 0; c < e; c++) {
            var g = this.labelList[c];
            var f = FR.Chart.TextUtils.calculateTextDimensionWithRotation(g, new FR.Chart.TextAttr()).width;
            if (c < e / 2) {
                a = Math.max(f, a)
            } else {
                d = Math.max(f, d)
            }
        }
        var b = this.getMaxLabelWidthAndInitStartEndLabelDim();
        var j = 12;
        a = Math.max(a, 12);
        d = Math.max(d, 12);
        if (this.textAttr.alignText == FR.Chart.Style.VERTICALTEXT) {
            j = Math.max(12, b)
        }
        h.x = h.x + a;
        h.y = h.y + j;
        h.width = h.width - a - d;
        h.height = h.height - j * 3
    }, getPreLeftWidth4DataSheet: function () {
        return 0
    }, calculateAxisLengthUnit: function () {
        this.unitLength = this.axisLength / (this.getArrowValue() - this.getCrossValue())
    }, _getCateMin: function (a) {
        if (a >= 0 && a < this.radarMin.length) {
            return this.radarMin[a]
        }
        return this.getCrossValue()
    }, _getCateMax: function (a) {
        if (a >= 0 && a < this.radarMax.length) {
            return this.radarMax[a]
        }
        return this.maxValue
    }, getPointInBounds: function (d, c) {
        var b = this._getCateMin(d);
        var a = this._getCateMax(d);
        if (c < b) {
            c = b
        }
        if (c > a) {
            c = a
        }
        return this.getPoint2D(d, c)
    }, getPoint2D: function (f, e) {
        var d = this._getCateMin(f);
        var b = this._getCateMax(f);
        var c = e - d;
        var a = this.axisLength / (b - d);
        return new FR.Chart.Point2D(this.originPoint.x + Math.cos(this.radian * f + Math.PI / 2) * c * a, this.originPoint.y - Math.sin(this.radian * f + Math.PI / 2) * c * a)
    }, drawAxisGrid: function (b) {
        if (!this.isAllMaxMin) {
            return
        }
        if (!b) {
            return
        }
        b.save();
        if (this.mainGridStyle != FR.Chart.Constants.LINE_NONE && this.tickLength > 0 && this.mainGridColor != null) {
            b.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.mainGridStyle);
            b.strokeStyle = this.mainGridColor;
            for (var d = this.getCrossValue(); d <= this.maxValue; d += this.tickLength) {
                var a = this.getGridLine(d);
                for (var c = 0; c < a.length; c++) {
                    FR.Chart.GraphHelper.dealLine4JSDraw(a[c]);
                    a[c].draw(b)
                }
            }
        }
        b.restore()
    }, getGridLine: function (c) {
        var a = [];
        for (var b = 0; b < this.categoryCount; b++) {
            a[b] = new FR.Chart.Line2D(this.getPoint2D(b, c), this.getPoint2D(b + 1, c))
        }
        return a
    }, drawAxisLine: function (c) {
        if (!c) {
            return
        }
        c.save();
        var e = new FR.Chart.BoundsManager();
        if (this.lineColor && this.lineStyle != FR.Chart.Constants.LINE_NONE) {
            c.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.lineStyle);
            c.strokeStyle = this.lineColor;
            var b = this._getAxisLines();
            for (var d = 0; d < b.length; d++) {
                var a = b[d];
                FR.Chart.GraphHelper.dealLine4JSDraw(a);
                a.draw(c);
                this.drawArrow(c, a.startPoint, a.endPoint);
                if (this.isArrowShow) {
                    this.drawCateLabel(c, d, a.endPoint, 20, e)
                } else {
                    this.drawCateLabel(c, d, a.endPoint, 0, e)
                }
            }
        }
        this.drawTicks(c, e);
        c.restore()
    }, paintRadarBackground: function (a, b) {
        if (this.isAllMaxMin) {
            if (!a) {
                return
            }
            a.save();
            if (this.tickLength > 0 && b != null) {
                a.fillStyle = b;
                for (var c = this.getCrossValue(); c <= this.maxValue - this.tickLength;
                     c += this.tickLength * 2) {
                    this.getRadarPath(c, this.tickLength, a)
                }
            }
            a.restore()
        }
    }, getRadarPath: function (d, c, a) {
        for (var b = 0; b < this.categoryCount; b++) {
            if (b == this.categoryCount - 1) {
                a.beginPath();
                a.moveTo(this.getPoint2D(b, d).x, this.getPoint2D(b, d).y);
                a.lineTo(this.getPoint2D(0, d).x, this.getPoint2D(0, d).y);
                a.lineTo(this.getPoint2D(0, d + c).x, this.getPoint2D(0, d + c).y);
                a.lineTo(this.getPoint2D(b, d + c).x, this.getPoint2D(b, d + c).y);
                a.fill()
            } else {
                a.beginPath();
                a.moveTo(this.getPoint2D(b, d).x, this.getPoint2D(b, d).y);
                a.lineTo(this.getPoint2D(b + 1, d).x, this.getPoint2D(b + 1, d).y);
                a.lineTo(this.getPoint2D(b + 1, d + c).x, this.getPoint2D(b + 1, d + c).y);
                a.lineTo(this.getPoint2D(b, d + c).x, this.getPoint2D(b, d + c).y);
                a.fill()
            }
        }
    }, drawTicks: function (o, m) {
        for (var c = 0; c < this.categoryCount; c++) {
            var h = 0;
            if (this.labelNumber === -1 || this.labelNumber === 0) {
                h = 1
            } else {
                h = this.labelNumber
            }
            var e = this._getCateMin(c);
            var n = this._getCateMax(c);
            var a = this.isCustomMainUnit === true ? this.tickLength : FR.Chart.AxisGlyph.calculateIncrement(e, n);
            var f = this.isCustomSecUnit === true ? this.smallTickLength : a / 5;
            var p = 1;
            var g = this.showUnit;
            if (g || this.unitPadding) {
                p = FR.Chart.ValueAxisGlyph.getDivideUnit(g);
                var l = new FR.Chart.TextGlyph();
                var j = g ? FR.i18nText("Chart-Use_Unit") + ":" + FR.Chart.ValueAxisGlyph.getUnitKye2Value(g) : "";
                j += this.unitPadding;
                l.text = j;
                var d = l.preferredDimension();
                var b = new FR.Chart.Bounds(this.bounds.x, this.bounds.y, d.width, d.height);
                l.bounds = b;
                l.draw(o)
            }
            for (var k = e; k <= n; k += a * h) {
                if (c === 0 || !this.isAllMaxMin) {
                    this.drawTickLine(o, this.getTickLine(c, k, FR.Chart.AxisGlyph.MAIN_TICK_LENGTH, this.tickMarkType), FR.Chart.Constants.AxisTickWidth);
                    this.drawFirstAxisLabel(o, c, k, p, m)
                }
            }
            for (var k = e; k <= n; k += f) {
                if ((c === 0 || !this.isAllMaxMin)) {
                    this.drawTickLine(o, this.getTickLine(c, k, FR.Chart.AxisGlyph.SEC_TICK_LENGTH, this.secTickMarkType), FR.Chart.Constants.AxisTickWidth)
                }
            }
        }
    }, getTickLine: function (f, e, c, d) {
        var b = this.getPoint2D(f, e);
        var a = new FR.Chart.Point2D(b.x - c / 2 * Math.cos(f * this.radian), b.y + c / 2 * Math.sin(f * this.radian));
        var g = new FR.Chart.Point2D(b.x + c / 2 * Math.cos(f * this.radian), b.y - c / 2 * Math.sin(f * this.radian));
        if (d == FR.Chart.Constants.TICK_MARK_CROSS) {
            return new FR.Chart.Line2D(a, g)
        } else {
            if (d == FR.Chart.Constants.TICK_MARK_INSIDE) {
                return new FR.Chart.Line2D(a, b)
            } else {
                if (d == FR.Chart.Constants.TICK_MARK_OUTSIDE) {
                    return new FR.Chart.Line2D(b, g)
                } else {
                    return new FR.Chart.Line2D(b, b)
                }
            }
        }
    }, drawFirstAxisLabel: function (j, h, f, k, g) {
        if (!this.isShowAxisLabel) {
            return
        }
        var e = this.getPoint2D(h, f);
        var i = this.value2String(f / k);
        var d = this.textAttr;
        if (d == null) {
            d = new FR.Chart.TextAttr()
        }
        var b = FR.Chart.TextUtils.calculateTextDimensionWithRotation(i, d);
        var a = FR.Chart.AxisGlyph.LINE_LABEL_GAP;
        var c = new FR.Chart.Bounds(e.x - b.width - a, e.y - b.height / 2, b.width, b.height);
        if (this.labelNumber !== 0) {
            FR.Chart.TextUtils.drawLabelWithRotation(j, i, d, c)
        } else {
            if (!g.isInteract(c)) {
                g.addBounds(c);
                FR.Chart.TextUtils.drawLabelWithRotation(j, i, d, c)
            }
        }
    }, drawCateLabel: function (m, d, k, a, j) {
        var l = this.labelList[d].toString();
        var c = new FR.Chart.Point2D(k.x + Math.cos(this.radian * d + Math.PI / 2) * a, k.y - Math.sin(this.radian * d + Math.PI / 2) * a);
        var b = 2;
        if (!this.isAllMaxMin) {
            b = 4 + FR.Chart.TextUtils.calculateTextDimensionWithRotation(this.getRealMaxValueText(d), new FR.Chart.TextAttr()).width
        }
        var f = FR.Chart.TextUtils.calculateTextDimensionWithRotation(l, new FR.Chart.TextAttr());
        var e = (d * 360 / this.categoryCount + 90) % 360;
        var i = c.x;
        var h = c.y;
        if (e > 90 && e < 270) {
            i = i - b - f.width
        } else {
            if ((e > 0 && e < 90) || (e > 270 && e < 360)) {
                h = h - f.height / 2
            } else {
                if (e === 90) {
                    i = i - f.width / 2;
                    h = h - f.height * 1.5
                } else {
                    if (e === 270) {
                        i = i - f.width / 2
                    }
                }
            }
        }
        var g = new FR.Chart.Bounds(i, h, f.width, f.height);
        if (!j.isInteract(g)) {
            j.addBounds(g);
            FR.Chart.TextUtils.drawLabelWithRotation(m, l, new FR.Chart.TextAttr(), g)
        }
    }, getRealMaxValueText: function (g) {
        var d = this.labelNumber > 0 ? this.labelNumber : 1;
        var f = this._getCateMin(g);
        var c = this._getCateMax(g);
        var e = this.isCustomMainUnit === true ? this.tickLength : FR.Chart.AxisGlyph.calculateIncrement(f, c);
        var b = 1;
        var a = this.showUnit;
        if (a != null) {
            b = FR.Chart.ValueAxisGlyph.getDivideUnit(a)
        }
        var h = f;
        while (h <= c) {
            h += e * d
        }
        return this.value2String(h / b)
    }, _getAxisLines: function () {
        var b = [];
        for (var a = 0; a < this.categoryCount; a++) {
            b[a] = new FR.Chart.Line2D(this.getPoint2D(a, this._getCateMin(a)), this.getPoint2D(a, this._getCateMax(a)))
        }
        return b
    }, getShape: function () {
        var c = new FR.Chart.GeneralPath();
        var a = this._getAxisLines();
        for (var b = 0; b < a.length; b++) {
            c.append(a[b], false)
        }
        return c
    }, getCrossValue: function () {
        return this.minValue
    }, getArrowValue: function () {
        return this.maxValue
    }, shouldBeHeight: function () {
        if (this.textAttr == null) {
            this.textAttr = new FR.Chart.TextAttr()
        }
        return this.textAttr.alignText == FR.Chart.Style.VERTICALTEXT
    }, drawAxisTitle: function (a) {
    }
});
FR.Chart.RangeAxisGlyph = FR.extend(FR.Chart.ValueAxisGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.leftColor = FR.pick(a.leftColor, "rgb(215, 214, 214)");
        this.rightColor = FR.pick(a.rightColor, "rgb(240, 239, 239)");
        FR.Chart.RangeAxisGlyph.superclass.initConstants.apply(this, [a])
    }, dealPlotBoundsWithAxisLabel: function (a) {
        FR.Chart.RangeAxisGlyph.superclass.dealAlertLabelWidth.apply(this)
    }, init: function (a, b) {
        this.bounds = a;
        this.originPoint = new FR.Chart.Point2D(a.x, a.y + a.height / 2);
        this.axisLength = a.width;
        this.axisGridLength = b
    }, drawAxisGrid: function (a) {
        a.translate(this.getBounds().x, this.getBounds().y);
        FR.Chart.RangeAxisGlyph.superclass.drawAxisGrid.apply(this, [a]);
        this._drawAxisGround(a);
        a.translate(-this.getBounds().x, -this.getBounds().y)
    }, _drawAxisGround: function (a) {
        if (!a) {
            return
        }
        a.save();
        var b = a.createLinearGradient(0, 0, this.axisLength, 0);
        b.addColorStop(0, this.leftColor);
        b.addColorStop(1, this.rightColor);
        a.fillStyle = b;
        a.fillRect(0, 0, this.axisLength, this.bounds.height);
        a.restore()
    }, getGridLine: function (c) {
        var b = this.getPoint2D(c);
        var a = new FR.Chart.Line2D(new FR.Chart.Point2D(b.x, 0 - this.bounds.y), new FR.Chart.Point2D(b.x, this.plotZeroBounds.height - this.bounds.y));
        return [a]
    }, drawLabel: function (i, h, c, f) {
        if (!this.isShowAxisLabel) {
            return
        }
        var g = this.getPoint2D(h + c);
        var e = this.textAttr;
        if (e == null) {
            e = new FR.Chart.TextAttr()
        }
        var d = FR.Chart.TextUtils.calculateTextDimensionWithRotation(f, e);
        var b = new FR.Chart.Bounds(g.x - d.width / 2, g.y - this.bounds.height * 0.5 - d.height - 16, d.width, d.height);
        var a = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(f, e);
        b.width = a.width;
        b.height = a.height;
        FR.Chart.TextUtils.drawLabelWithRotation(i, f, e, b)
    }, getLabelBounds4Point: function (e, g, b, d) {
        var a = this.textAttr;
        if (a == null) {
            a = new FR.Chart.TextAttr()
        }
        var f = FR.Chart.TextUtils.calculateTextDimensionWithRotation(b, a);
        var c = new FR.Chart.Bounds(d.x - f.width / 2, d.y - this.bounds.height * 0.5 - f.height - 12, f.width, f.height);
        return c
    }, getAlertLabelBounds: function (c, f, a, e) {
        var d = null;
        var b = null;
        if (e == FR.Chart.Constants.LEFT) {
            b = new FR.Chart.Bounds(0, this.plotZeroBounds.height - this.bounds.y - this.maxLeftAlert, this.bounds.width, this.maxLeftAlert);
            d = new FR.Chart.Bounds(c.x, this.plotZeroBounds.height - this.bounds.y - this.maxLeftAlert, f.width, f.height)
        } else {
            b = new FR.Chart.Bounds(0, 0 - this.bounds.y, this.bounds.width, this.maxRightAlert);
            d = new FR.Chart.Bounds(c.x, 0 - this.bounds.y, f.width, f.height)
        }
        return FR.Chart.RangeAxisGlyph.superclass.dealIntersectsBounds.apply(this, [b, a, d])
    }
});
FR.Chart.DateAxisGlyph = FR.extend(FR.Chart.CategoryAxisGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.mainType = FR.pick(a.mainType, FR.Chart.Constants.DAY);
        this.secondType = FR.pick(a.secondType, FR.Chart.Constants.DAY);
        FR.Chart.DateAxisGlyph.superclass.initConstants.apply(this, [a]);
        this.zoomTickLength = this.tickLength;
        this.jsType = "DateAxis"
    }, initMinMaxValue: function (b, a) {
        this.minValue = FR.Chart.ChartUtils.int2Date(b, FR.Chart.Constants.Second);
        this.maxValue = FR.Chart.ChartUtils.int2Date(a, FR.Chart.Constants.Second);
        this.minValue = FR.Chart.ChartUtils.date2Int(this.minValue, this.mainType);
        this.maxValue = FR.Chart.ChartUtils.date2Int(this.maxValue, this.mainType);
        if (!this.isCustomMainUnit) {
            this.tickLength = 5
        }
        if (!this.isCustomSecUnit) {
            this.smallTickLength = 1
        }
    }, getMaxLabelWidthAndInitStartEndLabelDim: function () {
        if (this.isShowAxisLabel) {
            var c = 8;
            var g = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
            var b = this.getTickNumber4CalDim();
            var d = ((this.labelNumber > 0) ? this.labelNumber : b);
            var h = 0;
            while (FR.Chart.ChartUtils.date2Int(g, this.mainType) <= this.maxValue && parseInt(this.tickLength * d) > 0) {
                var e = "";
                if (this.format != null) {
                    e = FR.contentFormat(g, this.format)
                } else {
                    e = FR.contentFormat(g, "Dyyyy-MM-dd")
                }
                var f = this.getAxisLabelDim(e);
                if (h === 0) {
                    this.startLabelDim = f;
                    h++
                } else {
                    this.endLabelDim = f
                }
                var a = this.shouldBeHeight() ? f.height : f.width;
                c = (a < c ? c : a);
                FR.Chart.DateAxisGlyph.nextDate(g, this.mainType, parseInt(this.tickLength * d))
            }
            return c
        }
        return 0
    }, getDateTypeNumber: function () {
        var a = 1;
        if (this.mainType == FR.Chart.Constants.MONTH) {
            a = 30
        } else {
            if (this.mainType == FR.Chart.Constants.YEAR) {
                a = 365
            }
        }
        return a
    }, calculateAxisLengthUnit: function () {
        this.unitLength = this.axisLength / (this.getArrowValue() - this.getCrossValue() + this.tickNumberChangeUponLabelLocation());
        this.unitLengthNoScale = this.axisLength / (this.maxValue - this.minValue + this.tickNumberChangeUponLabelLocation())
    }, tickNumberChangeUponLabelLocation: function () {
        return this.drawBetweenTick ? 0 : -1
    }, getTickIndex4Value: function (b) {
        var a = FR.Chart.ChartUtils.object2Date(this.categoryLabelList[b]);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, getDate4Value: function (a) {
        return FR.Chart.ChartUtils.object2Date(this.categoryLabelList[a])
    }, drawAxisGrid: function (a) {
        if (this.mainGridStyle != FR.Chart.Constants.LINE_NONE && parseInt(this.tickLength) > 0 && this.mainGridColor != null) {
            this.drawGridLine(a, this.mainGridStyle, this.mainGridColor, parseInt(this.tickLength), this.mainType)
        }
    }, drawGridLine: function (j, d, f, h, e) {
        if (this.axisLength <= 15) {
            return
        }
        if (!j) {
            return
        }
        j.save();
        j.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(d);
        j.strokeStyle = f;
        var b = this.getTickSamplingTime();
        var g = FR.Chart.ChartUtils.int2Date(this.getCrossValue(), e);
        while (FR.Chart.ChartUtils.date2Int(g, e) <= this.getArrowValue() && h > 0) {
            var a = FR.Chart.ChartUtils.date2Int(g, e);
            var k = this.getGridLine(a);
            for (var c = 0; c < k.length; c++) {
                FR.Chart.GraphHelper.dealLine4JSDraw(k[c]);
                k[c].draw(j)
            }
            FR.Chart.DateAxisGlyph.nextDate(g, e, h * b)
        }
        j.restore()
    }, drawAxisLine: function (b) {
        if (!b) {
            return
        }
        b.save();
        if (this.minValue == this.maxValue) {
            return
        }
        if (this.lineColor && this.lineStyle != FR.Chart.Constants.LINE_NONE) {
            b.strokeStyle = this.lineColor;
            b.linwWidth = FR.Chart.GraphHelper.getLineStyleSize(this.lineStyle);
            var a = new FR.Chart.Line2D(this.getPoint2D(this.getCrossValue()), this.getPoint2D(this.getArrowValue() + this.tickNumberChangeUponLabelLocation()));
            FR.Chart.GraphHelper.dealLine4JSDraw(a);
            a.draw(b);
            this.drawArrow(b, a.startPoint, a.endPoint)
        }
        this.drawTicks(b);
        b.restore()
    }, drawTicks: function (j) {
        if (this.axisLength <= 15 || this.maxValue <= this.minValue) {
            return
        }
        var a = FR.Chart.ChartUtils.int2Date(this.getCrossValue(), this.mainType);
        var f = (this.drawBetweenTick ? 0.5 : 0);
        var h = this.getTickSamplingTime();
        var i = (this.labelNumber > 0 ? this.labelNumber : h);
        var b = this.mainType;
        if (this.stockChartMainType) {
            this.mainType = this.stockChartMainType
        }
        while (FR.Chart.ChartUtils.date2Int(a, this.mainType) < this.getArrowValue() && parseInt(this.tickLength) > 0) {
            var d = FR.Chart.ChartUtils.date2Int(a, this.mainType);
            var k = this.getTickLine(d, FR.Chart.AxisGlyph.MAIN_TICK_LENGTH, this.tickMarkType);
            this.drawTickLine(j, k, FR.Chart.Constants.AxisTickWidth);
            FR.Chart.DateAxisGlyph.nextDate(a, this.mainType, this.stockChartMainType ? 1 : parseInt(this.tickLength * i))
        }
        if (h <= 1 && Math.abs(this.smallTickLength) > 0) {
            a = FR.Chart.ChartUtils.int2Date(this.getCrossValue(), this.secondType);
            while (FR.Chart.ChartUtils.date2Int(a, this.secondType) < this.getArrowValue() && parseInt(this.smallTickLength) > 0) {
                var d = FR.Chart.ChartUtils.date2Int(a, this.secondType);
                var k = this.getTickLine(d, FR.Chart.AxisGlyph.SEC_TICK_LENGTH, this.secTickMarkType);
                this.drawTickLine(j, k, FR.Chart.Constants.AxisTickWidth);
                FR.Chart.DateAxisGlyph.nextDate(a, this.secondType, parseInt(this.smallTickLength * i))
            }
        }
        var e = new FR.Chart.BoundsManager();
        a = FR.Chart.ChartUtils.int2Date(this.stockChartMinDateInt ? this.stockChartMinDateInt : this.getCrossValue(), this.mainType);
        while (FR.Chart.ChartUtils.date2Int(a, this.mainType) < this.getArrowValue() && parseInt(this.tickLength) > 0) {
            var d = FR.Chart.ChartUtils.date2Int(a, this.mainType);
            var c = "";
            c = this.getDateString4Type(a, this.mainType);
            var g = this.getLabelBounds(d, f, c);
            if (!e.isInteract(g)) {
                this.drawLabel(j, d, f, c);
                e.addBounds(g)
            }
            FR.Chart.DateAxisGlyph.nextDate(a, this.mainType, this.stockChartMainType ? 1 : parseInt(this.tickLength * i))
        }
        this.mainType = b
    }, getDateString4Type: function (a, b) {
        if (!this.stockChartMinDateInt) {
            return (this.format == null ? FR.contentFormat(a, "Dyyyy-MM-dd") : FR.contentFormat(a, this.format))
        }
        return FR.Chart.ChartUtils.calculateAdjustDateRange(a, b)
    }, drawOnlyLabels4Demo: function (m) {
        if (this.axisLength <= 15 || this.maxValue <= this.minValue) {
            return
        }
        var e = this.getTickSamplingTime4Demo();
        var l = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
        while (FR.Chart.ChartUtils.date2Int(l, this.mainType) < this.maxValue && this.tickLength > 0) {
            var c = FR.Chart.ChartUtils.date2Int(l, this.mainType);
            var n = this.getGridLine4Demo(c);
            for (var g = 0; g < n.length; g++) {
                FR.Chart.GraphHelper.dealLine4JSDraw(n[g]);
                n[g].draw(m)
            }
            FR.Chart.DateAxisGlyph.nextDate(l, this.mainType, this.tickLength * e)
        }
        var j = this.getTickIntervalCount(this.getMaxTickValueDemo() - this.minValue, 15);
        var k = (this.labelNumber > 0 ? this.labelNumber : j);
        var f = (this.drawBetweenTick ? 0.5 : 0);
        var d = new FR.Chart.BoundsManager();
        var a = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
        while (FR.Chart.ChartUtils.date2Int(a, this.mainType) < this.maxValue && parseInt(this.tickLength) > 0) {
            var c = FR.Chart.ChartUtils.date2Int(a, this.mainType);
            var b = "";
            b = (this.format == null ? FR.contentFormat(a, "DMM-dd") : FR.contentFormat(a, this.format));
            var h = this.getLabelBounds(c, f, b);
            if (!d.isInteract(h)) {
                this.drawLabel(m, c, f, b);
                d.addBounds(h, false)
            }
            FR.Chart.DateAxisGlyph.nextDate(a, this.mainType, parseInt(this.tickLength * k))
        }
    }, getPoint2D: function (c) {
        var b = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
        c = c - (this.isDraw4Demo ? FR.Chart.ChartUtils.date2Int(b, this.mainType) : this.getCrossValue());
        var a = this.isDraw4Demo ? this.unitLengthNoScale : this.unitLength;
        if (this.originPoint == null) {
            return new FR.Chart.Point2D(0, 0)
        }
        if (this.position == FR.Chart.Constants.LEFT || this.position == FR.Chart.Constants.RIGHT) {
            return new FR.Chart.Point2D(this.originPoint.x, this.originPoint.y - a * c)
        } else {
            return new FR.Chart.Point2D(this.originPoint.x + a * c, this.originPoint.y)
        }
    }, getOriginalCrossValue: function () {
        var a = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
        FR.Chart.DateAxisGlyph.nextDate(a, this.mainType, 0);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, getOriginalArrowValue: function () {
        var a = FR.Chart.ChartUtils.int2Date(this.maxValue, this.mainType);
        var b = this.mainType;
        if (b === FR.Chart.Constants.MONTH || FR.Chart.Constants.YEAR) {
            b = FR.Chart.Constants.DAY
        }
        FR.Chart.DateAxisGlyph.nextDate(a, b, 1);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, getCrossValue: function () {
        var a = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
        FR.Chart.DateAxisGlyph.nextDate(a, this._getMoreThanDayType(), -this.zoomBackward);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, getArrowValue: function () {
        var a = FR.Chart.ChartUtils.int2Date(this.maxValue, this.mainType);
        FR.Chart.DateAxisGlyph.nextDate(a, this._getMoreThanDayType(), this.zoomForward + 1);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, getEndValue4UnitBasedMinDate: function (b, c) {
        var a = FR.Chart.ChartUtils.int2Date(this.minValue, this.mainType);
        FR.Chart.DateAxisGlyph.nextDate(a, this._getMoreThanDayType(), -this.zoomBackward);
        FR.Chart.DateAxisGlyph.nextDate(a, b, c);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, getStartValue4UnitBasedOriginalMaxDate: function (c, d) {
        var a = FR.Chart.ChartUtils.int2Date(this.maxValue, this.mainType);
        var b = this.mainType;
        if (b === FR.Chart.Constants.MONTH || FR.Chart.Constants.YEAR) {
            b = FR.Chart.Constants.DAY
        }
        FR.Chart.DateAxisGlyph.nextDate(a, b, 1);
        FR.Chart.DateAxisGlyph.preDate(a, c, d);
        return FR.Chart.ChartUtils.date2Int(a, this.mainType)
    }, _getMoreThanDayType: function () {
        if (this.mainType == FR.Chart.Constants.YEAR || this.mainType == FR.Chart.Constants.MONTH) {
            return FR.Chart.Constants.DAY
        }
        return this.mainType
    }
});
$.extend(FR.Chart.DateAxisGlyph, {
    nextDate: function (c, a, b) {
        if (a == FR.Chart.Constants.DAY) {
            c.setDate(c.getDate() + b)
        } else {
            if (a == FR.Chart.Constants.MONTH) {
                c.setMonth(c.getMonth() + b)
            } else {
                if (a == FR.Chart.Constants.YEAR) {
                    c.setYear(c.getFullYear() + b)
                } else {
                    if (a == FR.Chart.Constants.Minute) {
                        c.setMinutes(c.getMinutes() + b)
                    } else {
                        if (a == FR.Chart.Constants.Hour) {
                            c.setHours(c.getHours() + b)
                        } else {
                            if (a == FR.Chart.Constants.Second) {
                                c.setSeconds(c.getSeconds() + b)
                            }
                        }
                    }
                }
            }
        }
    }, preDate: function (c, a, b) {
        if (a == FR.Chart.Constants.DAY) {
            c.setDate(c.getDate() - b)
        } else {
            if (a == FR.Chart.Constants.MONTH) {
                c.setMonth(c.getMonth() - b)
            } else {
                if (a == FR.Chart.Constants.YEAR) {
                    c.setYear(c.getFullYear() - b)
                } else {
                    if (a == FR.Chart.Constants.Minute) {
                        c.setMinutes(c.getMinutes() - b)
                    } else {
                        if (a == FR.Chart.Constants.Hour) {
                            c.setHours(c.getHours() - b)
                        } else {
                            if (a == FR.Chart.Constants.Second) {
                                c.setSeconds(c.getSeconds() - b)
                            }
                        }
                    }
                }
            }
        }
    }
});
FR.Chart.DataPoint = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        this.js = a || {};
        this.valueIsNull = this.js.valueIsNull || false;
        this.seriesIndex = FR.pick(this.js.seriesIndex, 0);
        this.categoryIndex = FR.pick(this.js.categoryIndex, 0);
        this.value = FR.pick(this.js.value, 0);
        this.valueByUnit = FR.pick(this.js.valueByUnit, 0);
        this.percentValue = FR.pick(this.js.percentValue, 0);
        this.categoryName = this.js.categoryName;
        this.secondCate = this.js.secondCate;
        this.thirdCate = this.js.thirdCate;
        this.seriesName = this.js.seriesName;
        this.seriesLabel = this.js.seriesLabel;
        this.categoryOriginalName = this.js.categoryOriginalName;
        this.dataLabel = this.js.dataLabel == undefined ? null : new FR.Chart.TextGlyph(this.js.dataLabel);
        this.hyperlink = this.js.hyperlink;
        this.relateHyerlink = [];
        this.tooltip = null;
        this.glyph = null;
        this.isOutBounds = false;
        this.dataPointStyle = null;
        this.lastGlyph = null;
        this.jsType = "DataPoint";
        this.surpportFocus = true;
        this.isCustomTooltip = false;
        this.isCustomLabel = false;
        this.clickable = this.hyperlink != null;
        this.stockDataPointCount = 1
    }, revert2Original: function () {
        this.valueIsNull = this.js.valueIsNull || false;
        this.value = FR.pick(this.js.value, 0);
        this.percentValue = FR.pick(this.js.percentValue, 0);
        this.categoryName = this.js.categoryName;
        this.seriesName = this.js.seriesName;
        this.dataLabel = this.js.dataLabel == undefined ? null : new FR.Chart.TextGlyph(this.js.dataLabel);
        this.tooltip = null;
        this.glyph = null;
        this.lastGlyph = null;
        this.surpportFocus = true;
        this.clickable = this.hyperlink != null;
        this.stockDataPointCount = 1
    }, addDataPoint4StockCategory: function (a) {
        this.addBaseDataPoint(a)
    }, addBaseDataPoint: function (a) {
        this.valueIsNull = this.valueIsNull && a.valueIsNull;
        this.lastGlyph = null;
        this.value = FR.pick(this.value, 0) + FR.pick(a.value);
        this.percentValue = FR.pick(this.percentValue, 0) + FR.pick(a.percentValue, 0);
        this.tooltip = null;
        this.surpportFocus = true;
        this.clickable = this.hyperlink != null
    }, addDataPoint: function (a) {
        this.addBaseDataPoint(a);
        this.seriesName = this.seriesName + "&" + a.seriesName
    }, setCustomLabel: function (a) {
        if (this.dataLabel) {
            this.dataLabel.text = a;
            this.isCustomLabel = true;
            if (this.isShowLabel) {
                this.showLabel = a
            }
        }
    }, resultParameter: function (c) {
        if (c) {
            var b = {};
            for (var a in c) {
                var d = this.getValueByPara(c[a]);
                b[a] = d
            }
            return b
        }
    }, getValueByPara: function (a) {
        if (!this.parameters) {
            this.parameters = {CATEGORY: this.categoryName, SERIES: this.seriesName, VALUE: this.value}
        }
        if (a.charAt(0) == "=") {
            a = a.substr(1)
        }
        return '"' + this.parameters[a] + '"'
    }, toResult: function (a) {
        if (FR.equals(a, "CategoryIndex")) {
            return this.categoryIndex + 1
        } else {
            if (FR.equals(a, "SeriesIndex")) {
                return this.seriesIndex + 1
            } else {
                if (FR.equals(a, "Value")) {
                    return this.value
                } else {
                    if (FR.equals(a, "CategoryName")) {
                        return this.categoryName
                    } else {
                        if (FR.equals(a, "SeriesName")) {
                            return this.seriesName
                        } else {
                            if (FR.equals(a, "ProjectID")) {
                                return this.seriesName
                            } else {
                                if (FR.equals(a, "StepIndex")) {
                                    return this.categoryIndex
                                }
                            }
                        }
                    }
                }
            }
        }
        return ""
    }, equals: function (a) {
        if (!a) {
            return false
        }
        return a.jsType == this.jsType && a.seriesIndex == this.seriesIndex && a.categoryIndex == this.categoryIndex
    }, createHotTooltip: function (e, a, c) {
        if (e && e.seriesLabel) {
            var d = "";
            this.outerBounds = a;
            this.isTooltip4Series = false;
            this.tooltipStyle = c;
            var b = e.seriesLabel;
            var f = "<br />";
            d += this._createCateTooltipString() + f;
            if (this.seriesName) {
                d += this.seriesName + ": "
            }
            if (b.indexOf("{VALUE}") != -1) {
                d += this._createValueTooltipString(this.value, e);
                if (b.indexOf("{PERCENT}") != -1) {
                    d += ",";
                    d += this._createPercentTooltipString(this.percentValue, e)
                }
            } else {
                if (b.indexOf("{PERCENT}") != -1) {
                    d += this._createPercentTooltipString(this.percentValue, e)
                }
            }
            this.tooltip = d
        }
    }, _createCateTooltipString: function () {
        var a = "";
        if (this.categoryName || this.secondCate || this.thirdCate) {
            if (this.thirdCate) {
                a += this.thirdCate + "  "
            }
            if (this.secondCate) {
                a += this.secondCate + "  "
            }
            if (this.categoryName) {
                a += this.categoryName
            }
        }
        return a
    }, _createPercentTooltipString: function (b, c) {
        var a = "";
        if (c.percentFormat) {
            a = FR.contentFormat(b, c.percentFormat)
        } else {
            a = FR.contentFormat(b, "#.##%")
        }
        return a
    }, _createValueTooltipString: function (a, c) {
        var b = "";
        if (c.format) {
            b = FR.contentFormat(a, c.format)
        } else {
            b = a + ""
        }
        return b
    }, createHotTooltip4Map: function (c, e, b, g) {
        if (g && g.seriesLabel) {
            var d = "";
            var h = "<br />";
            d += c.categoryOriginalName + h;
            if (g.seriesLabel.indexOf("{VALUE}") != -1) {
                d += this.seriesName + ": " + this._createValueTooltipString(this.value, g) + h
            }
            if (g.seriesLabel.indexOf("{PERCENT}") != -1) {
                d += this.seriesName + FR.i18nText("Chart-DataFunction_Percent") + ": " + this._createPercentTooltipString(this.percentValue, g) + h
            }
            if (e && c.areaValue) {
                var a = c.areaValue.getTitleValueByIndex(b);
                if (a) {
                    var f = a.title;
                    if (g.seriesLabel.indexOf("{VALUE}") != -1) {
                        d += f + ": " + this._createValueTooltipString(c.value, g) + h
                    }
                    if (g.seriesLabel.indexOf("{PERCENT}") != -1) {
                        d += f + FR.i18nText("Chart-DataFunction_Percent") + ": " + this._createPercentTooltipString(c.percentValue, g) + h
                    }
                }
            }
            this.tooltip = d
        }
    }, createHotTooltip4Series: function (h, m, b, a) {
        if (h && h.seriesLabel) {
            this.outerBounds = m;
            this.isTooltip4Series = true;
            this.tooltipStyle = b;
            var e = m.dataSeries;
            var l = [];
            for (var f = 0; f < e.length; f++) {
                l[f] = '<span style="font-size:12px; color: ' + a[f] + '">' + "●  " + "</span>"
            }
            var j = "";
            var g = "<br />";
            var c = h.seriesLabel;
            j += this._createCateTooltipString() + g;
            for (var f = 0, d = e.length; f < d; f++) {
                if (e[f].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                    continue
                }
                var k = e[f].points[this.categoryIndex];
                if (e[f].seriesName) {
                    j += l[f] + e[f].seriesName + ": "
                }
                if (c.indexOf("{VALUE}") != -1) {
                    j += this._createValueTooltipString(k.value, h);
                    if (c.indexOf("{PERCENT}") != -1) {
                        j += "," + this._createPercentTooltipString(k.percentValue, h)
                    }
                } else {
                    if (c.indexOf("{PERCENT}") != -1) {
                        j += this._createPercentTooltipString(k.percentValue, h)
                    }
                }
                j += g
            }
            this.tooltip = j
        }
    }, getValueParaString: function (a, b, c) {
        if (a && (a.format || a.percentFormat)) {
            if (c) {
                return FR.contentFormat(b, a.percentFormat)
            } else {
                return FR.contentFormat(b, a.format)
            }
        } else {
            if (c) {
                return FR.contentFormat(b, "#.##%")
            } else {
                return FR.contentFormat(b, "#.##")
            }
        }
    }, getDataPointLabelString: function (b, d) {
        var c = FR.equals(d, "${BR}") ? "\n" : d;
        if (b && b.seriesLabel) {
            var a = b.seriesLabel;
            var f = "";
            var e = b.seriesLabel.split(d).length - 1;
            if (a.indexOf("{CATEGORY}") != -1) {
                f += this.categoryName;
                if (e-- > 0) {
                    f += c
                }
            }
            if (a.indexOf("{SERIES}") != -1) {
                f += this.seriesName;
                if (e-- > 0) {
                    f += c
                }
            }
            if (a.indexOf("{VALUE}") != -1) {
                f += this.getValueParaString(b, this.value);
                if (e > 0) {
                    f += c
                }
            }
            if (a.indexOf("{PERCENT}") != -1) {
                f += this.getValueParaString(b, this.percentValue, true)
            }
            return f
        }
    }, createMaoHao: function () {
        var a = new FR.Chart.TooltipString();
        a.value = " : ";
        a.font.fontName = FR.i18nText("Chart-Song_TypeFace");
        a.font.size = "12";
        return a
    }, createDouHao: function () {
        var a = new FR.Chart.TooltipString();
        a.value = "  ";
        a.font.fontName = FR.i18nText("Chart-Song_TypeFace");
        a.font.size = "12";
        return a
    }, setShape: function (a) {
        var b = new FR.Chart.ShapeGlyph();
        b.shape = a;
        this.glyph = b
    }, getShape: function () {
        return this.glyph == null ? null : this.glyph.getShape()
    }, onClick: function (a, b) {
        b.hyperlink = this.hyperlink
    }, findOnMoveGlyph: function (a, b) {
        if (this.glyph && !this.valueIsNull && this.glyph.getShape() && this.containsPointJudge4Moved(a.x, a.y)) {
            if (this.surpportFocus) {
                b._lastHover = this;
                b._hasfound = true
            }
            if (this.hyperlink != null) {
                b.cursor = ChartHandler.POINTER
            }
        }
    }, containsPointJudge4Moved: function (c, a) {
        var b = this.glyph.getShape();
        if (b.width <= FR.Chart.Constants.MarkerDefaultSize && b.height <= FR.Chart.Constants.MarkerDefaultSize) {
            b = new FR.Chart.Bounds(b.x - 5, b.y - 5, b.width + 10, b.height + 10)
        }
        return b.containsPoint(c, a)
    }, containsMousePos: function (a) {
        return this.glyph && !this.valueIsNull && this.glyph.getShape() && this.glyph.getShape().containsPoint(a.x, a.y) && this.surpportFocus
    }, dealTooltip: function (a, b) {
        if (this.glyph && !this.valueIsNull) {
            if (this.surpportFocus) {
                b._lastHover = this;
                b._hasfound = true;
                b._isPlotAreaHover = true
            }
        }
    }, doOnMove: function (b, a, d, c) {
        c.save();
        d._saveClip4SeriesDrawThrowOutOfPlot(c, d);
        this.doOnMoveWithoutTooltip(b, d, c);
        this.doTooltip(b, a, d);
        c.restore()
    }, doOnMoveWithoutTooltip: function (b, d, c) {
        if (this.glyph && this.glyph.shapeType && this.glyph.shapeType == "meter") {
            return
        }
        if (d && d.dataSeries[this.seriesIndex].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
            return
        }
        if (this.glyph && this.glyph.marker && this.glyph.marker.getMarkerType) {
            this.glyph.drawOnMove = true;
            this.glyph.draw(b);
            this.glyph.drawOnMove = false
        } else {
            FR.Chart.HighUtils.doFocus(this.glyph, b, c);
            if (this.isDataPointStyle() && this.dataLabel && d && d.seriesLabelsInSide(this)) {
                b.notUseDivText = true;
                var a = this.dataLabel.bounds;
                this.dataLabel.bounds = new FR.Chart.Bounds(a.x, a.y + 1, a.width, a.height);
                this.drawLabel(b);
                this.dataLabel.bounds = a;
                b.notUseDivText = false
            } else {
                if (this.glyph & this.glyph.isFade && c) {
                    c.notUseDivText = true;
                    this.drawLabel(c);
                    c.notUseDivText = false
                }
            }
        }
    }, isDataPointStyle: function () {
        return this.glyph && this.glyph.dataPointStyle
    }, doTooltip: function (m, n, d) {
        if (d instanceof FR.Chart.MeterPlotGlyph) {
            return
        }
        if (this.outerBounds && this.outerBounds.dataSeries && d && d.isTooltipEnable) {
            this.outerBounds.currentChosenSeriesIndex = this.seriesIndex;
            if (this.isTooltip4Series) {
                var b = [];
                var e = 0;
                var c = this.outerBounds.bounds.x;
                var k = this.outerBounds.bounds.y + this.outerBounds.bounds.height;
                for (var g = 0; g < this.outerBounds.dataSeries.length; g++) {
                    var f = this.outerBounds.dataSeries[g];
                    if (f && f.points && f.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        var a = f.points[this.categoryIndex];
                        if (a && a.glyph) {
                            var h = a.glyph;
                            this.drawChosenPoint(a, m);
                            var l = 0;
                            var j = 0;
                            if (h.shape) {
                                l = h.shape.x;
                                j = h.shape.y
                            } else {
                                if (h.bounds) {
                                    l = h.bounds.x;
                                    j = h.bounds.y
                                } else {
                                    l = h.marker.x;
                                    j = h.marker.y
                                }
                            }
                            if (j < k || j == k && l > c) {
                                k = j;
                                c = l;
                                e = g
                            }
                            if (h && h.toolTipBackground) {
                                b[g] = h.toolTipBackground.color
                            } else {
                                h = this.outerBounds.dataSeries[g].glyph;
                                b[g] = h.toolTipBackground.color
                            }
                        }
                    }
                }
                if (this.outerBounds.dataSeries[e] && this.outerBounds.dataSeries[e].points[this.categoryIndex]) {
                    h = this.outerBounds.dataSeries[e].points[this.categoryIndex].glyph
                }
                if (h) {
                    FR.Chart.Tooltip.dataPointTip4Series(m, this.tooltip, n, h, h.toolTipBackground, this.outerBounds, this.tooltipStyle, b)
                }
            } else {
                if (this.glyph && this.glyph.toolTipBackground) {
                    if (this.glyph.colorInfo && this.glyph.colorInfo.seriesAttrColor) {
                        this.glyph.toolTipBackground = FR.Chart.ColorBackground.getInstance(this.glyph.colorInfo.seriesAttrColor.seriesColor)
                    } else {
                        if (this.glyph.marker && this.glyph.marker.background && this.glyph.marker.background.color) {
                            this.glyph.toolTipBackground = FR.Chart.ColorBackground.getInstance(this.glyph.marker.background.color)
                        }
                    }
                }
                FR.Chart.Tooltip.dataPointTip4Point(m, this.tooltip, n, this.glyph, this.glyph && this.glyph.toolTipBackground, this.outerBounds, this.tooltipStyle)
            }
        }
    }, drawChosenPoint: function (a, b) {
        if (a.glyph && a.glyph.marker && a.glyph.marker.getMarkerType) {
            a.glyph.drawOnMove = true;
            a.glyph.draw(b);
            a.glyph.drawOnMove = false
        } else {
            FR.Chart.HighUtils.doFocus(a.glyph, b)
        }
    }, draw: function (a, b) {
        if (this.glyph && (!this.dataPointStyle || !this.dataPointStyle.avoidOriginDraw)) {
            this.glyph.draw(a, b)
        }
        if (this.dataPointStyle) {
            this.dataPointStyle.paintStyle(a)
        }
    }, draw4Demo: function (a) {
        if (this.glyph && this.glyph.draw4Demo) {
            this.glyph.draw4Demo(a)
        }
    }, getAnimateGlyph: function (b, a, c) {
        if (this.glyph || this.lastGlyph) {
            this.animateGlyph = (this.glyph || this.lastGlyph).getAnimateGlyph(b, a, this.lastGlyph, c)
        } else {
            this.animateGlyph = []
        }
    }, drawAnimateGlyph: function (a, b) {
        if (this.animateGlyph && this.animateGlyph.length > 0 && b < this.animateGlyph.length) {
            this.animateGlyph[b].draw(a)
        }
    }, isBorderDefault: function (a) {
        return true
    }, drawOnlyBorder: function (a, b) {
    }, drawLabel: function (b, a) {
        if (this.valueIsNull) {
            return
        }
        if (this.dataLabel && this.dataLabel.visible) {
            this.dataLabel.draw(b, a)
        }
    }
});
FR.Chart.DataPoint4Bubble = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        this.x = FR.pick(a.x, 0);
        this.sizeValue = FR.pick(a.sizeValue, 0);
        FR.Chart.DataPoint4Bubble.superclass.initConstants.apply(this, [a])
    }, createHotTooltip: function (e, a, c) {
        if (e && e.seriesLabel) {
            this.outerBounds = a;
            this.tooltipStyle = c;
            var b = e.seriesLabel;
            var d = "";
            if (this.seriesName) {
                d += this.seriesName;
                d += "<br />"
            }
            if (b.indexOf("{VALUE}") != -1) {
                d += "(" + this._createValueTooltipString(this.x, e) + "," + this._createValueTooltipString(this.value, e) + ")" + this.sizeValue
            }
            this.tooltip = d
        }
    }, getDataPointLabelString: function (c, d) {
        if (c && c.seriesLabel) {
            var a = c.seriesLabel;
            var f = "";
            var e = c.seriesLabel.split(d).length - 1;
            if (a.indexOf("{SERIES}") != -1) {
                f += this.seriesName;
                if (e > 0) {
                    f += d
                }
            }
            if (a.indexOf("{VALUE}") != -1) {
                var b = "(" + this.getValueParaString(c, this.x);
                b += ",";
                b += this.getValueParaString(c, this.value) + ")";
                b += " size" + this.sizeValue;
                f += b
            }
            return f
        }
    }
});
FR.Chart.DataPoint4XY = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        this.x = FR.pick(a.x, 0);
        FR.Chart.DataPoint4XY.superclass.initConstants.apply(this, [a])
    }, createHotTooltip: function (e, a, c) {
        if (e && e.seriesLabel) {
            this.outerBounds = a;
            this.tooltipStyle = c;
            var b = e.seriesLabel;
            var f = "<br />";
            var d = "";
            if (this.seriesName) {
                d += this.seriesName + f
            }
            if (b.indexOf("{VALUE}") != -1) {
                d += "(" + this._createValueTooltipString(this.x, e) + "," + this._createValueTooltipString(this.value, e) + ")"
            }
            this.tooltip = d
        }
    }, getDataPointLabelString: function (c, e) {
        if (c && c.seriesLabel) {
            var a = c.seriesLabel;
            var g = "";
            var f = c.seriesLabel.split(e).length - 1;
            var d = FR.equals(e, "${BR}") ? "\n" : e;
            if (a.indexOf("{SERIES}") != -1) {
                g += this.seriesName;
                if (f > 0) {
                    g += d
                }
            }
            if (a.indexOf("{VALUE}") != -1) {
                var b = this.getValueParaString(c, this.x);
                b += " " + this.getValueParaString(c, this.value);
                g += b
            }
            return g
        }
    }
});
FR.Chart.DataPoint4Pie = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        this.leadLine = null;
        this.isSeparateOut = false;
        FR.Chart.DataPoint4Pie.superclass.initConstants.apply(this, [a]);
        this.isShowLabel = true;
        this.clickable = true;
        this.showLabel = this.dataLabel ? this.dataLabel.text : null
    }, drawAnimateGlyph: function (a, b) {
        if (this.animateGlyph && this.animateGlyph.length > 0 && b < this.animateGlyph.length) {
            this.animateGlyph[b].drawWithOutBorder(a)
        }
    }, drawOnlyBorder: function (a, b) {
        if (this.animateGlyph && this.animateGlyph.length > 0 && b < this.animateGlyph.length) {
            this.animateGlyph[b].drawOnlyBorder(a)
        }
    }, isBorderDefault: function (a) {
        if (!this.animateGlyph || a >= this.animateGlyph.length) {
            return true
        }
        return this.animateGlyph[a].isBorderDefault()
    }, createHotTooltip: function (e, a, c) {
        if (e && e.seriesLabel) {
            this.outerBounds = a;
            var b = e.seriesLabel;
            this.tooltipStyle = c;
            var d = "";
            if (this.seriesName) {
                d += this.seriesName + ": "
            }
            if (b.indexOf("{VALUE}") != -1) {
                d += this._createValueTooltipString(this.value, e);
                if (b.indexOf("{PERCENT}") != -1) {
                    d += "," + this._createPercentTooltipString(this.percentValue, e)
                }
            } else {
                if (b.indexOf("{PERCENT}") != -1) {
                    d += this._createPercentTooltipString(this.percentValue, e)
                }
            }
            this.tooltip = d
        }
    }, onClick: function (a, b) {
        b.hyperlink = this.hyperlink;
        this.isSeparateOut = !this.isSeparateOut;
        b.needRefresh = true
    }, findOnMoveGlyph: function (a, b) {
        if (this.glyph && this.glyph.getShape() && this.glyph.getShape().containsPoint(a.x, a.y)) {
            b.cursor = ChartHandler.POINTER;
            b._lastHover = this;
            b._hasfound = true
        }
    }, drawLabel: function (b, a) {
        if (this.valueIsNull) {
            return
        }
        if (this.isShowLabel && this.dataLabel) {
            var d = this.dataLabel.text;
            this.dataLabel.text = this.showLabel;
            this.dataLabel.draw(b, a);
            this.dataLabel.text = d;
            if (this.leadLine) {
                if (this.glyph.info.seriesAttrBackground && this.glyph.info.seriesAttrBackground.seriesBackground.color) {
                    var c = new FR.Chart.AttrColor();
                    c.seriesColor = this.glyph.info.seriesAttrBackground.seriesBackground.color;
                    this.leadLine.lineStyleInfo.attrLineColor = c;
                    this.leadLine.draw(b)
                }
            }
        }
    }
});
FR.Chart.DataPoint4Funnel = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.DataPoint4Funnel.superclass.initConstants.apply(this, [a]);
        this.leadLine = null;
        this.isShowLabel = true;
        this.showLabel = this.dataLabel ? this.dataLabel.text : null;
        this.seriesString = a.seriesString;
        this.valueString = a.valueString;
        this.valueWidth = 0;
        this.seriesText = new FR.Chart.TextGlyph();
        this.valueText = new FR.Chart.TextGlyph();
        this.topColor = "rgb(115,115,115)";
        this.lineColor = "rgb(204,204,204)";
        this.seriesColor = "rgb(0,0,0)"
    }, createHotTooltip: function (e, a, c) {
        if (e && e.seriesLabel) {
            this.outerBounds = a;
            var b = e.seriesLabel;
            this.tooltipStyle = c;
            var d = "";
            var f = "<br />";
            if (this.seriesName) {
                d += this.seriesName + f
            }
            if (b.indexOf("{VALUE}") != -1) {
                d += this._createValueTooltipString(this.value, e);
                if (b.indexOf("{PERCENT}") != -1) {
                    d += "," + this._createPercentTooltipString(this.percentValue, e)
                }
            } else {
                if (b.indexOf("{PERCENT}") != -1) {
                    d += this._createPercentTooltipString(this.percentValue, e)
                }
            }
            this.tooltip = d
        }
    }, onClick: function (a, b) {
        b.hyperlink = this.hyperlink
    }, findOnMoveGlyph: function (a, b) {
        if (this.glyph && this.glyph.getShape() && this.glyph.getShape().containsPoint(a.x, a.y)) {
            b.cursor = ChartHandler.POINTER;
            b._lastHover = this;
            b._hasfound = true
        }
    }, drawLabel: function (b, a) {
        if (this.valueIsNull) {
            return
        }
        if (this.isShowLabel && this.dataLabel) {
            if (this.valueText && this.valueText.text) {
                if (this.glyph.info.seriesAttrBackground && this.glyph.info.seriesAttrBackground.seriesBackground.color) {
                    var c = this.glyph.info.seriesAttrBackground.seriesBackground.color;
                    this.valueText.textAttr.frFont.color = c;
                    if (this.seriesIndex === 0) {
                        this.valueText.textAttr.frFont.color = this.topColor
                    }
                }
                var g = this.valueText.text;
                var d = this.valueText.textAttr;
                var e = this.valueText.bounds;
                FR.Chart.TextUtils.drawLabelWithNoRotation(b, g, d, e, a)
            }
            if (this.seriesText && this.seriesText.text) {
                this.seriesText.textAttr = (this.dataLabel.textAttr);
                this.seriesText.textAttr.frFont.color = (this.seriesColor);
                if (this.seriesIndex === 0) {
                    this.seriesText.textAttr.frFont.color = this.topColor
                }
                var g = this.seriesText.text;
                var d = this.seriesText.textAttr;
                var e = this.seriesText.bounds;
                FR.Chart.TextUtils.drawLabelWithNoRotation(b, g, d, e, a)
            }
            if (this.leadLine) {
                var f = new FR.Chart.AttrColor();
                f.seriesColor = this.lineColor;
                this.leadLine.lineStyleInfo.attrLineColor = f;
                this.leadLine.draw(b)
            }
        }
    }, getSeriesValueString: function () {
        if (this.valueIsNull || !this.isShowLabel) {
            return null
        }
        if (this.dataLabel == null || this.showLabel == null) {
            return null
        }
        return [this.seriesString, this.valueString]
    }, initLabelBounds: function () {
        if (this.valueIsNull || !this.isShowLabel) {
            return null
        }
        if (this.dataLabel == null || this.dataLabel.bounds == null) {
            return null
        }
        if (this.showLabel == null) {
            return null
        }
        var e = this.dataLabel.getBounds();
        if (this.valueString) {
            var f = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(this.valueString, this.dataLabel.textAttr);
            var a = e.x + e.width - this.valueWidth;
            var d = new FR.Chart.Bounds(a, e.y, this.valueWidth + 5, f.height);
            this.valueText.text = this.valueString;
            this.valueText.textAttr = this.dataLabel.textAttr;
            this.dealTextWithEllipsis(this.valueText, e.width);
            this.valueText.bounds = (d)
        }
        if (this.seriesString) {
            var c = e.width;
            if (this.valueText != null) {
                c -= this.valueWidth
            }
            if (c > 0) {
                var b = new FR.Chart.Bounds(e.x, e.y, c, e.height);
                this.seriesText.text = this.seriesString;
                this.seriesText.textAttr = this.dataLabel.textAttr;
                this.dealTextWithEllipsis(this.seriesText, c);
                this.seriesText.bounds = (b)
            }
        }
    }, dealTextWithEllipsis: function (f, d) {
        var b = f.text;
        var e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(b, f.textAttr).width;
        if (e <= d) {
            return
        }
        var a;
        for (a = b.length; a >= 0; a--) {
            var c = b.substring(0, a) + FR.Chart.Constants.ESP;
            e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, f.textAttr).width;
            if (e <= d) {
                break
            }
        }
        if (a === 0) {
            f.text = (FR.Chart.Constants.ESP)
        } else {
            f.text = (b.substring(0, a) + FR.Chart.Constants.ESP)
        }
    }
});
FR.Chart.DataPoint4Gantt = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        this.planStart = FR.pick(a.planStart, -1);
        this.planEnd = FR.pick(a.planEnd, -1);
        this.realStart = FR.pick(a.realStart, -1);
        this.realEnd = FR.pick(a.realEnd, -1);
        this.realStartImpl = null;
        this.realEndImpl = null;
        this.progressImpl = null;
        FR.Chart.DataPoint4Pie.superclass.initConstants.apply(this, [a])
    }, createHotTooltip: function (a) {
    }, draw: function (a, b) {
        if (this.glyph) {
            this.glyph.draw(a, b)
        }
        if (this.progressImpl) {
            this.progressImpl.draw(a, b)
        }
    }, drawReal: function (a) {
        if (this.realStartImpl) {
            this.realStartImpl.draw(a)
        }
        if (this.realEndImpl) {
            this.realEndImpl.draw(a)
        }
    }, onClick: function (a, b) {
        b.hyperlink = this.hyperlink
    }, findOnMoveGlyph: function (a, b) {
        if ((this.glyph && this.glyph.getShape() && this.glyph.getShape().containsPoint(a.x, a.y)) || (this.realStartImpl && this.realStartImpl.getShape().containsPoint(a.x, a.y)) || (this.realEndImpl && this.realEndImpl.getShape().containsPoint(a.x, a.y)) || (this.progressImpl && this.progressImpl.getShape().containsPoint(a.x, a.y))) {
            if (this.hyperlink != null) {
                b.cursor = ChartHandler.POINTER;
                b._hasfound = true;
                b._lastHover = this
            }
        }
    }, getAnimateGlyph: function (b, a) {
        if (this.glyph) {
            this.animateGlyph4Plan = this.glyph.getAnimateGlyph(b, a)
        }
        if (this.progressImpl) {
            this.animateGlyph4Progress = this.progressImpl.getAnimateGlyph(b, a)
        }
        this.animateGlyph = this.animateGlyph4Progress || this.animateGlyph4Plan
    }, drawAnimateGlyph: function (a, b) {
        if (this.animateGlyph4Plan && this.animateGlyph4Plan.length > 0 && b < this.animateGlyph4Plan.length) {
            this.animateGlyph4Plan[b].draw(a)
        }
        if (this.animateGlyph4Progress && this.animateGlyph4Progress.length > 0 && b < this.animateGlyph4Progress.length) {
            this.animateGlyph4Progress[b].draw(a)
        }
    }
});
FR.Chart.DataPoint4GisMap = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        this.mapAreaValue = new FR.Chart.MapAreaValue(a.mapAreaValue);
        this.addressName = FR.pick(a.addressName, "");
        this.location = null;
        this.lastOverlay = null;
        this.map = null;
        this.ComplexCustomOverlay = null;
        this.attrContents = null;
        FR.Chart.DataPoint4GisMap.superclass.initConstants.apply(this, [a])
    }, setCustomLabel: function (b) {
        if (this.dataLabel) {
            this.dataLabel.text = b;
            this.isCustomLabel = true
        }
        if (this.location && this.map && this.attrContents) {
            var a = this.ComplexCustomOverlay;
            this.map.removeOverlay(this.lastOverlay);
            var c = new a(this.location, this, this.attrContents);
            this.map.addOverlay(c);
            this.lastOverlay = c
        }
    }
});
FR.Chart.DataPoint4Map = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (a) {
        a = a || {};
        this.hasNextTo = FR.pick(a.hasNextTo, false);
        this.nameLayerTo = FR.pick(a.nameLayerTo, "");
        this.nameFrom = FR.pick(a.nameFrom, "");
        this.layerIndex = a.layerIndex || 0;
        this.areaValue = new FR.Chart.MapAreaValue(a.areaValue);
        FR.Chart.DataPoint4Map.superclass.initConstants.apply(this, [a]);
        this.leadLine = null;
        this.clickable = this.hasNextTo || this.hyperlink;
        if (a.combineGlyph) {
            this.combineGlyph = new FR.Chart.ChartGlyph(a.combineGlyph)
        }
    }, createHotTooltip: function (h, k, a) {
        if (h && h.seriesLabel) {
            this.outerBounds = k;
            this.tooltipStyle = a;
            var b = h.seriesLabel;
            var g = "<br />";
            var j = this.categoryOriginalName + g;
            var e = k.heatIndex;
            if (this.areaValue.getTitleValueByIndex(e)) {
                var f = this.areaValue.getTitleValueByIndex(e);
                if (b.indexOf("{VALUE}") != -1) {
                    j += f.title + ":" + this._createValueTooltipString(this.value, h);
                    if (b.indexOf("{PERCENT}") != -1) {
                        j += "," + this._createPercentTooltipString(this.percentValue, h)
                    }
                } else {
                    if (b.indexOf("{PERCENT}") != -1) {
                        j += f.title + ":" + this._createPercentTooltipString(this.percentValue, h)
                    }
                }
            }
            if (this.combineGlyph == null) {
                var d = this.areaValue.titleValues;
                for (var c = 0; c < d.length; c++) {
                    if (c === e) {
                        continue
                    }
                    var f = d[c];
                    j += g;
                    if (b.indexOf("{VALUE}") != -1) {
                        j += f.title + ":" + this._createValueTooltipString(f.value, h);
                        if (b.indexOf("{PERCENT}") != -1) {
                            j += "," + this._createPercentTooltipString(f.percentValue, h)
                        }
                    } else {
                        if (b.indexOf("{PERCENT}") != -1) {
                            j += f.title + ":" + this._createPercentTooltipString(f.percentValue, h)
                        }
                    }
                }
            }
            this.tooltip = j
        }
    }, findOnMoveGlyph: function (a, c, b) {
        if (this.combineGlyph) {
            this.combineGlyph.findOnMoveGlyph(a, c)
        }
        if (!c._hasfound) {
            FR.Chart.DataPoint4Map.superclass.findOnMoveGlyph.apply(this, [a, c, b])
        }
    }, containsPointJudge4Moved: function (b, a) {
        return this.glyph.getShape().contains(b, a, 1, 1)
    }, onClick: function (a, b) {
        b.toNext = true;
        b.hyperlink = this.hyperlink
    }, drawLabel: function (b, a) {
        if (this.valueIsNull) {
            return
        }
        if (this.leadLine) {
            this.leadLine.draw(b)
        }
        if (this.dataLabel) {
            this.dataLabel.draw(b, a)
        }
    }
});
FR.Chart.DataPoint4Stock = FR.extend(FR.Chart.DataPoint, {
    initConstants: function (b) {
        this.js = b || {};
        this.values = [0, 0, 0, 0, 0];
        if (this.js.values) {
            for (var a = 0;
                 a < this.js.values.length; a++) {
                this.values[a] = this.js.values[a]
            }
        }
        this.stockLabels = [FR.i18nText("Chart-Stock_Volume"), FR.i18nText("Chart-Stock_Open"), FR.i18nText("Chart-Stock_High"), FR.i18nText("Chart-Stock_Low"), FR.i18nText("Chart-Stock_Close")];
        if (this.js.stockLabels) {
            for (var a = 0; a < this.js.stockLabels.length; a++) {
                this.stockLabels[a] = this.js.stockLabels[a]
            }
        }
        this.highLowLine = null;
        this.volumeGlyph = null;
        this.choosedBounds = null;
        FR.Chart.DataPoint4Stock.superclass.initConstants.apply(this, [b])
    }, revert2Original: function () {
        if (this.js.values) {
            for (var a = 0;
                 a < this.js.values.length; a++) {
                this.values[a] = this.js.values[a]
            }
        }
        this.stockLabels = [FR.i18nText("Chart-Stock_Volume"), FR.i18nText("Chart-Stock_Open"), FR.i18nText("Chart-Stock_High"), FR.i18nText("Chart-Stock_Low"), FR.i18nText("Chart-Stock_Close")];
        if (this.js.stockLabels) {
            for (var a = 0; a < this.js.stockLabels.length; a++) {
                this.stockLabels[a] = this.js.stockLabels[a]
            }
        }
        this.highLowLine = null;
        this.volumeGlyph = null;
        this.choosedBounds = null;
        FR.Chart.DataPoint4Stock.superclass.revert2Original.apply(this)
    }, addDataPoint4StockCategory: function (a) {
        this.addBaseDataPoint(a);
        this.values[0] += a.values[0];
        this.values[2] = Math.max(this.values[2], a.values[2]);
        this.values[3] = Math.min(this.values[3], a.values[3]);
        this.values[4] = a.values[4]
    }, _createStockInfo: function (c, b) {
        var d = "<br />";
        var a = this.stockLabels[c] + ":";
        if (!isNaN(this.values[c])) {
            a += this._createValueTooltipString(this.values[c], b)
        }
        a += d;
        return a
    }, createHotTooltip: function (e, a, c) {
        if (e && e.seriesLabel) {
            this.outerBounds = a;
            this.tooltipStyle = c;
            var f = "<br />";
            var d = "";
            d += this.categoryName + f;
            for (var b = 1; b < 5; b++) {
                d += this._createStockInfo(b, e)
            }
            d += this._createStockInfo(0, e);
            this.tooltip = d
        }
    }, draw: function (a, b) {
        if (this.highLowLine) {
            this.highLowLine.draw(a, b)
        }
        if (this.volumeGlyph) {
            this.volumeGlyph.draw(a, b)
        }
        FR.Chart.DataPoint4Stock.superclass.draw.apply(this, [a, b])
    }, draw4Demo: function (a) {
        if (this.highLowLine) {
            this.highLowLine.draw4Demo(a)
        }
        if (this.volumeGlyph) {
            this.volumeGlyph.draw4Demo(a)
        }
        FR.Chart.DataPoint4Stock.superclass.draw4Demo.apply(this, [a])
    }, onClick: function (a, b) {
        b.hyperlink = this.hyperlink
    }, findOnMoveGlyph: function (a, b) {
        if (this.glyph && this.choosedBounds.containsPoint(a.x, a.y)) {
            if (this.hyperlink != null) {
                b.cursor = ChartHandler.POINTER
            }
            b._hasfound = true;
            b._lastHover = this
        }
    }, getAnimateGlyph: function (b, a) {
        if (this.glyph) {
            this.animateGlyph = this.glyph.getAnimateGlyph(b, a)
        } else {
            this.animateGlyph = null
        }
        if (this.highLowLine) {
            this.animateGlyph4HighLowLine = this.highLowLine.getAnimateGlyph(b, a)
        } else {
            this.animateGlyph4HighLowLine = null
        }
        if (this.volumeGlyph) {
            this.animateGlyph4Volume = this.volumeGlyph.getAnimateGlyph(b, a)
        } else {
            this.animateGlyph4Volume = null
        }
    }, drawAnimateGlyph: function (a, b) {
        if (this.animateGlyph4HighLowLine && this.animateGlyph4HighLowLine.length > 0 && b < this.animateGlyph4HighLowLine.length) {
            this.animateGlyph4HighLowLine[b].draw(a)
        }
        if (this.animateGlyph4Volume && this.animateGlyph4Volume.length > 0 && b < this.animateGlyph4Volume.length) {
            this.animateGlyph4Volume[b].draw(a)
        }
        if (this.animateGlyph && this.animateGlyph.length > 0 && b < this.animateGlyph.length) {
            this.animateGlyph[b].draw(a)
        }
    }
});
FR.Chart.DataSeries = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (c) {
        c = c || {};
        this.points = [];
        if (c.dataPoints && c.dataPoints.length > 0 && c.dataPointType) {
            var b = c.dataPoints || {};
            for (var a = 0; a < b.length; a++) {
                this.points[a] = new FR.Chart[c.dataPointType](b[a])
            }
        }
        this.seriesIndex = FR.pick(c.seriesIndex, 0);
        this.seriesName = c.seriesName;
        this.seriesDragEnable = FR.pick(c.seriesDragEnable, false);
        this.paintState = FR.Chart.ChartPaintConstants.STATE_ENABLE;
        this.trendLineList = [];
        this.dataSeriesStyle = null;
        this.jsType = "DataSeries";
        this.glyph = null;
        this.lastGlyph = null;
        this.topFoldLine = null;
        this.shouldDrawLable = true
    }, addDataSeries: function (b) {
        for (var a = 0; a < this.points.length; a++) {
            this.points[a].addDataPoint(b.points[a])
        }
        this.seriesName = this.seriesName + "&" + b.seriesName
    }, toResult: function (a) {
        if (FR.equals(a, "SeriesIndex")) {
            return this.seriesIndex + 1
        } else {
            if (FR.equals(a, "SeriesName")) {
                return this.seriesName
            } else {
                if (FR.equals(a, "ProjectID")) {
                    return this.seriesName
                }
            }
        }
        return ""
    }, equals: function (a) {
        if (!a) {
            return false
        }
        return a.jsType == this.jsType && a.seriesIndex == this.seriesIndex
    }, createHotTooltip: function (d, c, b) {
        this.outerBounds = c;
        this.isTooltip4Series = false;
        this.tooltipStyle = b;
        for (var a = 0; a < this.points.length; a++) {
            if (this.points[a]) {
                this.points[a].createHotTooltip(d, c, b)
            }
        }
    }, createHotTooltip4Series: function (e, d, c, a) {
        this.outerBounds = d;
        this.isTooltip4Series = true;
        this.tooltipStyle = c;
        for (var b = 0; b < this.points.length; b++) {
            if (this.points[b]) {
                this.points[b].createHotTooltip4Series(e, d, c, a)
            }
        }
    }, getDataPointCount: function () {
        var a = 0;
        if (this.points) {
            a = this.points.length
        }
        return a
    }, draw: function (a, e, c) {
        if (this.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || this.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
            return
        }
        if (this.glyph) {
            this.glyph.draw(a, e, c)
        }
        var d = this.points;
        for (var b = 0; b < this.getDataPointCount(); b++) {
            if (d[b] != null) {
                d[b].draw(a, e)
            }
        }
    }, draw4Demo: function (a) {
        if (this.glyph) {
            this.glyph.draw4Demo(a)
        }
    }, drawLabel: function (b, a) {
        if (!this.shouldDrawLable) {
            return
        }
        for (var c = 0; c < this.getDataPointCount(); c++) {
            if (this.points[c]) {
                this.points[c].drawLabel(b, a)
            }
        }
    }, getAnimateGlyph: function (c, b) {
        if (this.paintState == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return
        }
        if (this.trendLineList) {
            this.trendLineAnimateGlyph = [];
            for (var a = 0; a < this.trendLineList.length; a++) {
                this.trendLineAnimateGlyph[a] = this.trendLineList[a].getAnimateGlyph(c, b)
            }
        }
        if (this.glyph || this.lastGlyph) {
            this.animateGlyph = (this.glyph || this.lastGlyph).getAnimateGlyph(c, b, this.lastGlyph, this.paintState);
            if (!this.isPointAnimate) {
                return
            }
        }
        var d = this.points;
        for (var a = 0; a < this.getDataPointCount(); a++) {
            d[a].getAnimateGlyph(c, b, this.paintState)
        }
    }, getAnimateStepNumber: function () {
        var a = 0;
        if (this.animateGlyph) {
            a = this.animateGlyph.length
        }
        if (this.trendLineAnimateGlyph && a <= 0 && this.trendLineAnimateGlyph[0]) {
            return this.trendLineAnimateGlyph[0].length
        }
        if (this.points && a <= 0) {
            var b = 0;
            while (b < this.points.length && (!this.points[b].animateGlyph || this.points[b].valueIsNull || this.points[b].animateGlyph.length === 0)) {
                b++
            }
            if (b < this.points.length && this.points[b].animateGlyph) {
                return this.points[b].animateGlyph.length
            }
        }
        return a
    }, findOnMoveGlyph: function (a, g) {
        if (this.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || this.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
            return
        }
        var c = this.glyph ? this.glyph.getShape().getInteractivePath() : null;
        if (this.seriesDragEnable && g._isMouseDown) {
            if (FR.Chart.GraphHelper.isDrawingEnd) {
                for (var e = 0; e < this.getDataPointCount(); e++) {
                    this.points[e].findOnMoveGlyph(a, g);
                    if (g._hasfound) {
                        break
                    }
                }
                if (!g._hasfound && c && c.containsPoint(a.x, a.y)) {
                    g._hasfound = true;
                    g._lastHover = this
                }
                if (g._hasfound && !g._isMouseMoving) {
                    g._draggingTarget = this;
                    this.paintState = FR.Chart.ChartPaintConstants.STATE_TRANSPARENT
                }
            }
        } else {
            this.nearByPoint = null;
            for (var e = this.getDataPointCount() - 1; e >= 0; e--) {
                this.points[e].findOnMoveGlyph(a, g);
                if (g._hasfound) {
                    break
                }
            }
            if (g._hasfound) {
                return
            }
            if (c && c.containsPoint(a.x, a.y)) {
                g._hasfound = true;
                g._lastHover = this;
                var d = Number.MAX_VALUE;
                for (var e = 0; e < this.getDataPointCount(); e++) {
                    if (this.points[e].glyph) {
                        var f = this.points[e].glyph.getShape().getBounds2D();
                        var b = this.getAbsLength(f, a);
                        if (b < d && this.points[e].tooltip != null) {
                            d = b;
                            this.nearByPoint = this.points[e]
                        }
                    }
                }
            }
        }
    }, getAbsLength: function (c, b) {
        if (!c || !b) {
            return Number.MAX_VALUE
        }
        var a = c.x + c.width / 2;
        var d = c.y + c.height / 2;
        return (a - b.x) * (a - b.x) + (d - b.y) * (d - b.y)
    }, doOnMove: function (r, p, d) {
        var q = this.points[0] && this.points[0].glyph && this.points[0].glyph.marker && this.points[0].glyph.marker.getMarkerType;
        if (!d instanceof FR.Chart.Area3DPlotGlyph) {
            FR.Chart.HighUtils.doFocus(this.glyph, r)
        }
        if (q) {
            if (!r) {
                return
            }
            r.save();
            r.globalCompositeOperation = "destination-out";
            if (d !== undefined && d !== null) {
                for (var e = 0; e < d.dataSeries.length; e++) {
                    var h = d.dataSeries[e];
                    if (h.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || h.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
                        continue
                    }
                    for (var j = 0; j < this.points.length; j++) {
                        var k = h.points[j].glyph;
                        if (k) {
                            k.draw(r)
                        }
                    }
                }
            } else {
                for (var j = 0; j < this.points.length; j++) {
                    var k = this.points[j].glyph;
                    if (k) {
                        k.draw(r)
                    }
                }
            }
            r.restore()
        }
        if (this.nearByPoint && d.isTooltipEnable) {
            var o = this.nearByPoint;
            if (this.outerBounds && this.outerBounds.dataSeries) {
                this.outerBounds.currentChosenSeriesIndex = this.seriesIndex;
                if (this.isTooltip4Series) {
                    var b = [];
                    var e = 0;
                    var m = this.outerBounds.bounds.y + this.outerBounds.bounds.height;
                    var c = this.outerBounds.bounds.x;
                    for (var g = 0; g < this.outerBounds.dataSeries.length; g++) {
                        var f = this.outerBounds.dataSeries[g];
                        if (f && f.points && f.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                            var a = f.points[o.categoryIndex];
                            var k = a.glyph;
                            this.drawChosenPoint(a, r);
                            if (f.glyph && f.glyph.toolTipBackground) {
                                b[g] = f.glyph.toolTipBackground.color
                            } else {
                                if (k.toolTipBackground) {
                                    b[g] = k.toolTipBackground.color
                                }
                            }
                            var n = 0;
                            var l = 0;
                            if (k.shape) {
                                n = k.shape.x;
                                l = k.shape.y
                            } else {
                                if (k.bounds) {
                                    n = k.bounds.x;
                                    l = k.bounds.y
                                } else {
                                    n = k.marker.x;
                                    l = k.marker.y
                                }
                            }
                            if (l < m || l == m && n > c) {
                                m = l;
                                c = n;
                                e = g
                            }
                        }
                    }
                    if (this.outerBounds.dataSeries[e] && this.outerBounds.dataSeries[e].points[o.categoryIndex]) {
                        o = this.outerBounds.dataSeries[e].points[o.categoryIndex]
                    }
                    if (o) {
                        FR.Chart.Tooltip.dataPointTip4Series(r, o.tooltip, p, o.glyph, o.glyph.toolTipBackground, this.outerBounds, this.tooltipStyle, b)
                    }
                } else {
                    FR.Chart.Tooltip.dataPointTip4Point(r, o.tooltip, p, o.glyph, this.glyph.toolTipBackground, this.outerBounds, this.tooltipStyle)
                }
            }
        }
        if (this.nearByPoint) {
            this.drawChosenPoint(this.nearByPoint, r)
        }
    }, drawChosenPoint: function (a, b) {
        if (a.glyph && a.glyph.marker && a.glyph.marker.getMarkerType) {
            a.glyph.drawOnMove = true;
            a.glyph.draw(b);
            a.glyph.drawOnMove = false
        } else {
            FR.Chart.HighUtils.doFocus(a.glyph, b)
        }
    }, doTrendLineTooltip: function (e, d) {
        if (this.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return
        }
        if (this.trendLineList && this.trendLineList.length > 0) {
            for (var b = 0;
                 b < this.trendLineList.length; b++) {
                var c = this.trendLineList[b];
                var a = e.x;
                var h = c.calculator(a);
                var g = c.valueAxisGlyph.getPointValue4TrendLine(h, e.y);
                var f = new FR.Chart.TooltipString();
                f.formatValue(c.trendLineName + " : " + g);
                d[d.length] = {text: [f], lineColor: c.lineStyleInfo.attrLineColor.lineColor}
            }
        }
    }, drawAnimateGlyph: function (a, b) {
        if (this.paintState == FR.Chart.ChartPaintConstants.STATE_UNENABLE || this.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
            return
        }
        if (this.animateGlyph && this.animateGlyph.length > 0 && b < this.animateGlyph.length) {
            this.animateGlyph[b].draw(a)
        }
        var d = this.points;
        for (var c = 0; c < this.getDataPointCount(); c++) {
            d[c].drawAnimateGlyph(a, b);
            if (d[c].dataPointStyle && d[c].dataPointStyle.paintHighLight) {
                d[c].dataPointStyle.paintHighLight(a)
            }
        }
    }, drawAnimateGlyph4TrendLine: function (a, b) {
        if (this.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || this.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
            return
        }
        if (this.trendLineAnimateGlyph[0] && this.trendLineAnimateGlyph.length > 0 && b < this.trendLineAnimateGlyph[0].length) {
            for (var c = 0; c < this.trendLineAnimateGlyph.length;
                 c++) {
                if (this.trendLineAnimateGlyph[c]) {
                    var d = this.trendLineAnimateGlyph[c];
                    if (d[b]) {
                        d[b].draw(a)
                    }
                }
            }
        }
    }
});
FR.Chart.DataSeries4Area = FR.extend(FR.Chart.DataSeries, {
    getAnimateGlyph: function (b, a) {
        if (this.paintState == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return
        }
        if (this.topFoldLine && (this.glyph || this.lastGlyph)) {
            this.topFoldLineAnimateGlyph = (this.glyph || this.lastGlyph).getAnimateGlyph4TopFoldLine(b, a, this.topFoldLine, this.lastGlyph, this.paintState)
        }
        FR.Chart.DataSeries4Area.superclass.getAnimateGlyph.apply(this, [b, a])
    }, drawAnimateGlyph4TopFoldLine: function (a, b) {
        if (this.paintState == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return
        }
        if (this.topFoldLineAnimateGlyph && this.topFoldLineAnimateGlyph.length > 0 && b < this.topFoldLineAnimateGlyph.length) {
            this.topFoldLineAnimateGlyph[b].draw(a)
        }
    }
});
FR.Chart = FR.Chart || {};
FR.Chart.LineGlyph = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.lineStyle = FR.pick(a.lineStyle, FR.Chart.Constants.LINE_THIN);
        this.lineColor = FR.pick(a.lineColor, "black");
        this.alpha = FR.pick(a.alpha, 1);
        this.line = null
    }, draw: function (b) {
        if (this.line && this.lineColor) {
            if (!b) {
                return
            }
            b.save();
            b.globalAlpha = this.alpha;
            b.strokeStyle = this.lineColor;
            b.lineWidth = FR.Chart.GraphHelper.getLineStyleSize(this.lineStyle);
            var c = this.line.startPoint;
            var a = this.line.endPoint;
            b.moveTo(c.x, c.y);
            b.lineTo(a.x, a.y);
            b.stroke();
            b.restore()
        }
    }, getShape: function () {
        return this.line
    }
});
FR.Chart.TrendLineGlyph = FR.extend(FR.Chart.FoldLine, {
    initConstants: function (a) {
        a = a || {};
        this.equation = FR.pick(a.equation, FR.Chart.Constants.TRENDLINE_POLYNOMIAL);
        this.square = FR.pick(a.square, 6);
        this.moveAverage = FR.pick(a.moveAverage, 5);
        FR.Chart.TrendLineGlyph.superclass.initConstants.apply(this, [a]);
        this.drawBounds = null;
        this.actionXVal = [];
        this.actionYVal = [];
        this.val = []
    }, drawShape: function (a, b) {
        this.drawBounds = a;
        if (b && this.equation === 5) {
            var c = parseInt(this.actionXVal.length * b);
            var h = new FR.Chart.GeneralPath();
            for (var d = 0; d < c; d++) {
                if (d === 0) {
                    h.moveTo(this.actionXVal[d], this.actionYVal[d])
                } else {
                    h.lineTo(this.actionXVal[d], this.actionYVal[d])
                }
            }
            var j = new FR.Chart.GeneralPath();
            FR.Chart.FoldLine.curveTo(j, h);
            this.generalPath = j
        } else {
            var g = true;
            var j = new FR.Chart.GeneralPath();
            for (var f = a.x, e; f < a.width + a.x; f += 1) {
                e = this.calculator(f);
                if (e > a.height + a.y || e < 0) {
                    g = true
                } else {
                    if (g) {
                        j.moveTo(f, e);
                        g = false
                    } else {
                        j.lineTo(f, e)
                    }
                }
            }
            this.generalPath = j
        }
    }, getAnimateGlyph: function (c, f) {
        var g = this.drawBounds.width;
        var a = this.drawBounds.height;
        if (g <= 0 || a <= 0) {
            return []
        }
        var d = [];
        for (var e = 0; e < c; e++) {
            if (f == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                d[e] = this
            } else {
                var b = new FR.Chart.TrendLineGlyph();
                b.val = this.val;
                b.lineStyleInfo = this.lineStyleInfo;
                b.equation = this.equation;
                b.actionXVal = this.actionXVal;
                b.actionYVal = this.actionYVal;
                b.drawShape(new FR.Chart.Bounds(this.drawBounds.x, this.drawBounds.y, FR.Chart.ChartEase.easeOutQuint(e + 1, 0, g, c), a), (e + 1) / c);
                d[e] = b
            }
        }
        return d
    }, fitting: function (b, a) {
        if (b.length != a.length) {
            return
        }
        this.square = this.square > b.length - 1 ? b.length - 1 : this.square;
        if (this.equation == FR.Chart.Constants.TRENDLINE_LINEAR) {
            this.linear(b, a)
        } else {
            if (this.equation == FR.Chart.Constants.TRENDLINE_POLYNOMIAL) {
                this.polynomial(b, a, this.square)
            } else {
                if (this.equation == FR.Chart.Constants.TRENDLINE_LOG) {
                    this.log(b, a)
                } else {
                    if (this.equation == FR.Chart.Constants.TRENDLINE_EXPONENT) {
                        this.exponent(b, a)
                    } else {
                        if (this.equation == FR.Chart.Constants.TRENDLINE_POWER) {
                            this.power(b, a)
                        } else {
                            if (this.equation == FR.Chart.Constants.TRENDLINE_MA) {
                                this.ma(b, a)
                            }
                        }
                    }
                }
            }
        }
    }, calculator: function (a) {
        if (this.equation == FR.Chart.Constants.TRENDLINE_LINEAR) {
            return this.linearFunc(a)
        } else {
            if (this.equation == FR.Chart.Constants.TRENDLINE_POLYNOMIAL) {
                return this.polynomialFunc(a)
            } else {
                if (this.equation == FR.Chart.Constants.TRENDLINE_LOG) {
                    return this.logFunc(a)
                } else {
                    if (this.equation == FR.Chart.Constants.TRENDLINE_EXPONENT) {
                        return this.exponentFunc(a)
                    } else {
                        if (this.equation == FR.Chart.Constants.TRENDLINE_POWER) {
                            return this.powerFunc(a)
                        } else {
                            if (this.equation == FR.Chart.Constants.TRENDLINE_MA) {
                                return this.maFunc(a)
                            }
                        }
                    }
                }
            }
        }
        return NaN
    }, linear: function (g, d) {
        var f = 0, e = 0, b = 0, a = 0;
        var h = g.length;
        for (var c = 0; c < g.length; c++) {
            f += g[c];
            e += d[c];
            b += g[c] * g[c];
            a += g[c] * d[c]
        }
        if (f * f - b * h === 0) {
            return
        }
        this.val[0] = (e * f - a * h) / (f * f - b * h);
        this.val[1] = (e - f * this.val[0]) / h
    }, polynomial: function (u, p, o) {
        o++;
        var v;
        var r = [o];
        var d = [o];
        for (var m = 0; m < o; m++) {
            r[m] = [u.length];
            d[m] = [o]
        }
        var c = [o];
        var q = [o];
        this.val = [o];
        var m, g, f, e;
        for (m = 0; m < o; m++) {
            for (g = 0; g < u.length; g++) {
                v = 1;
                for (e = 0; e < m; e++) {
                    v = v * u[g]
                }
                r[m][g] = v
            }
        }
        for (m = 0; m < o; m++) {
            for (f = 0; f < o; f++) {
                v = 0;
                for (g = 0; g < u.length; g++) {
                    v += r[m][g] * r[f][g]
                }
                d[m][f] = v
            }
        }
        for (m = 0; m < o; m++) {
            v = 0;
            for (g = 0; g < u.length; g++) {
                v += p[g] * r[m][g]
            }
            c[m] = v
        }
        for (m = 1; m < o; m++) {
            d[m][0] = d[m][0] / d[0][0]
        }
        for (m = 1; m < o; m++) {
            for (g = m; g < o; g++) {
                var h = 0;
                for (f = 0; f < m; f++) {
                    var s = d[f][g];
                    var r = d[m][f];
                    h = h + s * r
                }
                var n = d[m][g] - h;
                d[m][g] = n;
                if (g + 1 != o) {
                    var h = 0;
                    for (f = 0; f < m; f++) {
                        h += d[f][m] * d[g + 1][f]
                    }
                    d[g + 1][m] = (d[g + 1][m] - h) / d[m][m]
                }
            }
        }
        q[0] = c[0];
        for (m = 1; m < o; m++) {
            v = 0;
            for (g = 0; g < m; g++) {
                v += d[m][g] * q[g]
            }
            q[m] = c[m] - v
        }
        this.val[o - 1] = q[o - 1] / d[o - 1][o - 1];
        for (m = o - 2; m >= 0; m--) {
            v = 0;
            for (g = m + 1; g < o; g++) {
                v += d[m][g] * this.val[g]
            }
            this.val[m] = (q[m] - v) / d[m][m]
        }
    }, log: function (e, c) {
        var f = [];
        var d = [];
        var a = 0;
        for (var b = 0; b < e.length; b++) {
            if (e[b] > 0) {
                f[a] = Math.log(e[b]);
                d[a] = c[b];
                a++
            }
        }
        this.linear(f, d)
    }, exponent: function (f, d) {
        var g = [];
        var e = [];
        var a = 0;
        for (var c = 0; c < d.length; c++) {
            if (d[c] > 0) {
                g[a] = f[c];
                e[a] = Math.log(d[c]);
                a++
            }
        }
        this.linear(g, e);
        var b = this.val[0];
        this.val[0] = Math.exp(this.val[1]);
        this.val[1] = b
    }, power: function (f, d) {
        var g = [];
        var e = [];
        var a = 0;
        for (var c = 0; c < f.length; c++) {
            if (f[c] > 0 && d[c] > 0) {
                g[a] = Math.log(f[c]);
                e[a] = Math.log(d[c]);
                a++
            }
        }
        this.linear(g, e);
        var b = this.val[0];
        this.val[0] = Math.exp(this.val[1]);
        this.val[1] = b
    }, ma: function (g, e) {
        this.actionXVal = g;
        this.actionYVal = [];
        var a = new FR.Chart.GeneralPath();
        for (var d = 0; d < g.length; d++) {
            if (d === 0) {
                a.moveTo(g[d], e[d]);
                this.actionYVal[d] = e[d]
            } else {
                if (d < this.moveAverage) {
                    var h = 0;
                    for (var c = 0; c < d + 1; c++) {
                        h += e[c]
                    }
                    a.lineTo(g[d], h / (d + 1));
                    this.actionXVal[d] = g[d];
                    this.actionYVal[d] = h / (d + 1)
                } else {
                    var h = 0;
                    for (var b = 0; b < this.moveAverage; b++) {
                        h += e[d - b]
                    }
                    a.lineTo(g[d], h / this.moveAverage);
                    this.actionYVal[d] = h / this.moveAverage
                }
            }
        }
        var f = new FR.Chart.GeneralPath();
        FR.Chart.FoldLine.curveTo(f, a);
        this.generalPath = f
    }, linearFunc: function (a) {
        return this.val[0] * a + this.val[1]
    }, polynomialFunc: function (b) {
        var a = 0;
        for (var c = 0; c < this.val.length; c++) {
            a += this.val[c] * Math.pow(b, c)
        }
        return a
    }, logFunc: function (a) {
        if (a <= 0) {
            return NaN
        }
        return this.val[0] * Math.log(a) + this.val[1]
    }, exponentFunc: function (a) {
        return this.val[0] * Math.exp(a * this.val[1])
    }, powerFunc: function (a) {
        return this.val[0] * Math.pow(a, this.val[1])
    }, maFunc: function (p) {
        if (this.actionXVal.length === 2) {
            if (p < this.actionXVal[0] || p > this.actionXVal[1]) {
                return NaN
            }
            if (this.actionXVal[0] == this.actionXVal[1]) {
                return this.actionYVal[0]
            } else {
                var r = Math.abs(p - this.actionXVal[0]) / Math.abs(this.actionXVal[1] - this.actionXVal[0]);
                return this.actionYVal[0] - Math.abs(this.actionYVal[0] - this.actionYVal[1]) * r
            }
        }
        var l = this.actionXVal;
        var b = this.actionYVal;
        var d, a = 0;
        for (var f = 0; f < this.actionXVal.length;
             f++) {
            if (p >= this.actionXVal[f] && p <= this.actionXVal[f + 1]) {
                d = f;
                a = f + 1;
                break
            }
        }
        if (a <= d) {
            return NaN
        }
        var g = this.actionYVal[d], q = this.actionYVal[a];
        var c = 0.6;
        var o = [];
        var n = [];
        for (var f = 0; f < l.length - 1; f++) {
            o[f] = (l[f] + l[f + 1]) / 2;
            n[f] = (b[f] + b[f + 1]) / 2
        }
        var k = [];
        var j = [];
        for (var f = 1; f < o.length; f++) {
            var h = l[f] - (o[f - 1] + o[f]) / 2;
            var e = b[f] - (n[f - 1] + n[f]) / 2;
            k[(f - 1) * 2] = l[f] + (o[f - 1] + h - l[f]) * c;
            j[(f - 1) * 2] = b[f] + (n[f - 1] + e - b[f]) * c;
            k[(f - 1) * 2 + 1] = l[f] + (o[f] + h - l[f]) * c;
            j[(f - 1) * 2 + 1] = b[f] + (n[f] + e - b[f]) * c
        }
        var m = NaN;
        var r = Math.abs(p - l[d]) / Math.abs(l[a] - l[d]);
        if (a === 1 || a == l.length - 1) {
            m = (1 - r) * (1 - r) * g + 2 * r * (1 - r) * j[0] + r * r * q
        } else {
            m = (1 - r) * (1 - r) * (1 - r) * g + 3 * j[d * 2 - 1] * r * (1 - r) * (1 - r) + 3 * j[d * 2] * r * r * (1 - r) + q * r * r * r
        }
        return m
    }
});
FR.Chart.GeneralGlyph = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.info = new FR.Chart.GeneralInfo(a.background || a.info)
    }, getBackground: function () {
        return this.info.getBackground()
    }, setBackground: function (a) {
        this.info.setBackground(a)
    }, getBorderStyle: function () {
        return this.info.getBorderStyle()
    }, setBorderStyle: function (a) {
        this.info.setBorderStyle(a)
    }, getBorderColor: function () {
        return this.info.getBorderColor()
    }, setBorderColor: function (a) {
        this.info.setBorderColor(a)
    }, isRoundBorder: function () {
        return this.info.isRoundBorder()
    }, setRoundBorder: function (a) {
        this.info.setRoundBorder(a)
    }, getAlpha: function () {
        return this.info.getAlpha()
    }, setAlpha: function (a) {
        this.info.setAlpha(a)
    }, draw: function (a) {
        this.info.paint(a, this.getOutline4Fill())
    }, draw4Demo: function (a) {
        var b = this.getOutline4Fill();
        if (b) {
            b.paint(a)
        }
    }
});
FR.Chart.RectangleGlyph = FR.extend(FR.Chart.GeneralGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.visible = FR.pick(a.visible, true);
        this.bounds = null;
        FR.Chart.RectangleGlyph.superclass.initConstants.apply(this, [a])
    }, getBounds: function () {
        if (this.bounds) {
            return this.bounds.getBounds2D()
        }
        return null
    }, getOutline4Fill: function () {
        return this.bounds
    }, getShape: function () {
        return this.bounds
    }
});
FR.Chart.ShapeGlyph = FR.extend(FR.Chart.GeneralGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.shape = null;
        FR.Chart.ShapeGlyph.superclass.initConstants.apply(this, [a])
    }, setShape: function (a) {
        this.shape = a
    }, getShape: function () {
        return this.shape
    }, getOutline4Fill: function () {
        return this.getShape()
    }, draw: function (a) {
        if (this.dataPointStyle) {
            this.dataPointStyle.paintStyle(a)
        } else {
            this.info.paint(a, this.getOutline4Fill())
        }
    }, drawWithOutBorder: function (a) {
        if (this.dataPointStyle) {
            this.dataPointStyle.paintStyle(a)
        } else {
            this.info.paintWithOutBorder(a, this.getOutline4Fill())
        }
    }, drawOnlyBorder: function (a, b) {
        if (this.dataPointStyle) {
            return
        }
        this.info.paintOnlyBorder(a, this.getOutline4Fill())
    }, isBorderDefault: function () {
        if (this.dataPointStyle || !this.info || !this.info.seriesAttrBorder) {
            return true
        }
        return this.info.seriesAttrBorder.borderStyle === FR.Chart.Constants.LINE_THIN && this.info.seriesAttrBorder.borderColor === "rgb(255,255,255)"
    }, drawWithOutStyle: function (a) {
        this.info.paint(a, this.getOutline4Fill())
    }, getFillStyleColor: function () {
        if (this.info && this.info.seriesAttrBackground.seriesBackground) {
            return this.info.seriesAttrBackground.seriesBackground.color
        }
        return null
    }, getTooltipBounds4Shape: function (c, b) {
        if (this.shape instanceof FR.Chart.Arc2D || this.shape instanceof FR.Chart.Ring) {
            var a = this.shape.getHalfAnglePoint();
            var e = this.shape.getHalfAngle();
            return this.getTooltipBounds4ArcRing(c, b, a, e)
        }
        if (this.shape instanceof FR.Chart.Pie3D) {
            var a = this.shape.top().getMiddlePoint();
            var e = this.shape.top().getMiddleAngle();
            return this.getTooltipBounds4ArcRing(c, b, a, e)
        }
        if (this.shape instanceof FR.Chart.Ring3D) {
            var d = this.shape.outerCylinderList[0];
            if (d) {
                var a = d.top().getMiddlePoint();
                var e = d.top().getMiddleAngle();
                return this.getTooltipBounds4ArcRing(c, b, a, e)
            }
        }
        if (this.shape instanceof FR.Chart.Bounds) {
            return this.getTooltipBounds4Bounds(c, b)
        }
        if (this.shape instanceof FR.Chart.Cubic) {
            return this.getTooltipBounds4Cubic(c, b)
        }
        if (this.shape instanceof FR.Chart.GeneralPath) {
            return this.getTooltipBounds4GeneralPath(c, b)
        }
    }, getTooltipBounds4GeneralPath: function (d, c) {
        var a;
        var e;
        var b = this.shape.getBounds2D();
        a = b.x + b.width / 2;
        if (a + d.width > c.x + c.width) {
            a -= d.width
        }
        a = this.getTooltipStartX(a, d, c, false);
        e = this.shape.getVerticalMiddlePointY();
        if (e + d.height > c.y + c.height) {
            e -= d.height
        }
        return new FR.Chart.Bounds(a, e, d.width, d.height)
    }, getTooltipBounds4Cubic: function (c, b) {
        var a;
        var d;
        if (this.shape.horizontalDrawBar) {
            a = this.shape.points[3].x - c.width;
            if (a < b.x) {
                a = this.shape.points[3].x
            }
            a = this.getTooltipStartX(a, c, b, true);
            d = this.shape.points[3].y + 3;
            if (d + c.height > b.y + b.height) {
                d = this.shape.points[1].y - c.height - 3
            }
            return new FR.Chart.Bounds(a, d, c.width, c.height)
        } else {
            d = this.shape.points[1].y;
            if (d + c.height > b.y + b.height) {
                d = this.shape.points[1].y - c.height
            }
            a = this.shape.points[1].x + 3;
            if (a + c.width > b.x + b.width) {
                a = this.shape.points[0].x - c.width - 3;
                d = this.shape.points[0].y - c.height
            }
            a = this.getTooltipStartX(a, c, b, false);
            return new FR.Chart.Bounds(a, d, c.width, c.height)
        }
    }, getTooltipBounds4Bounds: function (c, b) {
        var a;
        var d;
        if (this.shape.isHorizontal4Bounds) {
            a = this.shape.x + this.shape.width - c.width;
            if (a < b.x) {
                a = this.shape.x + this.shape.width
            }
            a = this.getTooltipStartX(a, c, b, true);
            d = this.shape.y + this.shape.height + 3;
            if (d + c.height > b.y + b.height) {
                d = this.shape.y - c.height - 3
            }
            d = Math.max(d, b.y - 3);
            return new FR.Chart.Bounds(a, d, c.width, c.height)
        } else {
            a = this.shape.x + this.shape.width + 3;
            if (a + c.width > b.x + b.width) {
                a = this.shape.x - c.width - 3
            }
            a = this.getTooltipStartX(a, c, b, false);
            d = this.shape.y;
            if (d + c.height > b.y + b.height) {
                d = this.shape.y - c.height
            }
            return new FR.Chart.Bounds(a, d, c.width, c.height)
        }
    }, getTooltipStartX: function (a, c, b, d) {
        if (d) {
            if (a + c.width > b.x + b.width) {
                return b.x
            }
        } else {
            if (a < b.x) {
                return Math.max(b.x, b.x + b.width - c.width)
            }
        }
        return a
    }, getTooltipBounds4ArcRing: function (d, c, b, e) {
        var a;
        var f;
        e %= 360;
        if (e < 90) {
            a = b.x - d.width - 1;
            f = b.y - d.height - 1;
            if (a < c.x || f < c.y) {
                a = b.x + 1;
                f = b.y + 1
            }
        } else {
            if (e < 180) {
                a = b.x + 1;
                f = b.y - d.height - 1;
                if (a + d.width > c.x + c.width || f < c.y) {
                    a = b.x - d.width - 1;
                    f = b.y + 1
                }
            } else {
                if (e < 270) {
                    a = b.x + 1;
                    f = b.y + 1;
                    if (a + d.width > c.x + c.width || f + d.height > c.y + c.height) {
                        a = b.x - d.width - 1;
                        f = b.y - d.height - 1
                    }
                } else {
                    a = b.x - d.width - 1;
                    f = b.y + 1;
                    if (a < c.x || f + d.height > c.y + c.height) {
                        a = b.x + 1;
                        f = b.y - d.height - 1
                    }
                }
            }
        }
        if (90 <= e && e < 270) {
            if (a < c.x) {
                a = c.x
            }
        } else {
            if (a + d.width > c.x + c.width) {
                a = c.x
            }
        }
        return new FR.Chart.Bounds(a, f, d.width, d.height)
    }, getAnimateGlyph: function (e, d, b, g) {
        if (this.isFade) {
            return this.getAnimateGlyphWithFade(e, d, b, g)
        }
        if (this.shape) {
            var f = null;
            if (b && b.shape && d == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
                f = b.shape
            }
            this.animateShape = this.shape.getAnimateShape(e, d, f, g)
        }
        var a = [];
        for (var c = 0; c < this.animateShape.length; c++) {
            if (d == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                a[c] = this
            } else {
                a[c] = new FR.Chart.ShapeGlyph();
                a[c].shape = this.animateShape[c];
                a[c].info.seriesAttrAlpha = this.info.seriesAttrAlpha;
                a[c].info.seriesAttrBorder = this.info.seriesAttrBorder;
                a[c].info.seriesAttrBackground = this.info.seriesAttrBackground;
                a[c].info.shadow = this.info.shadow;
                a[c].info.outerLight = this.info.outerLight
            }
            if (this.dataPointStyle) {
                a[c].dataPointStyle = this.dataPointStyle.clone(this.animateShape[c]);
                a[c].dataPointStyle.animateGlyph = a[c]
            }
        }
        return a
    }, getAnimateGlyphWithFade: function (e, d, b, f) {
        if (f == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        var a = [];
        for (var c = 0; c < e; c++) {
            if ((d == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) || (d == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && f == FR.Chart.ChartPaintConstants.STATE_ENABLE)) {
                a[c] = this
            } else {
                if ((d == FR.Chart.ChartPaintConstants.ACTION_MODEL_DEFAULT && f == FR.Chart.ChartPaintConstants.STATE_ENABLE) || (d == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && f == FR.Chart.ChartPaintConstants.STATE_APPEAR)) {
                    a[c] = new FR.Chart.ShapeGlyph();
                    a[c].shape = this.shape;
                    a[c].info.seriesAttrAlpha.alpha = FR.Chart.ChartEase.easeInCirc(c + 1, 0, this.info.seriesAttrAlpha.alpha, e);
                    a[c].info.seriesAttrBorder = this.info.seriesAttrBorder;
                    a[c].info.seriesAttrBackground = this.info.seriesAttrBackground;
                    a[c].info.shadow = this.info.shadow;
                    a[c].info.outerLight = this.info.outerLight
                } else {
                    if (d == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && f == FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
                        a[c] = new FR.Chart.ShapeGlyph();
                        a[c].shape = this.shape;
                        a[c].info.seriesAttrAlpha.alpha = FR.Chart.ChartEase.easeOutCirc(c + 1, this.info.seriesAttrAlpha.alpha, 0 - this.info.seriesAttrAlpha.alpha, e);
                        a[c].info.seriesAttrBorder = this.info.seriesAttrBorder;
                        a[c].info.seriesAttrBackground = this.info.seriesAttrBackground;
                        a[c].info.shadow = this.info.shadow;
                        a[c].info.outerLight = this.info.outerLight
                    }
                }
            }
        }
        return a
    }, getAnimateGlyph4TopFoldLine: function (f, e, c, b, h) {
        if (h <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        if (this.dataPointStyle && this.dataPointStyle instanceof FR.Chart.AreaPlane3DStyle) {
            return []
        }
        if (this.shape && c) {
            var g = null;
            if (b && e == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE) {
                g = b.shape
            }
            c.animateShape = this.shape.getTopFoldLineAnimateShape(f, e, g, h)
        }
        var a = [];
        for (var d = 0; d < c.animateShape.length; d++) {
            a[d] = new FR.Chart.FoldLine(c.animateShape[d]);
            a[d].lineStyleInfo = c.lineStyleInfo
        }
        return a
    }
});
FR.Chart.TextGlyph = FR.extend(FR.Chart.RectangleGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.text = a.text ? $.trim(a.text) : null;
        this.position = FR.Chart.ChartUtils.getPosition(FR.pick(a.align || a.position || FR.Chart.Constants.CENTER));
        this.textAttr = new FR.Chart.TextAttr(a.textAttr);
        if (a.font) {
            this.textAttr.frFont = new FR.Chart.FRFont(a.font)
        }
        FR.Chart.TextGlyph.superclass.initConstants.apply(this, [a]);
        this.boundsGap = FR.pick(a.boundsGap, 0)
    }, draw: function (b, a) {
        if (!this.getBounds() || !this.visible) {
            return
        }
        var c = 0;
        if (this.textAttr != null) {
            c = this.textAttr.rotation
        }
        var f = c * Math.PI / 180;
        var e = 0;
        var d = 0;
        if (c > 0) {
            e = Math.sin(f) * this.getBounds().height
        } else {
            d = Math.sin(f) * this.getBounds().width
        }
        if (!b) {
            return
        }
        b.save();
        b.translate(this.getBounds().x + e, this.getBounds().y - d);
        b.rotate(f);
        FR.Chart.RectangleGlyph.superclass.draw.apply(this, [b]);
        b.translate(-this.getBounds().x + e, -this.getBounds().y - d);
        b.globalAlpha = 1;
        this.drawText(b, a);
        b.restore()
    }, drawText: function (j, k) {
        var a = this.getBounds();
        var c = this.getTextBoundsWithOutGap(a);
        if (c != null && this.text) {
            var d = FR.Chart.TextUtils.changeAllReline2Normal(this.text);
            var g = d.split("\n");
            for (var f = 0; f < g.length; f++) {
                var e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(g[f], this.textAttr);
                var i = this.boundsGap;
                var h = this.boundsGap + (e.height) * f;
                if (this.textAttr != null && this.textAttr.alignText == FR.Chart.Style.VERTICALTEXT) {
                    i = this.boundsGap + (e.width) * f;
                    h = this.boundsGap
                } else {
                    if (this.position == FR.Chart.Constants.CENTER) {
                        i = this.boundsGap + (c.width - e.width) / 2
                    } else {
                        if (this.position == FR.Chart.Constants.LEFT) {
                            i = this.boundsGap
                        } else {
                            if (this.position == FR.Chart.Constants.RIGHT) {
                                i = this.boundsGap + (c.width - e.width)
                            }
                        }
                    }
                }
                var b = new FR.Chart.Bounds(i + a.x, h + 2 + a.y, e.width, e.height);
                FR.Chart.TextUtils.drawLabelWithNoRotation(j, g[f], this.textAttr, b, k)
            }
        }
    }, drawAxisTitle: function (h, i) {
        if (this.textAttr != null && this.textAttr.alignText == FR.Chart.Style.VERTICALTEXT) {
            if (!this.getBounds() || !this.visible) {
                return
            }
            var b = this.getTextBoundsWithOutGap(this.getBounds());
            if (b != null && this.text) {
                if (!this.textAttr.frFont) {
                    this.textAttr.frFont = new FR.Chart.FRFont()
                }
                var c = new FR.Chart.TextAttr();
                c.frFont = this.textAttr.frFont;
                c.alignText = FR.Chart.Style.HORIZONTALTEXT;
                var d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(this.text, c);
                var e = new FR.Chart.Dimension2D();
                e.width = this.textAttr.frFont.size + this.boundsGap * 2;
                e.height = d.width + this.boundsGap * 4;
                var g = this.boundsGap + this.bounds.x;
                var f = this.boundsGap + (b.height - e.height) / 2 + this.bounds.y;
                var a = new FR.Chart.Bounds(g, f, e.width, e.height);
                if (this.textAttr.rotation === -90) {
                    a.x += this.textAttr.frFont.size
                }
                this.textAttr.alignText = FR.Chart.Style.HORIZONTALTEXT;
                FR.Chart.TextUtils.drawLabelWithRotation(h, this.text, this.textAttr, a);
                this.textAttr.alignText = FR.Chart.Style.VERTICALTEXT
            }
        } else {
            this.drawText(h, i)
        }
    }, getOutline4Fill: function () {
        var a = this.bounds;
        if (a && a.arcHeight) {
            return new FR.Chart.RoundBounds(a.x, a.y, a.width, a.height, a.arcWidth, a.arcHeight)
        } else {
            return new FR.Chart.Bounds(a.x, a.y, a.width, a.height)
        }
    }, getTextBoundsWithOutGap: function (a) {
        if (this.notEnoughBounds4Text(a)) {
            return null
        }
        return new FR.Chart.Bounds(a.x + this.boundsGap, a.y + this.boundsGap, a.width - this.boundsGap * 2, a.height - this.boundsGap * 2)
    }, notEnoughBounds4Text: function (a) {
        return a == null || Math.abs(a.width) < Math.abs(this.boundsGap) * 2 || Math.abs(a.height) < Math.abs(this.boundsGap) * 2
    }, preferredDimension: function () {
        return FR.Chart.TextUtils.calculateTextDimensionWithRotation(this.text, this.textAttr)
    }, dealCondition: function (c, a) {
        var b = c.getConditionAttr(new FR.Chart.AttrAlpha(), a);
        this.setAlpha(b.alpha)
    }
});
FR.Chart.TitleGlyph = FR.extend(FR.Chart.TextGlyph, {
    preferredDimension: function (d, b) {
        var c = 4;
        var g = 0.2;
        var a = FR.Chart.ChartUtils.dealTitleStringAutoWrap(this.text, this.textAttr, d - c * 2);
        var h = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a, this.textAttr);
        a = FR.Chart.TextUtils.changeAllReline2Normal(a);
        var f = a.split("\n");
        var e = f.length;
        return new FR.Chart.Dimension2D(Math.min(h.width + c * 2 * e, d), Math.min(h.height + c * 2 * e, b * g))
    }, draw: function (a) {
        if (!this.getBounds() || !this.visible) {
            return
        }
        if (!a) {
            return
        }
        a.save();
        FR.Chart.RectangleGlyph.superclass.draw.apply(this, [a]);
        a.restore();
        this.drawText()
    }, drawText: function () {
        var a = this.getBounds();
        var b = this.getTextBoundsWithOutGap(a);
        if (b) {
            var h = "left";
            if (this.position == FR.Chart.Constants.CENTER) {
                h = "center"
            } else {
                if (this.position == FR.Chart.Constants.RIGHT) {
                    h = "right"
                }
            }
            var c = "12px Microsoft YaHei";
            var g = "black";
            if (this.textAttr && this.textAttr.frFont) {
                var f = this.textAttr.frFont;
                var l = parseInt(f.size);
                c = f.style + " " + l + "px  " + f.fontName;
                g = f.color
            }
            var e = (FR.Chart.ChartUtils.isIE11()) ? 2 : 0;
            var k = FR.Chart.ChartUtils.dealTitleStringAutoWrap(this.text, this.textAttr, b.width);
            var d = FR.Chart.TextUtils.changeAllReline2Normal(k);
            d = d.replaceAll("\n", "<br>");
            var j = $("<div>" + d + "</div>").css("position", "absolute").css("font", c).css("color", g).css("overflow", "hidden").css("text-align", h).css("left", b.x).css("top", b.y).css("width", b.width + e).css("height", b.height + 3);
            var i = FR.Chart.currentDivKey;
            FR.Chart.DivCon.addDiv(i, j[0])
        }
    }
});
FR.Chart.PlotGlyph = FR.extend(FR.Chart.RectangleGlyph, {
    initConstants: function (b) {
        b = b || {};
        this.conditionCollection = new FR.Chart.ConditionCollection(b.conditionCollection);
        this.isNullValueBreak = FR.pick(b.isNullValueBreak, true);
        this.plotFillStyle = new FR.Chart.AttrFillStyle(b.color || b.plotFillStyle);
        this.plotStyle = FR.pick(b.plotStyle, FR.Chart.Constants.STYLE_NONE);
        this.hotTooltipStyle = new FR.Chart.AttrContents(b.tooltip || b.hotTooltipStyle);
        this.combinedSize = FR.pick(b.combinedSize, 50);
        this.wholeChartBackground = null;
        this.isTooltipEnable = true;
        if (b.theme) {
            this.plotStyle = FR.Chart.PlotStyle[b.theme]
        }
        this.dataSeries = [];
        if (b.seriesList && b.seriesList.length > 0) {
            var c = b.seriesList;
            for (var a = 0; a < c.length; a++) {
                this.dataSeries[a] = new FR.Chart[c[a].type](c[a])
            }
        }
        this.actionModel = null;
        FR.Chart.PlotGlyph.superclass.initConstants.apply(this, [b]);
        this.createHotTooltip();
        this.createDataLabel4EverySeries();
        this.currentChosenSeriesIndex = -1;
        this.isStockChart = false
    }, isSupportLegend: function () {
        return true
    }, seriesLabelsInSide: function () {
        return false
    }, getSecondValueAxisGlyph: function () {
    }, configSeries: function (c) {
        var b = this.conditionCollection.defaultAttr;
        if (c.trendLine) {
            var a = new FR.Chart.AttrTrendLine(c.trendLine);
            b.addAttr(a)
        }
    }, layoutDemoGlyph: function () {
    }, getStockDateRangeIndex: function (a, d, f, e) {
        for (var b = a.length - 1; b >= 0; b--) {
            var c = f.getDate4Value(a[b].categoryIndex);
            if (FR.Chart.ChartUtils.isBelongToSameUnit(c, d, e)) {
                return b
            }
        }
        return -1
    }, getStockChartAdjustDateType: function (b, a) {
        var c = FR.Chart.ChartUtils.getTwoDay(b, a, FR.Chart.Constants.Second);
        if (c / 60 < 1) {
            return FR.Chart.Constants.Minute
        }
        if (c / 3600 < 1) {
            return FR.Chart.Constants.Hour
        }
        if (c / (3600 * 24) < 1) {
            return FR.Chart.Constants.DAY
        }
        if (c / (3600 * 24) < b.getMonthDays()) {
            return FR.Chart.Constants.MONTH
        }
        return FR.Chart.Constants.YEAR
    }, getStockChartDatePointX: function (g, a, e, i) {
        var d = g.getDate4Value(a.categoryIndex);
        var c = FR.Chart.ChartUtils.getMiddleDate(d, e);
        var j = FR.Chart.ChartUtils.date2Int(c, g.mainType);
        var h = Math.round(g.getPoint2D(j + g.labelOffset).x);
        if (h < i.x) {
            var f = FR.Chart.ChartUtils.getEndDate4Type(d, e);
            j = FR.Chart.ChartUtils.date2Int(f, g.mainType);
            j = g.getCrossValue() + (j - g.getCrossValue()) / 2;
            h = Math.round(g.getPoint2D(j + g.labelOffset).x)
        } else {
            if (h > (i.x + i.width)) {
                var b = FR.Chart.ChartUtils.getStartDate4Type(d, e);
                j = FR.Chart.ChartUtils.date2Int(b, g.mainType);
                j = g.getArrowValue() - (g.getArrowValue() - j) / 2;
                h = Math.round(g.getPoint2D(j + g.labelOffset).x)
            }
        }
        if (g.stockChartMinDateInt) {
            g.stockChartMinDateInt = Math.min(g.stockChartMinDateInt, j)
        } else {
            g.stockChartMinDateInt = j
        }
        return h
    }, getDataPointByPara: function (b) {
        var h = b[0];
        var a = b[1];
        for (var g = 0; g < this.dataSeries.length; g++) {
            var f = this.dataSeries[g];
            for (var d = 0, e = this.getCategoryCount(); d < e; d++) {
                var c = f.points[d];
                if (c && FR.equals(h, c.categoryName) && FR.equals(a, c.seriesName)) {
                    return c
                }
            }
        }
    }, _getDataPointByXY: function (k) {
        var g = k[0];
        var h = k[1];
        var f = k[2];
        for (var c = 0; c < this.dataSeries.length; c++) {
            var d = this.dataSeries[c];
            for (var b = 0, e = this.getCategoryCount(); b < e; b++) {
                var a = d.points[b];
                if (FR.equals(g, a.seriesName) && FR.equals(h, a.x) && FR.equals(f, a.value)) {
                    return a
                }
            }
        }
    }, setTooltipValue: function (a) {
        var b = this.getDataPointByPara(a);
        if (b) {
            b.tooltip = a[a.length - 1]
        }
    }, triggerTooltip: function (b, f) {
        var c = this.getDataPointByPara(b);
        if (c && c.glyph && c.glyph.shape && c.glyph.shape.getBounds2D && f) {
            var h = c.glyph.shape.getBounds2D();
            if (h && f.handler) {
                var a = new FR.Chart.Point2D(h.getMiddleX(), h.getMiddleY());
                var e = f.plotGlyph;
                var d = f.getOnMoveCtx();
                f.clearOnMoveCtx();
                var g = f.handler.getTooltipDiv();
                d._tooltipDiv = g;
                c.doTooltip(d, a, e)
            }
        }
    }, sort: function (c) {
        var f = [];
        var k = [];
        for (var m = 0, s = this.getCategoryCount(); m < s; m++) {
            var r = 0;
            for (var h = 0, n = this.dataSeries.length; h < n; h++) {
                var l = this.dataSeries[h].points;
                if (l) {
                    var d = l[m];
                    r += d.value
                }
            }
            f.push(r);
            k.push(m)
        }
        for (var m = 0; m < f.length; m++) {
            var g = m;
            var a = f[m];
            for (var h = m + 1; h < f.length; h++) {
                if (c) {
                    if (f[h] < a) {
                        a = f[h];
                        g = h
                    }
                } else {
                    if (f[h] > a) {
                        a = f[h];
                        g = h
                    }
                }
            }
            var p = f[m];
            f[m] = f[g];
            f[g] = p;
            p = k[m];
            k[m] = k[g];
            k[g] = p
        }
        for (var m = 0; m < this.dataSeries.length; m++) {
            var e = this.dataSeries[m];
            var l = e.points;
            var o = [];
            e.points = o;
            for (var h = 0; h < l.length; h++) {
                var t = k[h];
                var d = l[t];
                d.categoryIndex = h;
                o.push(d)
            }
        }
        if (this.xAxisGlyph && this.xAxisGlyph.categoryLabelList) {
            var q = this.xAxisGlyph.categoryLabelList;
            var b = [];
            for (var m = 0; m < q.length;
                 m++) {
                b.push(q[k[m]])
            }
            this.xAxisGlyph.categoryLabelList = b
        }
    }, configTooltipAndLabels: function (a) {
        var b = this.conditionCollection.defaultAttr;
        if (a.label) {
            var c = new FR.Chart.AttrContents(a.label);
            b.addAttr(c)
        }
        if (a.tooltip) {
            this.hotTooltipStyle = new FR.Chart.AttrContents(a.tooltip)
        }
    }, configStyle: function (a) {
        this.plotStyle = FR.pick(a.plotStyle, 0);
        this.plotFillStyle = new FR.Chart.AttrFillStyle(a.color)
    }, installSeriesWithData: function (b, a) {
        this.addSeries2PlotGlyph(b, a);
        this.calculatePercentValue()
    }, installSeriesWithOptionData: function (f, d) {
        this.dataSeries = [];
        if (f && f.category && f.series) {
            var c = f.category;
            var g = f.series;
            for (var h = 0; h < g.length; h++) {
                var e = g[h];
                var b = new FR.Chart[d.dataSeries]();
                b.points = [];
                b.seriesIndex = e.seriesIndex;
                b.seriesName = e.seriesName;
                for (var k = 0, j = c.length; k < j; k++) {
                    var a = new FR.Chart[d.dataPoint]();
                    a.categoryIndex = k;
                    a.categoryName = c[k];
                    a.seriesIndex = e.seriesIndex;
                    a.seriesName = e.seriesName;
                    var l = e.value[k];
                    if (FR.equals(l, "null")) {
                        a.value = 0;
                        a.valueIsNull = true
                    } else {
                        a.value = l
                    }
                    b.points[k] = a
                }
                this.dataSeries[h] = b
            }
        }
    }, configAxisLabels: function () {
    }, configAxisLabelsWithOptionData: function () {
    }, configCondition: function (b) {
        var a = b.conditionConfig || {};
        this.conditionCollection.addAll(a, this.dataSeries)
    }, addSeries2PlotGlyph: function (c, b) {
        this.dataSeries = [];
        for (var d = 0, g = c.getSeriesCount(); d < g; d++) {
            var e = new FR.Chart[b.dataSeries]();
            e.points = [];
            e.seriesIndex = d;
            e.seriesName = c.getSeriesLabel(d);
            for (var h = 0, f = c.getCategoryLabelCount(); h < f; h++) {
                var a = new FR.Chart[b.dataPoint]();
                a.categoryIndex = h;
                a.seriesIndex = d;
                var j = c.getValueAt(d, h);
                if (isNaN(parseFloat(j))) {
                    j = 0;
                    a.valueIsNull = true
                } else {
                    j = parseFloat(j)
                }
                a.value = j;
                a.categoryName = c.getCategoryLabel(h);
                a.seriesName = c.getSeriesLabel(d);
                this.addMoreCate2DataPoint(a, c);
                e.points[h] = a
            }
            this.dataSeries[d] = e
        }
    }, calculatePercentValue: function () {
        for (var c = 0; c < this.getCategoryCount(); c++) {
            var d = 0;
            for (var b = 0; b < this.dataSeries.length; b++) {
                if (this.dataSeries[b].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                    continue
                }
                d += Math.abs(this.dataSeries[b].points[c].value)
            }
            for (var b = 0; b < this.dataSeries.length; b++) {
                var a = this.dataSeries[b].points[c];
                var e = Math.abs(a.value);
                a.percentValue = e / d
            }
        }
    }, refreshDataPointLabel: function () {
        this.calculatePercentValue();
        this.createDataLabel4EverySeries();
        this.createHotTooltip()
    }, createDataLabel4EverySeries: function () {
        for (var c = 0, h = this.dataSeries.length; c < h; c++) {
            var e = this.dataSeries[c];
            for (var l = 0; l < e.getDataPointCount(); l++) {
                var a = e.points[l];
                if (a.valueIsNull) {
                    continue
                }
                var k = this.conditionCollection.getAttr(a);
                var f = k.isContains(new FR.Chart.AttrContents());
                if (!f) {
                    f = this.conditionCollection.defaultAttr.isContains(new FR.Chart.AttrContents());
                    if (!f) {
                        continue
                    }
                }
                var j = f.seriesLabel;
                var g = ",";
                var b = FR.Chart.Separator;
                for (var d = 0; d < b.length; d++) {
                    if (j.indexOf(b[d]) != -1) {
                        g = b[d];
                        break
                    }
                }
                this.createDataLabel4DataPointWithCondition(a, f, g)
            }
        }
    }, createHyperlink: function (h) {
        for (var e = 0; e < h.length; e++) {
            var k = h[e];
            for (var d = 0; d < this.dataSeries.length; d++) {
                var f = this.dataSeries[d];
                for (var j = 0; j < f.points.length; j++) {
                    var b = f.points[j];
                    var g = b.resultParameter(k.parameter);
                    var c = this._substituteContentsWithParameters(k.content, g);
                    switch (k.type) {
                        case FR.Chart.HyperlinkType.JS:
                            b.jsHyperlink.push(c);
                            break;
                        case FR.Chart.HyperlinkType.WEB:
                            var a = true;
                            for (var l in g) {
                                if (a) {
                                    c += "?" + l + "=" + g[l]
                                } else {
                                    c += "&" + l + "=" + g[l]
                                }
                            }
                            b.webHyerlink.push(c);
                            break
                    }
                }
            }
        }
    }, _substituteContentsWithParameters: function (b, c) {
        for (var a in c) {
            b = b.replaceAll(a, c[a])
        }
        return b
    }, createDataLabel4DataPointWithCondition: function (a, c, d) {
        var b = a.getDataPointLabelString(c, d);
        if (a.isCustomLabel && a.dataLabel) {
            b = a.dataLabel.text
        }
        var e = new FR.Chart.TextGlyph();
        e.text = b;
        e.textAttr = c.textAttr;
        a.dataLabel = e;
        if (a.isShowLabel) {
            a.showLabel = b
        }
    }, isNeedTimeSwitchWidget: function () {
        return false
    }, createLegendItems: function () {
        var e = [];
        for (var f = 0; f < this.dataSeries.length; f++) {
            var g = this.dataSeries[f];
            var l = new FR.Chart.LegendItem();
            var a = this.createColors4Series();
            l.label = g.seriesName;
            l.lineMarkerIcon = this.getLegendMarkerIcon(g, a);
            e[f] = l
        }
        if (this.conditionCollection) {
            for (var f = 0; f < this.dataSeries.length; f++) {
                var g = this.dataSeries[f];
                var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrTrendLine(), g);
                if (c) {
                    var h = c.trendLineList;
                    for (var k = 0; k < h.length; k++) {
                        var m = h[k];
                        var b = m.lineStyleInfo;
                        var l = new FR.Chart.LegendItem();
                        var j = new FR.Chart.LineMarkerIcon();
                        l.label = m.trendLineName;
                        l.lineMarkerIcon = j;
                        var d = "black";
                        if (b && b.attrLineColor && b.attrLineColor.seriesColor) {
                            d = b.attrLineColor.seriesColor
                        }
                        j.background = FR.Chart.ColorBackground.getInstance(d);
                        j.lineStyle = FR.Chart.Constants.LINE_THIN;
                        j.marker = new FR.Chart.NullMarker();
                        e.push(l)
                    }
                }
            }
        }
        return e
    }, dealAttr4LegendGlyph: function (a) {
    }, getLegendMarkerIcon: function (b, a) {
        var c = new FR.Chart.LineMarkerIcon();
        this.dealCondition(c, b, a);
        return c
    }, getLegendMarkerIcon4Line: function (b, a) {
        var c = new FR.Chart.LineMarkerIcon();
        this.dealLineCondition(c, b, a);
        return c
    }, dealCondition: function (e, b, a) {
        var d = this.conditionCollection.getConditionAttr(new FR.Chart.AttrAlpha(), b);
        e.alpha = d.alpha;
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrBackground(), b, a);
        e.background = c.seriesBackground
    }, dealLineCondition: function (h, g, d) {
        var e = this.conditionCollection.getConditionAttr(new FR.Chart.AttrColor(), g, d);
        h.background = FR.Chart.ColorBackground.getInstance(e.seriesColor);
        var f = this.conditionCollection.getConditionAttr(new FR.Chart.AttrLineStyle(), g, d);
        h.lineStyle = f.lineStyle;
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrAlpha(), g, d);
        h.alpha = c.alpha;
        var a = this.conditionCollection.getConditionAttr(new FR.Chart.AttrMarkerType(), g, d);
        var b = new FR.Chart[a.markerType]();
        b.size = b.size * 0.8;
        b.background = FR.Chart.ColorBackground.getInstance(e.seriesColor);
        h.marker = b
    }, addMoreCate2DataPoint: function (b, f) {
        var i = f.secondCates;
        if (!i || i.length === 0) {
            return
        }
        var k = b.categoryIndex;
        var a = f.getCategoryLabelCount();
        var d = Math.max(1, i.length);
        var e = f.thirdCates;
        var h = 1;
        if (e && e.length > 0) {
            h = e.length
        }
        var j = a / h;
        var l = j / d;
        var g = k / j;
        var c = (k - g * j) / l;
        if (i && i.length > 0) {
            if (c < i.length && i[c]) {
                b.secondCate = i[c]
            }
        }
        if (e && e.length > 0) {
            if (g < h && e[g]) {
                b.thirdCate = e[g]
            }
        }
    }, setLastGlyph: function (a) {
        this.lastPlotGlyph = a
    }, getLastDataPointGlyph: function (a) {
        var b = a.seriesIndex;
        var c = a.categoryIndex;
        if (this.lastPlotGlyph && this.lastPlotGlyph.dataPointDoExit(b, c)) {
            return this.lastPlotGlyph.dataSeries[b].points[c].glyph
        }
        return a.glyph
    }, getLastSeriesGlyph: function (c) {
        var b = c.seriesIndex;
        if (this.lastPlotGlyph && this.lastPlotGlyph.dataSeries.length > b) {
            var a = this.lastPlotGlyph.dataSeries[b];
            if (a.points.length == c.points.length) {
                a.glyph
            }
        }
        return c.glyph
    }, dataPointDoExit: function (a, b) {
        return this.dataSeries.length > a && this.dataSeries[a].points.length > b
    }, createHotTooltip: function () {
        if (this.hotTooltipStyle && this.hotTooltipStyle.seriesLabel) {
            var b = this.hotTooltipStyle.isShowMutiSeries;
            var d = this.hotTooltipStyle.isWhiteBackground ? "white" : "black";
            var a = [];
            if (this.dataSeries.length === 1) {
                a = this.createColors4Cate()
            } else {
                a = this.createColors4Series()
            }
            if (b) {
                for (var c = 0; c < this.dataSeries.length; c++) {
                    if (this.dataSeries[c]) {
                        this.dataSeries[c].createHotTooltip4Series(this.hotTooltipStyle, this, d, a)
                    }
                }
            } else {
                for (var c = 0; c < this.dataSeries.length; c++) {
                    if (this.dataSeries[c]) {
                        this.dataSeries[c].createHotTooltip(this.hotTooltipStyle, this, d)
                    }
                }
            }
        }
    }, getCategoryCount: function () {
        if (this.dataSeries[0] && this.dataSeries[0].points) {
            return this.dataSeries[0].points.length
        }
        return 0
    }, getSeriesViewCount: function () {
        var b = 0;
        for (var a = 0; this.dataSeries && a < this.dataSeries.length;
             a++) {
            if (this.dataSeries[a] && this.dataSeries[a].paintState >= FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                b++
            }
        }
        return b
    }, getLastSeriesViewIndex: function () {
        var a = -1;
        for (var b = 0; this.dataSeries && b < this.dataSeries.length; b++) {
            if (this.dataSeries[b] && this.dataSeries[b].paintState >= FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                a = b
            }
        }
        return a
    }, getSeriesViewIndex: function (a) {
        var c = 0;
        for (var b = 0; this.dataSeries && b < this.dataSeries.length; b++) {
            if (b == a) {
                return c
            }
            if (this.dataSeries[b] && this.dataSeries[b].paintState >= FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                c++
            }
        }
        return -1
    }, getDrawSequence: function () {
        var a = [];
        for (var b = 0; this.dataSeries && b < this.dataSeries.length; b++) {
            a[b] = b
        }
        return a
    }, getPreGap4AxisTopUnit: function () {
        return 0
    }, getPreGap4AxisRightUnit: function () {
        return 0
    }, getPreLeft4DataSheet: function () {
        return 0
    }, _isShowInScaleChartCate: function (a) {
        var d = a.categoryIndex;
        if (this.xAxisGlyph) {
            var b = this.xAxisGlyph.zoomBackward;
            var c = this.xAxisGlyph.zoomForward;
            return d >= Math.abs(b) && a.categoryIndex < this.getCategoryCount() - Math.abs(c)
        }
        return true
    }, isDataPointXNotInPlotBounds: function (a) {
        if (isNaN(a)) {
            return true
        }
        var b = this.getBounds();
        return (a < b.x - 1 || a > b.x + b.width + 1)
    }, dealLabelBoundsInOrder: function () {
        var d = [];
        for (var e = 0; this.dataSeries && e < this.dataSeries.length; e++) {
            for (var o = 0; o < this.getCategoryCount(); o++) {
                var g = this.dataSeries[e];
                if (g == null || g.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    continue
                }
                var a = g.points[o];
                if (a && a.dataLabel && a.dataLabel.bounds != null) {
                    if (this._isShowInScaleChartCate(a)) {
                        d[d.length] = a
                    } else {
                        a.dataLabel.bounds = null
                    }
                }
            }
        }
        if (d.length <= 0) {
            return
        }
        if (FR.Browser.isIE8Before()) {
            var c = 50;
            if (d.length > c) {
                var b = [];
                var j = parseInt(d.length / c);
                for (var f = 0; f < d.length; f++) {
                    if (f % j === 0) {
                        b[b.length] = d[f]
                    } else {
                        d[f].dataLabel.bounds = null
                    }
                }
                d = b
            }
        }
        var m = this._dealDataPointOrder(d);
        var n = this.getBounds();
        var l = new FR.Chart.BoundsManager();
        for (var k = 0; k < m.length; k++) {
            var a = m[k];
            if (a.dataLabel == null) {
                continue
            }
            var h = a.dataLabel.bounds;
            this.dealLabelBoundsOutPlotBounds(a, h, n, m, k, l)
        }
        for (var k = 0; k < m.length; k++) {
            var a = m[k];
            if (a.dataLabel == null) {
                continue
            }
            var h = a.dataLabel.bounds;
            if (h == null || h.x < this.bounds.x - 3 || h.y < this.bounds.y - 3) {
                a.dataLabel.bounds = null
            }
        }
    }, dealLabelBoundsOutPlotBounds: function (c, e, f, d, b, a) {
        e = this.avoidCoverLabelBounds(a, e);
        if (e == null) {
            c.dataLabel.bounds = null;
            return
        }
        if (f.contains(e.x, e.y, e.width, e.height)) {
            c.dataLabel.bounds = e
        } else {
            while (e.y + e.height > f.y + f.height) {
                e.y = e.y - 1
            }
            this._dealBoundsIntersects(d, b, a, e, 0, -1);
            this._reAddLabelPath(a, d, b);
            while (e.x < f.x) {
                e.x = e.x + 1
            }
            this._dealBoundsIntersects(d, b, a, e, 1, 0);
            this._reAddLabelPath(a, d, b);
            while (e.x + e.width > f.x + f.width) {
                e.x = e.x - 1
            }
            this._dealBoundsIntersects(d, b, a, e, -1, 0);
            this._reAddLabelPath(a, d, b);
            while (e.y < f.y) {
                e.y = e.y + 1
            }
            this._dealBoundsIntersects(d, b, a, e, 0, 1);
            this._reAddLabelPath(a, d, b);
            c.dataLabel.bounds = e
        }
        a.addBounds(e)
    }, _reAddLabelPath: function (a, d, b) {
        a = new FR.Chart.BoundsManager();
        for (var c = 0; c < b; c++) {
            var e = d[c];
            if (e != null && e.dataLabel != null && e.dataLabel.bounds != null) {
                a.addBounds(e.dataLabel.bounds)
            }
        }
    }, _dealBoundsIntersects: function (e, d, t, p, k, n) {
        var l = [];
        if (d <= 0) {
            return
        }
        var o = 1;
        while (t.isInteract(p)) {
            if ((d - o) < 0) {
                break
            }
            var b = e[d - o];
            o++;
            if (o > e.length) {
                break
            }
            if (b == null || b.dataLabel == null || b.dataLabel.bounds == null) {
                continue
            }
            var g = b.dataLabel.bounds;
            var f = false;
            var a = new FR.Chart.BoundsManager();
            a.addBounds(p);
            var m = 1;
            while (m < o - 1) {
                var s = e[d - m];
                m++;
                if (s == null || s.dataLabel == null || s.dataLabel.bounds == null) {
                    continue
                }
                a.addBounds(s.dataLabel.bounds)
            }
            if (g && a.isInteract(g)) {
                f = true
            }
            while (g && a.isInteract(g)) {
                g.x = g.x + k;
                g.y = g.y + n;
                b.dataLabel.bounds = g
            }
            if (f) {
                l[l.length] = b
            }
            t = new FR.Chart.BoundsManager();
            for (var r = 0; r < d; r++) {
                var j = e[r];
                if (j != null && j.dataLabel != null && j.dataLabel.bounds != null) {
                    t.addBounds(j.dataLabel.bounds)
                }
            }
        }
        for (var q = 0;
             q < l.length; q++) {
            var c = l[q];
            var h = c.dataLabel.bounds;
            for (var i = 0; i < e.length; i++) {
                if (c && e[i] && e[i].categoryIndex == c.categoryIndex && c.seriesIndex == e[i].seriesIndex) {
                    this._dealBoundsIntersects(e, i, t, h, k, n)
                }
            }
        }
    }, _dealDataPointOrder: function (c) {
        var b = [];
        var e = c.length;
        for (var g = 0; g < e && c.length >= 1; g++) {
            var h = c[0];
            for (var f = 0; f < c.length; f++) {
                var a = c[f];
                if (a.dataLabel == null || a.dataLabel.bounds == null) {
                    continue
                }
                var j = a.dataLabel.bounds;
                if (h.dataLabel == null || h.dataLabel.bounds == null) {
                    continue
                }
                var o = h.dataLabel.bounds;
                var m = o.x;
                var l = o.y;
                var q = j.x;
                var p = j.y;
                if (l < p) {
                } else {
                    if (p < l) {
                        h = a
                    } else {
                        if (l == p) {
                            if (m > q) {
                                h = a
                            }
                        }
                    }
                }
            }
            c.remove(h);
            for (var d = 0; d < c.length; d++) {
                var r = c[d];
                if (r.categoyrIndex == h.categoryIndex && r.seriesIndex == h.seriesIndex) {
                    for (tmpIndex = d; tmpIndex < c.length - 1; tmpIndex++) {
                        c[d] = c[d + 1]
                    }
                    c.length = c.length - 1;
                    break
                }
            }
            b[b.length] = h
        }
        return b
    }, avoidCoverLabelBounds: function (k, b) {
        if (b == null) {
            return null
        }
        var m = b.x;
        var j = b.y;
        var d = b.width;
        var o = b.height;
        var f = new FR.Chart.Bounds(m, j, 1, 1);
        var i = new FR.Chart.Bounds(m + d - 1, j, 1, 1);
        var l = new FR.Chart.Bounds(m, j + o - 1, 1, 1);
        var e = new FR.Chart.Bounds(m + d - 1, j + o - 1, 1, 1);
        var h = k.isInteract(f);
        var c = k.isInteract(i);
        var g = k.isInteract(l);
        var n = k.isInteract(e);
        if (!h && !c && !g && !n) {
            if (k.isInteract(b)) {
                this.whileTmp(k, b, 0, 1, o)
            } else {
                var a = new FR.Chart.Bounds(b.x, b.y, b.width + 2, b.height);
                return a
            }
        } else {
            if (!h && c && g && n) {
                this.whileTmp(k, b, -1, -1, d)
            } else {
                if (h && !c && g && n) {
                    this.whileTmp(k, b, 1, -1, d)
                } else {
                    if (h && c && !g && n) {
                        this.whileTmp(k, b, -1, 1, d)
                    } else {
                        if (h && c && g && !n) {
                            this.whileTmp(k, b, 1, 1, d)
                        } else {
                            if (!h && !c && g && n) {
                                this.whileTmp(k, b, 0, -1, o)
                            } else {
                                if (h && !c && g && !n) {
                                    this.whileTmp(k, b, 1, 0, d)
                                } else {
                                    if (h && c && g && n || h && c && !g && !n) {
                                        this.whileTmp(k, b, 0, 1, o)
                                    } else {
                                        if (!h && c && !g && n) {
                                            this.whileTmp(k, b, -1, 0, d)
                                        } else {
                                            if (h && !c && !g && !n) {
                                                this.whileTmp(k, b, 1, 0, d);
                                                if (k.isInteract(b)) {
                                                    b = new FR.Chart.Bounds(m, j, d, o)
                                                }
                                                this.whileTmp(k, b, 0, 1, o);
                                                if (k.isInteract(b)) {
                                                    b = new FR.Chart.Bounds(m, j, d, o)
                                                }
                                                this.whileTmp(k, b, 1, 1, d)
                                            } else {
                                                if (!h && c && !g && !n) {
                                                    this.whileTmp(k, b, -1, 0, d);
                                                    if (k.isInteract(b)) {
                                                        b = new FR.Chart.Bounds(m, j, d, o)
                                                    }
                                                    this.whileTmp(k, b, 0, 1, o);
                                                    if (k.isInteract(b)) {
                                                        b = new FR.Chart.Bounds(m, j, d, o)
                                                    }
                                                    this.whileTmp(k, b, -1, 1, d)
                                                } else {
                                                    if (!h && !c && g && !n) {
                                                        this.whileTmp(k, b, 0, -1, o);
                                                        if (k.isInteract(b)) {
                                                            b = new FR.Chart.Bounds(m, j, d, o)
                                                        }
                                                        this.whileTmp(k, b, 1, 0, d);
                                                        if (k.isInteract(b)) {
                                                            b = new FR.Chart.Bounds(m, j, d, o)
                                                        }
                                                        this.whileTmp(k, b, 1, -1, d)
                                                    } else {
                                                        if (!h && !c && !g && n) {
                                                            this.whileTmp(k, b, -1, 0, d);
                                                            if (k.isInteract(b)) {
                                                                b = new FR.Chart.Bounds(m, j, d, o)
                                                            }
                                                            this.whileTmp(k, b, 0, -1, o);
                                                            if (k.isInteract(b)) {
                                                                b = new FR.Chart.Bounds(m, j, d, o)
                                                            }
                                                            this.whileTmp(k, b, -1, -1, d)
                                                        } else {
                                                            if (h && !c && !g && n) {
                                                                this.whileTmp(k, b, -1, 1, d);
                                                                if (k.isInteract(b)) {
                                                                    b = new FR.Chart.Bounds(m, j, d, o)
                                                                }
                                                                this.whileTmp(k, b, 1, -1, d)
                                                            } else {
                                                                if (!h && c && g && !n) {
                                                                    this.whileTmp(k, b, -1, -1, d);
                                                                    if (k.isInteract(b)) {
                                                                        b = new FR.Chart.Bounds(m, j, d, o)
                                                                    }
                                                                    this.whileTmp(k, b, 1, 1, d)
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        if (!k.isInteract(b)) {
            var a = new FR.Chart.Bounds(b.x, b.y, b.width + 2, b.height);
            return a
        }
        return null
    }, whileTmp: function (c, e, b, f, a) {
        var d = 0;
        while (c.isInteract(e)) {
            e.x = e.x + b;
            e.y = e.y + f;
            d += 1;
            if (d > a) {
                break
            }
        }
    }, dealPlotBounds4JSDraw: function (a) {
        a.x = parseInt(a.x) - 0.5;
        a.y = parseInt(a.y) - 0.5;
        a.width = Math.round(a.width + 1);
        a.height = Math.round(a.height + 1)
    }, getAnimateStepNumber: function () {
        var a = 0;
        while (this.dataSeries[a] && !(this.dataSeries[a].getAnimateStepNumber() > 0 && this.dataSeries[a].paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE)) {
            a++
        }
        if (this.dataSeries[a]) {
            return this.dataSeries[a].getAnimateStepNumber()
        } else {
            return -1
        }
    }, createColors4Series: function () {
        return FR.Chart.ChartUtils.createFillColorArray(this.plotFillStyle, this.dataSeries.length)
    }, createColors4Cate: function () {
        return FR.Chart.ChartUtils.createFillColorArray(this.plotFillStyle, this.getCategoryCount())
    }, draw: function (c, h, e) {
        this.actionModel = e;
        for (var d = 0, a = this.dataSeries.length; d < a; d++) {
            var b = 6;
            if (!FR.Browser.isIE() || FR.Chart.ChartUtils.isIE9Later()) {
                if (e) {
                    b = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[e];
                    h = FR.Chart.ChartPaintConstants.ACTION_TIME[e]
                }
            }
            if (this.dataSeries[d].trendLineList) {
                for (var g = 0; g < this.dataSeries[d].trendLineList.length; g++) {
                    this.dataSeries[d].trendLineList[g].width = this.getBounds().width;
                    this.dataSeries[d].trendLineList[g].height = this.getBounds().height
                }
            }
            this.dataSeries[d].getAnimateGlyph(b, e)
        }
        if (this.arc3DStyleBase) {
            this.arc3DStyleBase.paintStyle(c[1]);
            this.arc3DStyleBase = null
        }
        if (this.arcOuterBase) {
            this.arcOuterBase.paintStyle(c[1]);
            this.arcOuterBase = null
        }
        var f = this.getAnimateStepNumber();
        if (f > 0) {
            this.animateGlyphDraw(c[2], h, f)
        } else {
            this.animateGlyphDraw(c[2], 1, 1)
        }
    }, setCombieGlyphCtx: function (a) {
        this.combineGlyphCtx = a
    }, drawCombineGlyph: function () {
    }, isSupportTwoStepDraw: function () {
        return false
    }, animateGlyphDraw: function (k, b, h) {
        if (this.lastPlotGlyph && this.isSupportTwoStepDraw()) {
            var g = this.lastPlotGlyph;
            var e = 0;
            var a = this.lastPlotGlyph.dataSeries;
            var j = this;
            for (var f = 0; f < a.length; f++) {
                var d = a[f];
                d.paintState = FR.Chart.ChartPaintConstants.STATE_DISAPPEAR;
                d.getAnimateGlyph(h, FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE)
            }

            function i() {
                if (!k) {
                    return
                }
                k.save();
                g._saveClip4SeriesDrawThrowOutOfPlot(k, g);
                g.doAnimate4SeriesDraw(k, g, e);
                e++;
                k.restore();
                if (e <= h - 1) {
                    c(i)
                } else {
                    j.animateGlyphDrawCurrent(k, b, h)
                }
            }

            var c = window.requrestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (l) {
                setTimeout(l, b / h)
            };
            c(i)
        } else {
            this.animateGlyphDrawCurrent(k, b, h)
        }
    }, animateGlyphDrawCurrent: function (c, g, b) {
        var f = this;
        var e = 0;
        var a = FR.Chart.currentDivKey;

        function h() {
            if (!c) {
                return
            }
            c.save();
            f._saveClip4SeriesDrawThrowOutOfPlot(c, f);
            f.doAnimate4SeriesDraw(c, f, e);
            e++;
            if (e > b - 1) {
                f.drawMarkersLabelAfterSeriesAnimateDraw(c, a);
                f.drawCombineGlyph(g);
                FR.Chart.GraphHelper.isDrawingEnd = true
            }
            c.restore();
            if (e <= b - 1) {
                FR.Chart.GraphHelper.isDrawingEnd = false;
                d(h)
            }
        }

        var d = window.requrestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function (i) {
            setTimeout(i, g / b)
        };
        d(h)
    }, _saveClip4SeriesDrawThrowOutOfPlot: function (a, f) {
        a.clearRect(0, 0, a.canvas.width, a.canvas.height);
        var e = f.bounds;
        var h = FR.Browser.r.webkit ? 1 : 0;
        var g = (0 < e.width ? -h : e.width - h) + e.x;
        var d = (0 < e.height ? -h : e.height - h) + e.y;
        var c = Math.abs(e.width) + h * 2;
        var b = Math.abs(e.height) + h * 2;
        a.beginPath();
        a.moveTo(g, d);
        a.lineTo(g, d + b);
        a.lineTo(g + c, d + b);
        a.lineTo(g + c, d);
        a.closePath();
        a.clip()
    }, doAnimate4SeriesDraw: function (a, e, d) {
        var b = e.getDrawSequence();
        for (var c = 0; c < e.dataSeries.length; c++) {
            e.dataSeries[b[c]].drawAnimateGlyph(a, d);
            if (e.dataSeries[b[c]].drawAnimateGlyph4TopFoldLine) {
                e.dataSeries[b[c]].drawAnimateGlyph4TopFoldLine(a, d)
            }
        }
        for (var c = e.dataSeries.length - 1; c >= 0; c--) {
            e.dataSeries[c].drawAnimateGlyph4TrendLine(a, d)
        }
    }, drawBar3DStackSeries: function (o, a, l, h) {
        var m = a.getCategoryCount();
        var e = h.length;
        for (var g = 0; g < m; g++) {
            var c = [];
            for (var d = 0; d < e; d++) {
                var f = h[d];
                if (f != null && (f.paintState <= FR.Chart.ChartPaintConstants.STATE_ENABLE || f.paintState <= FR.Chart.ChartPaintConstants.STATE_APPEAR)) {
                    c[d] = f.points[g]
                }
            }
            for (var d = 0; d < e;
                 d++) {
                for (var b = e - 1; b > d; b--) {
                    if (c[b] != null && !c[b].valueIsNull && c[b].valueByUnit < 0) {
                        var n = c[b];
                        c[b] = c[b - 1];
                        c[b - 1] = n
                    }
                }
            }
            for (var d = 0; d < e; d++) {
                if (c[d] != null) {
                    c[d].drawAnimateGlyph(o, l);
                    if (c[d].dataPointStyle && c[d].dataPointStyle.paintHighLight) {
                        c[d].dataPointStyle.paintHighLight(o)
                    }
                }
            }
        }
    }, draw4Demo: function (b) {
        for (var c = 0, a = this.dataSeries.length; c < a; c++) {
            this.dataSeries[c].draw4Demo(b)
        }
    }, refreshAxisGlyph: function () {
    }, getMaxValueFromData: function () {
        var e = 0;
        for (var c = 0, a = this.getCategoryCount(); c < a; c++) {
            for (var b = 0;
                 b < this.dataSeries.length; b++) {
                if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    continue
                }
                var d = this.dataSeries[b].points[c];
                if (!d.valueIsNull) {
                    e = (d.value > e) ? d.value : e
                }
            }
        }
        if (e == this.getMinValueFromData(false)) {
            return e + 10
        }
        return e
    }, getMinValueFromData: function (b) {
        var f = 0;
        if (b) {
            f = Number.MAX_VALUE
        }
        for (var d = 0, a = this.getCategoryCount(); d < a; d++) {
            for (var c = 0; c < this.dataSeries.length; c++) {
                if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    continue
                }
                var e = this.dataSeries[c].points[d];
                if (!e.valueIsNull) {
                    if (b) {
                        f = (e.value < f && e.value < 1 && e.value > 0) ? e.value : f
                    } else {
                        f = (e.value < f) ? e.value : f
                    }
                }
            }
        }
        if (f == Number.MAX_VALUE) {
            return 1
        }
        return f
    }, isLegendInteractive: function () {
        if (this instanceof FR.Chart.StockPlotGlyph) {
            return false
        }
        if (this instanceof FR.Chart.MeterPlotGlyph) {
            return false
        }
        if (this instanceof FR.Chart.GanttPlotGlyph) {
            return false
        }
        if (this instanceof FR.Chart.GisMapPlotGlyph) {
            return false
        }
        return true
    }, getHyperMenuWithPosition: function (h, d) {
        var a = this.getBounds();
        if (h.y < a.y || h.x > a.x + a.width) {
            return
        }
        var j = this.getMenuItemsInBounds(h);
        var k = [];
        for (var c = 0; c < j.length; c++) {
            var e = j[c];
            if (e.length > 1) {
                for (var f = 0; f < e.length; e++) {
                    var b = this._createHyperItemMenu(e[f], d);
                    if (b.src) {
                        k[k.length] = b
                    }
                }
            } else {
                var b = this._createHyperItemMenu(e[0], d);
                if (b.src) {
                    k[k.length] = b
                }
            }
        }
        var g = {};
        g.src = "showMenu";
        g.items = k;
        return g
    }, getMenuItemsInBounds: function (i) {
        var j = [];
        var c = 5;
        var b = new FR.Chart.Bounds(i.x - c, i.y - c, c * 2, c * 2);
        for (var h = 0; h < this.getCategoryCount(); h++) {
            var f = [];
            for (var d = 0; d < this.dataSeries.length; d++) {
                var e = this.dataSeries[d];
                var a = e.points[h];
                if (a && a.hyperlink && a.glyph && a.glyph.getShape()) {
                    var g = a.glyph.getShape();
                    if (g && (this._dealEveryPointInBounds(g, b) || g.containsPoint(i.x, i.y))) {
                        f[f.length] = a
                    }
                }
            }
            if (f.length > 0) {
                j[j.length] = f
            }
        }
        return j
    }, _dealEveryPointInBounds: function (c, b) {
        if (c && b) {
            var f = b.width || 0;
            var a = b.height || 0;
            for (var d = b.x; d < b.x + f; d++) {
                for (var e = b.y; e < b.y + a; e++) {
                    if (c.containsPoint(d, e)) {
                        return true
                    }
                }
            }
        }
        return false
    }, _createHyperItemMenu: function (a, e) {
        var c = {};
        c.src = a.categoryName + " " + a.seriesName;
        if (a.glyph) {
            var d = a.glyph;
            if (d.info && d.info.seriesAttrBackground.seriesBackground) {
                c.color = d.info.seriesAttrBackground.seriesBackground.color
            } else {
                if (d.lineStyleInfo && d.lineStyleInfo.attrLineColor.seriesColor) {
                    c.color = d.lineStyleInfo.attrLineColor.seriesColor
                } else {
                    c.color = "gray"
                }
            }
        }
        c.dataPoint = a;
        if (a.nameLayerTo && a.hasNextTo) {
            c.chartEvent = e
        } else {
            if (a.hyperlink) {
                var f = new Function("return " + a.hyperlink)();
                var b = this._createItems4Menu(f);
                if (b.length === 1) {
                    c.handler = b[0].handler
                } else {
                    c.submenu = b
                }
            }
        }
        return c
    }, _createItems4Menu: function (b) {
        return $.map(b, function a(c) {
            return {src: c.name, handler: new Function(unescape(c.data))}
        })
    }, findClickOnGlyph: function (a, b) {
        this.findOnMoveGlyph(a, b)
    }, _findSeriesGlyphPoint: function (f, k, d) {
        var g = f.glyph ? f.glyph.getShape().getInteractivePath() : null;
        if (g && g.containsPoint(k.x, k.y)) {
            var i = Number.MAX_VALUE;
            var b;
            for (var e = 0; e < f.points.length && !d._hasfound; e++) {
                var h = f.points[e];
                if (h.glyph && h.glyph.getBounds2D) {
                    var a = h.glyph.getBounds2D();
                    if (a.containsPoint(k.x, k.y)) {
                        d._hasfound = true;
                        d._lastHover = h;
                        break
                    }
                    var c = this._getDistance(k, a);
                    if (c < i) {
                        b = h;
                        i = c
                    }
                }
            }
            if (b && !d._hasfound) {
                d._hasfound = true;
                d._lastHover = b
            }
        }
    }, _findNearByDataPoint: function (k, c) {
        var h = Number.MAX_VALUE;
        for (var e = 0; e < this.dataSeries.length && !c._hasfound; e++) {
            var f = this.dataSeries[e];
            if (f.paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                continue
            }
            this._findSeriesGlyphPoint(f, k, c);
            var a;
            for (var d = 0; d < f.points.length && !c._hasfound; d++) {
                var g = f.points[d];
                if (g && g.glyph && g.glyph.shape) {
                    if (g.glyph.shape && g.glyph.shape.containsPoint) {
                        if (g.glyph.shape.containsPoint(k.x, k.y)) {
                            c._hasfound = true;
                            c._lastHover = g;
                            break
                        }
                    }
                    var b = this._getDistance(k, g.glyph.shape);
                    if (b < h) {
                        a = g;
                        h = b
                    }
                }
            }
        }
        if (a && !c._hasfound) {
            c._hasfound = true;
            c._lastHover = a
        }
    }, _getDistance: function (a, b) {
        if (this.isHorizontal) {
            if (b.getMiddleY) {
                var c = b.getMiddleY();
                return Math.abs(c - a.y)
            }
        } else {
            if (b.getMiddleX) {
                var d = b.getMiddleX();
                return Math.abs(d - a.x)
            }
        }
        return Number.MAX_VALUE
    }, findOnMoveGlyph: function (a, f, c) {
        var e = this.getBounds();
        if (e == null || !e.containsPoint(a.x, a.y)) {
            return
        }
        if (this.xAxisGlyph) {
            this.xAxisGlyph.findOnMoveGlyph(a, f, c)
        }
        if (this.yAxisGlyph) {
            this.yAxisGlyph.findOnMoveGlyph(a, f, c)
        }
        if (this.secondAxisGlyph) {
            this.secondAxisGlyph.findOnMoveGlyph(a, f, c)
        }
        if (f._hasfound || !this.dataSeries || this.dataSeries.length <= 0) {
            return
        }
        if (a.y < e.y || a.x < e.x || a.x > e.x + e.width || a.y > e.y + e.height) {
            return
        }
        var b = this.getDrawSequence();
        for (var d = this.dataSeries.length - 1; d >= 0 && d < this.dataSeries.length; d += -1) {
            this.dataSeries[b[d]].findOnMoveGlyph(a, f, c);
            if (f._hasfound) {
                return
            }
        }
    }, doOnMove: function (b, a) {
        this.doAxisTooltip(b, a);
        this.doTrendLineTooltip(b, a);
        this.doNullDataTootip(b, a)
    }, doAxisTooltip: function (b, a) {
        if (this.interactiveAxisTooltip && this.getBounds().containsPoint(a.x, a.y)) {
            var d = [];
            $.each([this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph], function (e, i) {
                if (i) {
                    var g = i.getPointValue(a);
                    var j = "";
                    var h = i.format;
                    if (i instanceof FR.Chart.DateAxisGlyph) {
                        j = FR.contentFormat(FR.Chart.ChartUtils.int2Date(g, i.mainType), FR.Chart.ChartUtils.accDateFormat(i.mainType, i.tickLength)) + ""
                    } else {
                        if (i instanceof FR.Chart.NumberAxisGlyph || i.markAxisType == "valueaxis" || i instanceof FR.Chart.ValueAxisGlyph) {
                            h = FR.Chart.ChartUtils.accFormat(h);
                            j = FR.contentFormat(g, h) + ""
                        } else {
                            if (this instanceof FR.Chart.GanttPlotGlyph && this.yAxisGlyph == i) {
                                j = this.yAxisGlyph.categoryLabelList[i.getCategoryCount() - parseInt(g) - 1]
                            } else {
                                if (i.categoryLabelList && parseInt(g) < i.categoryLabelList.length) {
                                    j = i.categoryLabelList[parseInt(g)]
                                }
                            }
                        }
                    }
                    var f = new FR.Chart.TooltipString();
                    f.value = j;
                    d[d.length] = {
                        point: i.getPoint2D(g),
                        tooltips: [f],
                        pos: i.position,
                        x: i.getBounds().x,
                        y: i.getBounds().y,
                        gridLine: i.getGridLine(g)[0]
                    }
                }
            });
            if (d && d.length > 0) {
                if (!b) {
                    return
                }
                b.save();
                b.strokeStyle = "rgb(128,128,128)";
                for (var c = 0; c < d.length; c++) {
                    d[c].gridLine.draw(b, FR.Chart.Constants.LINE_DOT);
                    FR.Chart.Tooltip.drawAxisTooltip(b, d[c])
                }
                b.restore()
            }
        }
    }, doTrendLineTooltip: function (b, a) {
        if (!this.interactiveAxisTooltip) {
            return
        }
        var d = [];
        if (this.getBounds().containsPoint(a.x, a.y)) {
            for (var c = 0; c < this.dataSeries.length; c++) {
                this.dataSeries[c].doTrendLineTooltip(a, d)
            }
        }
        FR.Chart.Tooltip.doTrendLineTooltip(b, d, this.getBounds())
    }, doNullDataTootip: function (b, a) {
        if (!this.errorDataTip) {
            return
        }
        var c = new FR.Chart.ColorBackground();
        c.color = "red";
        FR.Chart.Tooltip.dataPointTip(b, this.errorDataTip, a, c)
    }, drawInfo: function (a) {
        this.info.paint(a[0], this.getOutline4Fill())
    }, trendLineFitting: function (g, d, e, a) {
        e.trendLineList = [];
        var f = this.conditionCollection.getConditionAttr(new FR.Chart.AttrTrendLine(), e.seriesIndex);
        if (f && f.trendLineList) {
            for (var c = 0; c < f.trendLineList.length; c++) {
                var b = f.trendLineList[c].createTrendLineGlyph();
                b.fitting(g, d);
                b.drawShape(this.bounds.clone());
                if (a instanceof FR.Chart.ValueAxisGlyph) {
                    b.valueAxisGlyph = a
                }
                e.trendLineList[c] = b
            }
        }
    }, stopDataPointLabel: function () {
        for (var b = 0, a = this.dataSeries.length; b < a; b++) {
            this.dataSeries[b].shouldDrawLable = false
        }
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (c, b) {
        for (var d = 0, a = this.dataSeries.length; d < a; d++) {
            if (this.dataSeries[d].paintState == FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
                this.dataSeries[d].paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE
            }
            if (this.dataSeries[d].paintState == FR.Chart.ChartPaintConstants.STATE_APPEAR) {
                this.dataSeries[d].paintState = FR.Chart.ChartPaintConstants.STATE_ENABLE
            }
            if (this.dataSeries[d].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            this.dataSeries[d].drawLabel(c, b)
        }
        for (var d = 0, a = this.dataSeries.length; d < a; d++) {
            if (this.dataSeries[d] && this.dataSeries[d].dataSeriesStyle) {
                if (this.dataSeries[d].paintState == FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                    this.dataSeries[d].dataSeriesStyle.paintStyle(c);
                    break
                }
            }
        }
    }, drawAfterAnimate4LineMarker: function (c, b) {
        for (var e = 0, a = this.dataSeries.length; e < a; e++) {
            if (this.dataSeries[e].paintState == FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
                this.dataSeries[e].paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE
            }
            if (this.dataSeries[e].paintState == FR.Chart.ChartPaintConstants.STATE_APPEAR) {
                this.dataSeries[e].paintState = FR.Chart.ChartPaintConstants.STATE_ENABLE
            }
            if (this.dataSeries[e].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || this.dataSeries[e].paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
                continue
            }
            this.dataSeries[e].drawLabel(c, b);
            var f = this.dataSeries[e].points;
            for (var d = 0; d < f.length; d++) {
                f[d].draw(c, b)
            }
        }
    }, dealDataPointLabel: function (b) {
        var a = b.dataLabel;
        if (!a) {
            return
        }
        if (this.notDealDataPointLabel(b, a)) {
            a.bounds = null
        } else {
            var g = a.preferredDimension();
            var f = b.getShape().getBounds2D();
            var e = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), b);
            var c = b.value < 0;
            var d = this.getDataPointLabelBoundsWithPosition(g, f, e.position, c);
            a.bounds = d
        }
    }, notDealDataPointLabel: function (b, a) {
        return (!a || !a.text || b.getShape() == null || b.getShape().getBounds2D() == null)
    }, getDataPointLabelBoundsWithPosition: function (c, b, a) {
        return null
    }, getDataPointLabelBoundsWithPosition4Line: function (f, e, a) {
        var d = 2;
        var c = e.x + (e.width - f.width) / 2;
        var b = e.y - f.height - d;
        return new FR.Chart.Bounds(c, b, f.width, f.height)
    }, returnBackToLayer: function () {
    }, layerToDataPointNext: function (a, b) {
    }, onDragStart: function (e, d) {
        var c;
        if (d.glyph) {
            c = d.glyph.getAlpha();
            if (d instanceof FR.Chart.DataSeries4Area) {
                d.glyph.setAlpha(0.2)
            } else {
                d.glyph.setAlpha(0.5)
            }
            d.glyph.draw(e, 1000, FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL);
            d.glyph.setAlpha(c)
        }
        var g = d.points;
        var h = 0;
        var f = d.getDataPointCount();
        if (this.xAxisGlyph && this.xAxisGlyph.isZoom) {
            h = this.xAxisGlyph.getCrossValue();
            f = this.xAxisGlyph.getArrowValue()
        }
        for (var b = h; b < f; b++) {
            var a = g[b];
            if (a && a.glyph) {
                c = a.glyph.getAlpha();
                a.glyph.setAlpha(0.5);
                a.draw(e, 1000);
                a.glyph.setAlpha(c)
            }
        }
    }, onSeriesDrag: function (b, m, c, o) {
        var l = 0;
        var g = o.getDataPointCount();
        if (this.xAxisGlyph && this.xAxisGlyph.isZoom) {
            l = this.xAxisGlyph.getCrossValue();
            g = this.xAxisGlyph.getArrowValue()
        }
        var d = this._combineSeriesIndex(m, o);
        if (d !== -1) {
            var f = this.dataSeries[d];
            if (f.glyph) {
                FR.Chart.HighUtils.doSeriesDragBorder(f.glyph, c)
            }
            var k = f.points;
            for (var e = l; e < g; e++) {
                var a = k[e];
                if (a != null && a.glyph) {
                    FR.Chart.HighUtils.doSeriesDragBorder(a.glyph, c)
                }
            }
        }
        var n = m.x - b.x;
        var j = m.y - b.y;
        c.translate(n, j);
        var h;
        if (o.glyph) {
            h = o.glyph.getAlpha();
            if (o instanceof FR.Chart.DataSeries4Area) {
                o.glyph.setAlpha(0.2)
            } else {
                o.glyph.setAlpha(0.5)
            }
            o.glyph.draw(c, 1000, FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL);
            o.glyph.setAlpha(h)
        }
        var k = o.points;
        for (var e = l;
             e < g; e++) {
            var a = k[e];
            if (a && a.glyph) {
                h = a.glyph.getAlpha();
                a.glyph.setAlpha(0.5);
                a.draw(c, 1000);
                a.glyph.setAlpha(h)
            }
        }
        c.translate(-n, -j)
    }, onSeriesDragEnd: function (d, c, a, e) {
        var b = this._combineSeriesIndex(a, d);
        if (b !== -1) {
            this.dataSeries[b].addDataSeries(d);
            d.paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE;
            d.lastState = FR.Chart.ChartPaintConstants.STATE_TRANSPARENT;
            this.refreshDataPointLabel();
            e.needRefresh = true
        } else {
            if (!this.bounds.containsPoint(a.x, a.y)) {
                d.paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE;
                d.lastState = FR.Chart.ChartPaintConstants.STATE_TRANSPARENT;
                this.refreshDataPointLabel();
                e.needRefresh = true
            } else {
                d.paintState = FR.Chart.ChartPaintConstants.STATE_ENABLE
            }
        }
    }, onDragMouseOut: function (a) {
        a.paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE;
        a.lastState = FR.Chart.ChartPaintConstants.STATE_TRANSPARENT
    }, isSupportZoom: function () {
        return false
    }, setZoom: function (a) {
        return false
    }, _combineSeriesIndex: function (a, g) {
        var f = -1;
        for (var c = 0; c < this.dataSeries.length; c++) {
            var e = this.dataSeries[c];
            if (e.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT || e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var d = 0; d < e.points.length; d++) {
                var b = e.points[d].getShape();
                if (b && b.containsPoint(a.x, a.y)) {
                    f = c;
                    break
                }
            }
            if (e.glyph && f == -1) {
                if (e.glyph.getShape().containsPoint(a.x, a.y)) {
                    f = c;
                    break
                }
            }
        }
        return f
    }, hasNextLayer: function () {
        return false
    }, setCurrentOffset: function (a, b) {
    }, setTotalOffset: function () {
    }
});
FR.Chart.RectanglePlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (b) {
        b = b || {};
        this.horizontalIntervalBackgroundColor = b.horizontalIntervalBackgroundColor;
        this.verticalIntervalBackgroundColor = b.verticalIntervalBackgroundColor;
        this.interactiveAxisTooltip = b.interactiveAxisTooltip || false;
        var a = FR.Chart.AxisConfig;
        if (b.xAxis || b.xAxisGlyph) {
            if (b.xAxis) {
                var c = a[b.xAxis.axisType];
                this.xAxisGlyph = new FR.Chart[c](b.xAxis)
            } else {
                if (b.xAxisGlyph) {
                    this.xAxisGlyph = new FR.Chart[b.xAxisGlyphType](b.xAxisGlyph)
                }
            }
        } else {
            this.xAxisGlyph = null
        }
        if (b.yAxis || b.yAxisGlyph) {
            if (b.yAxis) {
                var c = a[b.yAxis.axisType];
                this.yAxisGlyph = new FR.Chart[c](b.yAxis)
            } else {
                if (b.yAxisGlyph) {
                    this.yAxisGlyph = new FR.Chart[b.yAxisGlyphType](b.yAxisGlyph)
                }
            }
        } else {
            this.yAxisGlyph = null
        }
        if (b.secondAxis || b.secondAxisGlyph) {
            if (b.secondAxis) {
                var c = a[b.secondAxis.axisType];
                this.secondAxisGlyph = new FR.Chart[c](b.secondAxis)
            } else {
                if (b.secondAxisGlyph) {
                    this.secondAxisGlyph = new FR.Chart[b.secondAxisGlyphType](b.secondAxisGlyph)
                }
            }
        } else {
            this.secondAxisGlyph = null
        }
        if (this.xAxisGlyph) {
            this.xAxisGlyph.isLabelWrap = this.xAxisGlyph.isLabelWrap && this.isSupportLabelWrap();
            this.xAxisGlyph.isLabelWrap = this.xAxisGlyph.isLabelWrap && this.isSupportLabelWrap();
            this.xAxisGlyph.isLabelWrap = this.xAxisGlyph.isLabelWrap && this.isSupportLabelWrap()
        }
        FR.Chart.RectanglePlotGlyph.superclass.initConstants.apply(this, [b])
    }, onDrag: function (d, b, c) {
        if (!this.bounds.containsPoint(d.x, d.y) || !this.bounds.containsPoint(b.x, b.y)) {
            return
        }
        var h = Math.min(d.x, b.x);
        var f = Math.min(d.y, b.y);
        var e = Math.abs(d.x - b.x);
        var a = Math.abs(d.y - b.y);
        var g = new FR.Chart.Bounds(h, f, e, a);
        c.save();
        c.fillStyle = "rgba(64,194,239, 0.5)";
        c.strokeStyle = "rgba(64,194,239, 1.0)";
        g.paint(c);
        g.draw(c);
        c.restore()
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (b, a) {
        FR.Chart.RectanglePlotGlyph.superclass.drawMarkersLabelAfterSeriesAnimateDraw.apply(this, [b, a]);
        this.drawAlertLinesAfterSeriesAnimateDraw(b)
    }, drawAlertLinesAfterSeriesAnimateDraw: function (a) {
        if (this.xAxisGlyph) {
            this.xAxisGlyph.drawAlertValueLines(a)
        }
        if (this.yAxisGlyph && !this.yAxisGlyph.cubic) {
            this.yAxisGlyph.drawAlertValueLines(a)
        }
        if (this.secondAxisGlyph && !this.secondAxisGlyph.cubic) {
            this.secondAxisGlyph.drawAlertValueLines(a)
        }
    }, isSupportLabelWrap: function () {
        return false
    }, isNeedTimeSwitchWidget: function () {
        return this.xAxisGlyph && this.xAxisGlyph.isNeedTimeSwitch()
    }, layoutDemoGlyph: function () {
        for (var a = 0;
             a < this.dataSeries.length; a++) {
            var b = this.dataSeries[a];
            if (b.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                b.glyph = null;
                continue
            }
            this.dealLine4DemoGlyph(b, this, this.xAxisGlyph, this.getSeriesAxisGlyph(a))
        }
    }, dealLine4DemoGlyph: function (b, d, a, c) {
    }, layoutAxisGlyph: function (a) {
        this.layoutDoubleAxisGlyph(this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph, a)
    }, layoutDoubleAxisGlyph: function (i, g, b) {
        var c = this.getBounds().clone();
        var m = this.getBounds();
        this.initAxisGlyphBoundsAndZeroBounds(i, c);
        this.initAxisGlyphBoundsAndZeroBounds(g, c);
        this.initAxisGlyphBoundsAndZeroBounds(b, c);
        this.dealPlotBoundsWithAxisGlyph(i, m);
        this.dealPlotBoundsWithAxisGlyph(g, m);
        this.dealPlotBoundsWithAxisGlyph(b, m);
        if (!i.isLabelWrap) {
            this.dealPlotBoundsWidthAxisInHorizontal(i, m)
        } else {
            this.dealWithAreaAxisWrap(i, m)
        }
        this.dealPlotBoundsWidthAxisInHorizontal(g, m);
        this.dealPlotBoundsWidthAxisInHorizontal(b, m);
        this.calculateAxisGlyphAttr(i, m);
        if (i.isLabelWrap && !(i instanceof FR.Chart.DateAxisGlyph)) {
            var j = i.dealWithPlotBounds();
            i.calculateBoundsWidthOrientationAndTitle(m, j, new FR.Chart.Dimension2D(0, 0));
            this.calculateAxisGlyphAttr(i, m)
        }
        this.calculateAxisGlyphAttr(g, m);
        this.calculateAxisGlyphAttr(b, m);
        if (b && b.alignZeroValue) {
            var k = g.getPointInBounds(0);
            var d = b.getPointInBounds(0);
            var h = g.position == FR.Chart.Constants.LEFT || g.position == FR.Chart.Constants.RIGHT;
            var l = h ? k.y : k.x;
            var f = h ? d.y : d.x;
            if (l != f) {
                var a = g.getBounds();
                var e = h ? a.height : a.width;
                if (l > e * 0.2 && l < e * 0.8) {
                    this.dealAxisGlyphZeroPoint(b, h, l)
                } else {
                    this.dealAxisGlyphZeroPoint(g, h, (l + f) / 2);
                    this.dealAxisGlyphZeroPoint(b, h, (l + f) / 2)
                }
            }
        }
        this.dealPlotBounds4JSDraw(this.getBounds())
    }, dealWithAreaAxisWrap: function (b, a) {
        if (this instanceof FR.Chart.AreaPlotGlyph || this instanceof FR.Chart.Area3DPlotGlyph) {
            b.dealPlotBounds4AreaWrapInHorizontal(a)
        }
    }, initAxisGlyphBoundsAndZeroBounds: function (a, b) {
        if (a) {
            a.bounds = b.clone();
            a.plotZeroBounds = b.clone()
        }
    }, dealPlotBoundsWithAxisGlyph: function (b, a) {
        if (b) {
            b.dealPlotBoundsWithAxisLabel(a)
        }
    }, dealPlotBoundsWidthAxisInHorizontal: function (b, a) {
        if (b) {
            b.dealPlotBoundsWithLabelInHorizontal(a)
        }
    }, calculateAxisGlyphAttr: function (a, b) {
        if (a) {
            a.calculateAxisGlyph(b)
        }
    }, dealAxisGlyphZeroPoint: function (b, h, c) {
        if (b == null) {
            return
        }
        var a = b.getBounds();
        var f = h ? a.height : a.width;
        var d = b.getPointInBounds(0);
        var i = h ? d.y : d.x;
        var e = 1;
        if (i > c) {
            e = (c - a.y) / (i - a.y);
            var g = b.originPoint;
            g.y = a.y + f * e
        } else {
            if (i < c) {
                e = (f - (c - a.y)) / (f - (i - a.y))
            }
        }
        b.axisLength = f * e;
        b.unitLength = b.unitLength * e
    }, getSeriesAxisGlyph: function (b) {
        var a = this.conditionCollection.getConditionAttr(new FR.Chart.AttrAxisPosition(), b);
        return a.axisPosition == FR.Chart.CustomAttr.Axis_RIGHT ? this.secondAxisGlyph : this.yAxisGlyph
    }, getStartY: function (a) {
        var b = this.yAxisGlyph;
        if (b == null) {
            return 0
        }
        return b.getPoint2D(a.value).y
    }, getPreGap4AxisTopUnit: function () {
        return (this._isAxisShowUnit(this.yAxisGlyph) || this._isAxisShowUnit(this.secondAxisGlyph)) ? FR.Chart.NumberAxisGlyph.UNIT_HEIGHT : 0
    }, _isAxisShowUnit: function (a) {
        return a && (a.showUnit || a.unitPadding)
    }, getPreGap4AxisRightUnit: function () {
        return this._isAxisShowUnit(this.xAxisGlyph) ? FR.Chart.NumberAxisGlyph.UNIT_HEIGHT : 0
    }, getPreLeft4DataSheet: function () {
        var c = (this.xAxisGlyph == null) ? 0 : this.xAxisGlyph.getPreLeftWidth4DataSheet();
        var b = (this.yAxisGlyph == null) ? 0 : this.yAxisGlyph.getPreLeftWidth4DataSheet();
        var a = (this.secondAxisGlyph == null) ? 0 : this.secondAxisGlyph.getPreLeftWidth4DataSheet();
        return c + b + a
    }, draw: function (a, c, b) {
        if (!this.xAxisGlyph.cubic) {
            this.drawInfo(a)
        }
        if (this.xAxisGlyph != null && !this.xAxisGlyph.cubic) {
            this.xAxisGlyph.draw(a[1])
        }
        if (this.yAxisGlyph != null && !this.xAxisGlyph.cubic) {
            this.yAxisGlyph.draw(a[1])
        }
        if (this.secondAxisGlyph != null && !this.secondAxisGlyph.cubic) {
            this.secondAxisGlyph.draw(a[1])
        }
        FR.Chart.RectanglePlotGlyph.superclass.draw.apply(this, [a, c, b])
    }, drawInfo: function (a) {
        this.info.paint(a[0], this.getOutline4Fill());
        if (this.verticalIntervalBackgroundColor != null) {
            var b = new FR.Chart.IntervalColorBackground();
            b.bgColor = this.verticalIntervalBackgroundColor;
            b.position = FR.Chart.Constants.BOTTOM;
            b.intervalLength = this._getIntervalLength(false);
            b.paint(a[1], this.getOutline4Fill())
        }
        if (this.horizontalIntervalBackgroundColor != null) {
            var c = new FR.Chart.IntervalColorBackground();
            c.bgColor = this.horizontalIntervalBackgroundColor;
            c.position = FR.Chart.Constants.LEFT;
            c.intervalLength = this._getIntervalLength(true);
            c.paint(a[1], this.getOutline4Fill())
        }
        this._drawBackgroundGrid(a[1])
    }, _getIntervalLength: function (c) {
        var a = this.xAxisGlyph.unitLength * this.xAxisGlyph.tickLength;
        var b = this.yAxisGlyph.unitLength * this.yAxisGlyph.tickLength;
        if (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP) {
            return c === true ? b : a
        } else {
            return c === true ? a : b
        }
    }, _drawBackgroundGrid: function (a) {
        if (this.yAxisGlyph && this.yAxisGlyph.getBounds()) {
            this.yAxisGlyph.drawAxisGrid(a)
        }
        if (this.xAxisGlyph && this.xAxisGlyph.getBounds()) {
            this.xAxisGlyph.drawAxisGrid(a)
        }
        if (this.secondAxisGlyph && this.secondAxisGlyph.getBounds()) {
            this.secondAxisGlyph.drawAxisGrid(a)
        }
    }, refreshAxisGlyph4XY: function () {
        this.xAxisGlyph.oldMin = this.xAxisGlyph.minValue;
        this.xAxisGlyph.oldMax = this.xAxisGlyph.maxValue;
        this.xAxisGlyph.oldTick = this.xAxisGlyph.tickLength;
        var c = this._getMinValue4XValue(this.xAxisGlyph.isLog);
        var a = this._getMaxValue4XValue();
        var b = (a - c) * this.getMarkerSize() / 500;
        a = a + b;
        c = c - b;
        this.xAxisGlyph.initMinMaxValue(c, a);
        this.yAxisGlyph.oldMin = this.yAxisGlyph.minValue;
        this.yAxisGlyph.oldMax = this.yAxisGlyph.maxValue;
        this.yAxisGlyph.oldTick = this.yAxisGlyph.tickLength;
        c = this.getMinValueFromData(this.yAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_LEFT);
        a = this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_LEFT);
        b = (a - c) * this.getMarkerSize() / 300;
        a = a + b;
        c = c - b;
        this.yAxisGlyph.initMinMaxValue(c, a)
    }, getMarkerSize: function () {
        return 0
    }, _getMinValue4XValue: function (a) {
        var g = 0;
        if (a) {
            g = Number.MAX_VALUE
        }
        for (var c = 0; c < this.dataSeries.length;
             c += 1) {
            var e = this.dataSeries[c];
            if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var d = 0; e && d < e.getDataPointCount(); d++) {
                var b = e.points[d];
                var f = b.x;
                if (a) {
                    if (f > 0 && f < g) {
                        g = f
                    }
                } else {
                    g = g < f ? g : f
                }
            }
        }
        if (a) {
            if (g == Number.MAX_VALUE) {
                g = 1
            }
        }
        return g
    }, _getMaxValue4XValue: function () {
        var e = 0;
        for (var b = 0; b < this.dataSeries.length; b += 1) {
            var d = this.dataSeries[b];
            if (d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var c = 0; d && c < d.getDataPointCount(); c++) {
                var a = d.points[c];
                e = Math.max(e, a.x)
            }
        }
        return e
    }, refreshAxisGlyph: function () {
        this.yAxisGlyph.oldMin = this.yAxisGlyph.minValue;
        this.yAxisGlyph.oldMax = this.yAxisGlyph.maxValue;
        this.yAxisGlyph.oldTick = this.yAxisGlyph.tickLength;
        this.yAxisGlyph.initMinMaxValue(this.getMinValueFromData(this.yAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_LEFT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_LEFT));
        if (this.secondAxisGlyph) {
            this.secondAxisGlyph.oldMin = this.secondAxisGlyph.minValue;
            this.secondAxisGlyph.oldMax = this.secondAxisGlyph.maxValue;
            this.secondAxisGlyph.oldTick = this.secondAxisGlyph.tickLength;
            this.secondAxisGlyph.initMinMaxValue(this.getMinValueFromData(this.secondAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_RIGHT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_RIGHT))
        }
    }
});
FR.Chart.CategoryPlotGlyph = FR.extend(FR.Chart.RectanglePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isStacked = a.isStacked;
        FR.Chart.CategoryPlotGlyph.superclass.initConstants.apply(this, [a])
    }, configAxisLabels: function (a) {
        this.xAxisGlyph.configLabels(a)
    }, configAxisLabelsWithOptionData: function (a) {
        this.xAxisGlyph.configAxisLabelsWithOptionData(a)
    }, getMaxValueFromData: function () {
        var e = 0;
        var g = 0;
        var h = 0;
        var d = this.getCategoryCount();
        if (this.xAxisGlyph.isZoom) {
        }
        if (this.isStacked) {
            for (var c = h; c < d; c++) {
                var f = 0;
                for (var b = 0; b < this.dataSeries.length; b++) {
                    if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        continue
                    }
                    var a = this.dataSeries[b].points[c];
                    if (!a.valueIsNull && a.value >= 0 && this.isInCategoryField(this.xAxisGlyph, a.categoryName)) {
                        f += a.value
                    }
                }
                e = f > e ? f : e;
                if (this.yAxisGlyph.isPercentage) {
                    var k = 0;
                    for (var b = 0; b < this.dataSeries.length;
                         b++) {
                        var a = this.dataSeries[b].points[c];
                        if (!a.valueIsNull && this.isInCategoryField(this.xAxisGlyph, a.categoryName)) {
                            k += Math.abs(a.value)
                        }
                    }
                    g = f / k > g ? f / k : g
                }
            }
            if (this.yAxisGlyph.isPercentage) {
                return g
            }
        } else {
            for (var c = h; c < d; c++) {
                for (var b = 0; b < this.dataSeries.length; b++) {
                    if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        continue
                    }
                    var a = this.dataSeries[b].points[c];
                    if (!a.valueIsNull && this.isInCategoryField(this.xAxisGlyph, a.categoryName)) {
                        e = (a.value > e) ? a.value : e
                    }
                }
            }
        }
        if (this.getMinValueFromData(false) == e) {
            return e + 10
        }
        return e
    }, getMinValueFromData: function (a) {
        var g = 0;
        var h = 0;
        var k = 0;
        var e = this.getCategoryCount();
        if (this.xAxisGlyph.isZoom) {
        }
        if (a) {
            g = Number.MAX_VALUE
        }
        if (this.isStacked) {
            for (var d = k; d < e; d++) {
                var f = 0;
                for (var c = 0; c < this.dataSeries.length; c++) {
                    if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        continue
                    }
                    var b = this.dataSeries[c].points[d];
                    if (!b.valueIsNull && this.isInCategoryField(this.xAxisGlyph, b.categoryName)) {
                        if (b.value <= 0) {
                            f += b.value
                        } else {
                            if (a) {
                                g = (b.value < g) ? b.value : g
                            }
                        }
                    }
                }
                if (!a) {
                    g = f < g ? f : g
                }
                if (this.yAxisGlyph.isPercentage) {
                    var l = 0;
                    for (var c = 0; c < this.dataSeries.length; c++) {
                        if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                            continue
                        }
                        var b = this.dataSeries[c].points[d];
                        if (!b.valueIsNull && this.isInCategoryField(this.xAxisGlyph, b.categoryName)) {
                            l += Math.abs(b.value)
                        }
                    }
                    h = f / l < h ? f / l : h
                }
            }
            if (this.yAxisGlyph.isPercentage) {
                return h
            }
        } else {
            for (var d = k; d < e; d++) {
                for (var c = 0; c < this.dataSeries.length; c++) {
                    if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        continue
                    }
                    var b = this.dataSeries[c].points[d];
                    if (!b.valueIsNull && this.isInCategoryField(this.xAxisGlyph, b.categoryName)) {
                        if (a) {
                            g = (b.value < g && b.value > 0) ? b.value : g
                        } else {
                            g = (b.value < g) ? b.value : g
                        }
                    }
                }
            }
        }
        if (g == Number.MAX_VALUE) {
            return 1
        }
        return g
    }, isInCategoryField: function (f, a) {
        var d = f.minValue;
        var e = f.maxValue;
        if (f.jsType == "DateAxis") {
            var b = FR.Chart.ChartUtils.object2Date(a);
            var c = FR.Chart.ChartUtils.date2Int(b, f.mainType);
            if (!isNaN(c)) {
                if (c < d || c > e) {
                    return false
                }
            }
        }
        return true
    }, isSeriesCurve: function (b) {
        if (b && this.conditionCollection) {
            var a = this.conditionCollection.getConditionAttr(new FR.Chart.AttrCurveLine({isCurve: this.isCurve}), b);
            if (a) {
                return a.isCurve
            }
        }
        return this.isCurve
    }, isSeriesNullValueBreak: function (a) {
        if (a && this.conditionCollection) {
            if (this.conditionCollection.isContainsAttr(a, new FR.Chart.AttrNullValueBreak())) {
                var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrNullValueBreak({isNullValueBreak: this.isNullValueBreak}), a);
                return b.isNullValueBreak
            }
        }
        return this.isNullValueBreak
    }, draw4Demo: function (b) {
        for (var c = 0, a = this.dataSeries.length; c < a; c++) {
            this.dataSeries[c].draw4Demo(b)
        }
    }, getPreSum4Line: function (a, b) {
        return this.getPreSum4Area(a, b)
    }, getPreSum4Area: function (b, d) {
        var a = 0;
        for (var c = b - 1; c >= 0; c--) {
            if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            a += this.getDataPointPercentValue(c, d)
        }
        return a
    }, getPreSum4AreaDataRange: function (e, b, g, k) {
        var l = 0;
        for (var h = e - 1; h >= 0; h--) {
            var f = this.dataSeries[h];
            var j = 0;
            var d = 0;
            if (f.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var m = 0; m < f.getDataPointCount(); m++) {
                var a = f.points[m];
                if (a.valueIsNull) {
                    continue
                }
                var c = k.getDate4Value(m);
                if (FR.Chart.ChartUtils.isBelongToSameUnit(b, c, g)) {
                    j += this.getDataPointPercentValue(h, m);
                    d++
                }
            }
            if (d > 0) {
                l += j / d
            }
        }
        return l
    }, getPreSum4Bar: function (c, g, a) {
        var b = 0;
        var e = 0;
        for (var d = c - 1; d >= 0; d--) {
            if (this.dataSeries[d].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var f = this.getDataPointPercentValue(d, g);
            if (f > 0) {
                b += f
            } else {
                e += f
            }
        }
        if (a) {
            return e
        } else {
            return b
        }
    }, dealLine4DemoGlyph: function (c, p, d, q) {
        var n = [];
        var g = [];
        var e = 0;
        var b = new FR.Chart.GeneralPath();
        var f = new FR.Chart.GeneralPath();
        if (d.axisReversed) {
            b.axisReversed = true;
            f.axisReversed = true
        }
        var k = true;
        for (var m = 0; m < c.getDataPointCount();
             m++) {
            var a = c.points[m];
            if (a.valueIsNull) {
                if (this.isNullValueBreak) {
                    k = true
                }
                continue
            }
            var j = p.getDataPointPercentValue(c.seriesIndex, m);
            var l = d.getPoint2D(d.getTickIndex4Value(m) + d.labelOffset).x;
            if (this.isDataPointXNotInPlotBounds(l)) {
                continue
            }
            var i = q.getPoint2D(j).y;
            n[e] = l;
            g[e] = i;
            e++;
            if (this.isCurve) {
                if (k) {
                    FR.Chart.FoldLine.curveTo(b, f);
                    f.clear();
                    f.moveTo(l, i);
                    b.moveTo(l, i);
                    k = false
                } else {
                    f.lineTo(l, i)
                }
            } else {
                if (k) {
                    b.moveTo(l, i);
                    k = false
                } else {
                    b.lineTo(l, i)
                }
            }
        }
        if (this.isCurve) {
            FR.Chart.FoldLine.curveTo(b, f)
        }
        var h = new FR.Chart.FoldLine(b);
        c.glyph = h;
        h.lineStyleInfo.dealCondition(this.conditionCollection, c, this.createColors4Series());
        if (h.lineStyleInfo.attrLineColor.seriesColor) {
            var o = new FR.Chart.ColorBackground();
            o.color = h.lineStyleInfo.attrLineColor.seriesColor;
            h.toolTipBackground = o
        }
    }, getDataPointPercentValue: function (a, f) {
        var c = this.dataSeries[a].points[f].value;
        if (!this.yAxisGlyph.isPercentage) {
            return c
        }
        var e = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var d = this.dataSeries[b];
            e = e + Math.abs(d.points[f].value)
        }
        if (e === 0) {
            return 0
        }
        return c / e
    }, categoryInBounds: function (a, b) {
        return false
    }, findOnMoveGlyph: function (a, c, b) {
        if (this.xAxisGlyph && this.xAxisGlyph.isZoom && this.bounds.containsPoint(a.x, a.y)) {
            c._lastHover = this;
            c._draggingTarget = c._isMouseDown ? this : null
        }
        FR.Chart.CategoryPlotGlyph.superclass.findOnMoveGlyph.apply(this, [a, c, b])
    }, _findOnMoveGlyph4Line: function (h, b, f) {
        if (this.bounds && !this.bounds.containsPoint(h.x, h.y)) {
            return
        }
        if (this.xAxisGlyph && this.xAxisGlyph.isZoom && this.bounds.containsPoint(h.x, h.y)) {
            b._lastHover = this;
            b._draggingTarget = b._isMouseDown ? this : null
        }
        FR.Chart.CategoryPlotGlyph.superclass.findOnMoveGlyph.apply(this, [h, b, f]);
        var a = this.getBounds();
        if (!b._hasfound && a.containsPoint(h.x, h.y)) {
            this._resetCurrentLineSeries();
            var k = this.dataSeries[this.currentChosenSeriesIndex];
            if (k && k.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                var g = k.points;
                var e = Number.MAX_VALUE;
                var c = 0;
                for (var d = 0; d < g.length; d++) {
                    if (!g[d].glyph || !g[d].glyph.marker) {
                        continue
                    }
                    var j = Math.abs(g[d].glyph.marker.x - h.x);
                    if (e > j) {
                        e = j;
                        c = d
                    }
                }
                g[c].dealTooltip(h, b)
            }
        }
    }, _resetCurrentLineSeries: function () {
        var a = this.currentChosenSeriesIndex;
        var c = this.dataSeries[a];
        if (!c || c.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE && this._isLineSeries(c)) {
            return
        }
        for (var b = 0; b < this.dataSeries.length; b++) {
            if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            if (this._isLineSeries(this.dataSeries[b])) {
                this.currentChosenSeriesIndex = b;
                break
            }
        }
    }, _isLineSeries: function (b) {
        if (b && b.points && b.points[0]) {
            var a = b.points[0];
            return a.glyph && a.glyph.marker
        }
        return false
    }, move4Mobile: function (d, b, c) {
        var h = Math.min(d.x, b.x);
        var f = Math.min(d.y, b.y);
        var e = Math.abs(d.x - b.x);
        var a = Math.abs(d.y - b.y);
        var g = new FR.Chart.Bounds(h, f, e, a);
        c.save();
        c.fillStyle = "rgba(64,194,239, 0.5)";
        c.strokeStyle = "rgba(64,194,239, 1.0)";
        g.paint(c);
        g.draw(c);
        c.restore()
    }, onDragEnd: function (c, j) {
        if (!this.bounds.containsPoint(c.x, c.y) || !this.bounds.containsPoint(j.x, j.y)) {
            return
        }
        var b = Math.min(c.x, j.x);
        var m = Math.min(c.y, j.y);
        var d = Math.abs(c.x - j.x);
        var l = Math.abs(c.y - j.y);
        var g = new FR.Chart.Bounds(b, m, d, l);
        if (this.xAxisGlyph && (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP)) {
            var k = this.getCategoryCount();
            var i = 0;
            for (var e = 0; e < this.dataSeries.length; e++) {
                var f = this.dataSeries[e];
                for (var h = 0; h < this.getCategoryCount(); h++) {
                    var a = f.points[h];
                    if (a.glyph != null && this.categoryInBounds(a, g)) {
                        if (k > f.points.length - 1 || !this.categoryInBounds(f.points[k], g)) {
                            k = h
                        }
                        if (!this.categoryInBounds(f.points[i], g)) {
                            i = h
                        }
                        k = this.xAxisGlyph.getTickIndex4Value(k) < this.xAxisGlyph.getTickIndex4Value(h) ? k : h;
                        i = this.xAxisGlyph.getTickIndex4Value(i) > this.xAxisGlyph.getTickIndex4Value(h) ? i : h
                    }
                }
            }
            if (k < this.getCategoryCount()) {
                this.xAxisGlyph.zoomBackward = this.xAxisGlyph.getOriginalCrossValue() - this.xAxisGlyph.getTickIndex4Value(k);
                this.xAxisGlyph.zoomForward = this.xAxisGlyph.getTickIndex4Value(i) + 1 - this.xAxisGlyph.getOriginalArrowValue()
            }
        }
    }, resetPlotBoundsWith3DDeepAndProjectionBeforeAxisGlyph: function () {
        var c = 0.1;
        this.deepBase = c * this.bounds.height;
        var b = this.get3DDeep();
        var d = this.bounds.height;
        var e = this.bounds.width;
        var a = d - this.projection.projecteeRY(e, d, b);
        var f = this.projection.projecteeRX(e, d, b) - e;
        this.bounds.setRect(this.bounds.x, this.bounds.y + a, e - f, d - a);
        this.threeDBase = new FR.Chart.Cubic(0, 0, this.bounds.width, this.bounds.height);
        this.threeDBase.deep = b;
        this.threeDBase.projection = this.projection;
        this.threeDBase.covers = [FR.Chart.Cubic.BOTTOM];
        this.xAxisGlyph.cubic = this.threeDBase;
        this.yAxisGlyph.cubic = this.threeDBase;
        if (this.secondAxisGlyph) {
            this.secondAxisGlyph.cubic = this.threeDBase
        }
    }, layoutAxisGlyph4ThreeD: function (c, a, e) {
        this.resetPlotBoundsWith3DDeepAndProjectionBeforeAxisGlyph();
        var b = this.getBounds().clone();
        var f = this.getBounds();
        this.initAxisGlyphBoundsAndZeroBounds(c, b);
        this.initAxisGlyphBoundsAndZeroBounds(a, b);
        this.initAxisGlyphBoundsAndZeroBounds(e, b);
        this.dealPlotBoundsWithAxisGlyph(c, f);
        if (a) {
            a.dealPlotBoundsWithAxisTitle(f)
        }
        if (e) {
            a.dealPlotBoundsWithAxisTitle(f)
        }
        this.threeDBase.setCubicWidthHeight(f.width, f.height);
        this.threeDBase.setCubicPosition(f.x, f.y);
        if (a) {
            a.dealPlotBoundsWithLabel(f);
            a.dealPlotBoundsWithAlert(f);
            a.dealPlotBoundsWithLabelInHorizontal(f)
        }
        if (e) {
            e.dealPlotBoundsWithLabel(f);
            e.dealPlotBoundsWithAlert(f);
            e.dealPlotBoundsWithLabelInHorizontal(f)
        }
        var d = !!this.isHorizontal;
        this._dealPlotBoundsBefore(d, f);
        this.calculateAxisGlyphAttr(c, f);
        this.calculateAxisGlyphAttr(a, f);
        this.calculateAxisGlyphAttr(e, f);
        this._dealPlotBoundsAfter(d, f);
        this._adjustValueAxisBounds(a, true, d);
        this._adjustValueAxisBounds(e, false, d);
        this.dealPlotBounds4JSDraw(this.getBounds())
    }, _adjustValueAxisBounds: function (b, d, f) {
        if (!b) {
            return
        }
        var c = this.threeDBase.getPoints();
        var a = b.bounds;
        var e = d ? c[4] : c[5];
        if (f) {
            a.x = e.x;
            a.y = e.y + this.threeDBase.height - a.height;
            b.originPoint = new FR.Chart.Point2D(a.x, a.y);
            b.axisGridLength = this.bounds.height
        } else {
            if (b.position == FR.Chart.Constants.LEFT) {
                a.x = e.x;
                a.y = e.y;
                a.height = this.threeDBase.height;
                b.originPoint = new FR.Chart.Point2D(a.x + a.width, a.y + a.height);
                b.axisGridLength = this.bounds.width
            } else {
                if (b.position == FR.Chart.Constants.RIGHT) {
                    a.x = e.x - a.width;
                    a.y = e.y;
                    a.height = this.threeDBase.height;
                    b.originPoint = new FR.Chart.Point2D(e.x - a.width, e.y + a.height);
                    b.axisGridLength = this.bounds.width
                }
            }
        }
    }, _dealPlotBoundsBefore: function (e, h) {
        if (e) {
            var g = this.threeDBase.getGapHeight();
            var b = h.x;
            var f = h.y + g;
            var d = h.width;
            var a = h.height - 2 * g;
            h.setRect(b, f, d, a)
        } else {
            var c = this.threeDBase.getGapWidth();
            var b = h.x + c;
            var f = h.y;
            var d = h.width - 2 * c;
            var a = h.height;
            h.setRect(b, f, d, a)
        }
    }, _dealPlotBoundsAfter: function (a, b) {
        if (a) {
            b.width += this.threeDBase.getGapWidth();
            b.height += 2 * this.threeDBase.getGapHeight();
            b.y -= this.threeDBase.getGapHeight()
        } else {
            b.width += 2 * this.threeDBase.getGapWidth();
            b.height += this.threeDBase.getGapHeight();
            b.y -= this.threeDBase.getGapHeight()
        }
    }, get3DDeep: function () {
        var a = this.deep;
        if (a == -1) {
            a = this.projection.projecteeDeep(this.deepBase)
        }
        return a
    }, draw3DInfo: function (a) {
        this.drawInfo(a);
        if (this.yAxisGlyph && this.yAxisGlyph.getBounds()) {
            this.yAxisGlyph.drawAxisGrid(a[1])
        }
        if (this.threeDBase) {
            if (this.isHorizontal) {
                this.threeDBase.draw3DBase(a[1], FR.Chart.Cubic.LEFT)
            } else {
                this.threeDBase.draw3DBase(a[1], FR.Chart.Cubic.BOTTOM)
            }
        }
    }
});
FR.Chart.MarkerGlyph = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function () {
        this.alpha = 1;
        this.background = null;
        this.marker = null;
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0
    }, setAlpha: function (a) {
        this.alpha = a
    }, getAlpha: function () {
        return this.alpha
    }, draw: function (a) {
        if (this.marker) {
            if (!a) {
                return
            }
            a.save();
            a.globalAlpha = this.alpha;
            if (this.drawOnMove) {
                if (this.marker.getMarkerType() == FR.Chart.Marker.NullMarker) {
                    var c = new FR.Chart.RoundFilledMarker();
                    c.color = this.marker.color;
                    if (this.background === null || !(this.background instanceof FR.Chart.ColorBackground)) {
                        c.background = FR.Chart.ColorBackground.getInstance("rgb(255,255,255)")
                    } else {
                        c.background = this.background
                    }
                    c.size = 6.5;
                    c.paintBackgroundBiggerMarker(a, this.x + this.width / 2, this.y + this.height / 2);
                    c.background = this.marker.background;
                    c.size = 4.5;
                    c.paint(a, this.x + this.width / 2, this.y + this.height / 2)
                } else {
                    var b = a.lineWidth;
                    a.lineWidth = 2;
                    var d = this.marker.background;
                    if (this.background === null || !(this.background instanceof FR.Chart.ColorBackground)) {
                        this.marker.background = FR.Chart.ColorBackground.getInstance("rgb(255,255,255)")
                    } else {
                        this.marker.background = this.background
                    }
                    this.marker.size = 8.5;
                    this.marker.paintBackgroundBiggerMarker(a, this.x + this.width / 2, this.y + this.height / 2);
                    this.marker.size = 6.5;
                    this.marker.background = d;
                    this.marker.paint(a, this.x + this.width / 2, this.y + this.height / 2);
                    a.lineWidth = b
                }
            } else {
                if (!FR.Chart.ChartUtils.isExcanvas()) {
                    this.marker.size = 6.5;
                    if (!a) {
                        return
                    }
                    a.save();
                    a.globalCompositeOperation = "destination-out";
                    this.marker.paintBackgroundBiggerMarker(a, this.x + this.width / 2, this.y + this.height / 2);
                    a.restore()
                }
                this.marker.size = 4.5;
                this.marker.paint(a, this.x + this.width / 2, this.y + this.height / 2)
            }
            a.restore()
        }
    }, draw4Demo: function (a) {
        if (this.marker) {
        }
    }, getAnimateGlyph: function (e, c, a, g) {
        if (g == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return []
        }
        var d = Math.random() * e;
        var f = [];
        for (var b = 0; b < e; b++) {
            if (c == FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL) {
                f[b] = this
            } else {
                if (c == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && g == FR.Chart.ChartPaintConstants.STATE_ENABLE && a) {
                    f[b] = new FR.Chart.MarkerGlyph();
                    f[b].alpha = this.alpha;
                    f[b].marker = this.marker;
                    f[b].width = this.width;
                    f[b].height = this.height;
                    f[b].x = FR.Chart.ChartEase.easeOutQuint(b + 1, a.x, this.x - a.x, e);
                    f[b].y = FR.Chart.ChartEase.easeOutQuint(b + 1, a.y, this.y - a.y, e)
                } else {
                    if (c == FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE && g == FR.Chart.ChartPaintConstants.STATE_DISAPPEAR) {
                        if (b + 1 > d) {
                            f[b] = new FR.Chart.MarkerGlyph()
                        } else {
                            f[b] = this
                        }
                    } else {
                        if (b + 1 > d) {
                            f[b] = this
                        } else {
                            f[b] = new FR.Chart.MarkerGlyph()
                        }
                    }
                }
            }
        }
        return f
    }, getShape: function () {
        return new FR.Chart.Bounds(this.x, this.y, this.width, this.height)
    }, setShape: function (a) {
        this.x = a.x;
        this.y = a.y;
        this.width = a.width;
        this.height = a.height
    }, dealCondition: function (d, b) {
        var a = d.getConditionAttr(new FR.Chart.AttrMarkerType(), b);
        this.marker = FR.Chart.MarkerFactory.createMarker(a.markerType);
        var c = d.getConditionAttr(new FR.Chart.AttrAlpha(), b);
        this.alpha = c.alpha
    }, dealCondition4Line: function (f, d, b) {
        var a = f.getConditionAttr(new FR.Chart.AttrMarkerType(), d);
        this.marker = FR.Chart.MarkerFactory.createMarker(a.markerType);
        var c = f.getConditionAttr(new FR.Chart.AttrColor(), d, b);
        this.marker.background = FR.Chart.ColorBackground.getInstance(c.seriesColor);
        var e = f.getConditionAttr(new FR.Chart.AttrAlpha(), d);
        this.alpha = e.alpha
    }, getBounds2D: function () {
        return this.getShape()
    }, isNeedRadialGradient: function () {
        return false
    }
});
FR.Chart.BarPlotGlyph = FR.extend(FR.Chart.CategoryPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isHorizontal = FR.pick(a.isHorizontal, false);
        this.seriesOverlapPercent = FR.pick(a.seriesOverlapPercent, -0.2);
        this.categoryIntervalPercent = FR.pick(a.categoryIntervalPercent, 1);
        this.LABEL_BAR_GAP = 3;
        FR.Chart.BarPlotGlyph.superclass.initConstants.apply(this, [a])
    }, isSupportLabelWrap: function () {
        return true
    }, configSeries: function (a) {
        this.isHorizontal = FR.pick(a.isHorizontal, false);
        this.seriesOverlapPercent = FR.pick(a.seriesGap, -0.2);
        this.categoryIntervalPercent = FR.pick(a.categoryGap, 1);
        FR.Chart.BarPlotGlyph.superclass.configSeries.apply(this, [a])
    }, seriesLabelsInSide: function (a) {
        if (!this.conditionCollection || !a) {
            return true
        }
        var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (!b) {
            return true
        }
        return b.position === FR.Chart.Constants.INSIDE
    }, getBarShape: function (m, j, t, g, s, c, b) {
        var i = j.getBarPercent(c);
        var d = j.getBarStartPercent(i, b, g, t);
        var p = j.getDataPointPercentValue(m.seriesIndex, t);
        var h = 0;
        if (s.isLog) {
            h = 1
        }
        var a, q, u = g.unitLength * i;
        var o = g.unitLength * i * (this.isStockChart ? m.points[t].stockDataPointCount : 1);
        if (this.isHorizontal) {
            if (!g.axisReversed) {
                u = g.getPoint2D(d + i).y
            } else {
                u = g.getPoint2D(d).y
            }
        } else {
            if (!g.axisReversed) {
                u = g.getPoint2D(d).x
            } else {
                u = g.getPoint2D(d + i).x
            }
        }
        var n = false;
        if (this.isStacked) {
            if (p >= 0) {
                var f = j.getPreSum4Bar(m.seriesIndex, t, false);
                if (this.isHorizontal) {
                    if (s.axisReversed) {
                        a = s.getPointInBounds(f + p).x
                    } else {
                        a = s.getPointInBounds(f).x
                    }
                } else {
                    if (s.axisReversed) {
                        a = s.getPointInBounds(f).y
                    } else {
                        a = s.getPointInBounds(f + p).y
                    }
                }
                q = s.get2ValueLength(f, f + p)
            } else {
                var k = j.getPreSum4Bar(m.seriesIndex, t, true);
                if (this.isHorizontal) {
                    if (s.axisReversed) {
                        a = s.getPointInBounds(k).x
                    } else {
                        a = s.getPointInBounds(k + p).x
                    }
                } else {
                    if (s.axisReversed) {
                        a = s.getPointInBounds(k + p).y
                    } else {
                        a = s.getPointInBounds(k).y
                    }
                }
                q = s.get2ValueLength(k + p, k);
                n = true
            }
        } else {
            if (p > h) {
                if (this.isHorizontal) {
                    if (!s.axisReversed) {
                        a = s.getPointInBounds(h).x
                    } else {
                        a = s.getPointInBounds(p).x
                    }
                } else {
                    if (!s.axisReversed) {
                        a = s.getPointInBounds(p).y
                    } else {
                        a = s.getPointInBounds(h).y
                    }
                }
            } else {
                if (this.isHorizontal) {
                    if (!s.axisReversed) {
                        a = s.getPointInBounds(p).x
                    } else {
                        a = s.getPointInBounds(h).x
                    }
                } else {
                    if (!s.axisReversed) {
                        a = s.getPointInBounds(h).y
                    } else {
                        a = s.getPointInBounds(p).y
                    }
                }
                n = true
            }
            q = s.get2ValueLength(p, h)
        }
        var e = new FR.Chart.Bounds();
        e.isHorizontal4Bounds = this.isHorizontal;
        e.isNigativeValue = n;
        e.axisReversed = s.axisReversed;
        var l = 0.05;
        var r = l * 2;
        if (this.isHorizontal) {
            e.x = a - l;
            e.y = u - l;
            e.width = q;
            e.height = o
        } else {
            e.x = u - l;
            e.y = a - l;
            e.width = o + r;
            e.height = q + r
        }
        return e
    }, _getLabelBoundsInHorizontal: function (e, d, a, c) {
        var b;
        if (c) {
            switch (a) {
                case FR.Chart.Constants.INSIDE:
                    b = d.x + this.LABEL_BAR_GAP;
                    break;
                case FR.Chart.Constants.OUTSIDE:
                    b = d.x - e.width - this.LABEL_BAR_GAP;
                    break;
                default:
                    b = d.x + (d.width - e.width) / 2;
                    break
            }
        } else {
            switch (a) {
                case FR.Chart.Constants.INSIDE:
                    b = d.x + d.width - e.width - this.LABEL_BAR_GAP;
                    break;
                case FR.Chart.Constants.OUTSIDE:
                    b = d.x + d.width + this.LABEL_BAR_GAP;
                    break;
                default:
                    b = d.x + (d.width - e.width) / 2;
                    break
            }
        }
        return new FR.Chart.Bounds(b, d.y + (d.height - e.height) / 2, e.width, e.height)
    }, _getLabelBoundsInVertical: function (e, d, a, c) {
        var b;
        if (c) {
            switch (a) {
                case FR.Chart.Constants.INSIDE:
                    b = d.y + d.height - this.LABEL_BAR_GAP - e.height;
                    break;
                case FR.Chart.Constants.OUTSIDE:
                    b = d.y + d.height + this.LABEL_BAR_GAP;
                    break;
                default:
                    b = d.y + (d.height - e.height) / 2;
                    break
            }
        } else {
            switch (a) {
                case FR.Chart.Constants.INSIDE:
                    b = d.y + this.LABEL_BAR_GAP;
                    break;
                case FR.Chart.Constants.OUTSIDE:
                    b = d.y - e.height - this.LABEL_BAR_GAP;
                    break;
                default:
                    b = d.y + (d.height - e.height) / 2;
                    break
            }
        }
        return new FR.Chart.Bounds(d.x + (d.width - e.width) / 2, b, e.width, e.height)
    }, getBarPercent: function (a) {
        return 1 / (a - ((a - 1) * this.seriesOverlapPercent) + this.categoryIntervalPercent)
    }, getBarStartPercent: function (a, b, c, d) {
        return a * (1 - this.seriesOverlapPercent) * b + c.getTickIndex4Value(d) + 0.5 * this.categoryIntervalPercent * a
    }, getDataPointLabelBoundsWithPosition: function (e, d, a, b) {
        var c = b ^ this.yAxisGlyph.axisReversed;
        if (this.isHorizontal) {
            return this._getLabelBoundsInHorizontal(e, d, a, c)
        } else {
            return this._getLabelBoundsInVertical(e, d, a, c)
        }
    }, getBarShape4GanttPlot: function (f, c, p, a, h, e, d) {
        this.seriesOverlapPercent = -0.2;
        this.categoryIntervalPercent = 0.1;
        var k = this.getBarPercent(e);
        var g = k * (1 - this.seriesOverlapPercent) * d + a.getTickIndex4Value(p) + 0.5 * this.categoryIntervalPercent * k;
        var b = FR.Chart.ChartUtils.int2Date(f, FR.Chart.Constants.Second);
        var j = FR.Chart.ChartUtils.date2Int(b, h.mainType);
        var o = FR.Chart.ChartUtils.int2Date(c, FR.Chart.Constants.Second);
        var r = FR.Chart.ChartUtils.date2Int(o, h.mainType);
        var l = h.getPointInBounds(j).x;
        var i = a.getPoint2D(g).y;
        var n = h.getPointInBounds(r).x - l;
        var m = a.unitLength * k;
        var q = 40;
        if (m > q) {
            i = i + (m - q) / 2;
            m = q
        }
        return new FR.Chart.Bounds(l, i, n, m)
    }
});
FR.Chart.Bar2DPlotGlyph = FR.extend(FR.Chart.BarPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.Bar2DPlotGlyph.superclass.initConstants.apply(this, [a])
    }, findClickOnGlyph: function (a, b) {
        if (this.bounds && this.bounds.containsPoint(a.x, a.y)) {
            this._findNearByDataPoint(a, b)
        }
    }, layoutDataSeriesGlyph: function () {
        var g = this.getSeriesViewCount(), c = -1;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var e = this.dataSeries[b];
            if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                for (var f = 0; f < e.getDataPointCount(); f++) {
                    var a = e.points[f];
                    a.lastGlyph = a.glyph;
                    a.glyph = null
                }
                continue
            }
            c++;
            var d = this.dealShape4Bar(e, this, this.xAxisGlyph, this.getSeriesAxisGlyph(b), g, c);
            if (d !== -1) {
                this.dealBarShape4LargeDataStockChart(e, this, this.xAxisGlyph, this.getSeriesAxisGlyph(b), g, c, d)
            }
            if (this.isStockChart) {
                this.refreshDataPointLabel()
            }
        }
        if (this.isStacked) {
            this._setTotalRectWhenStacked()
        }
        this.dealLabelBoundsInOrder();
        this._dealBoundsGap4Unstacked()
    }, _getBoundsGap: function (b) {
        var a = this.getBarPercent(b);
        var f = this.xAxisGlyph.unitLength * a;
        var d = a * (1 - this.seriesOverlapPercent) * 0 + this.xAxisGlyph.getTickIndex4Value(0) + 0.5 * this.categoryIntervalPercent * a;
        var g = a * (1 - this.seriesOverlapPercent) * 1 + this.xAxisGlyph.getTickIndex4Value(0) + 0.5 * this.categoryIntervalPercent * a;
        var e = 0;
        var c = 0;
        if (this.isHorizontal) {
            if (this.xAxisGlyph.axisReversed) {
                e = this.xAxisGlyph.getPoint2D(d).y;
                c = this.xAxisGlyph.getPoint2D(g).y
            } else {
                e = this.xAxisGlyph.getPoint2D(d + a).y;
                c = this.xAxisGlyph.getPoint2D(g + a).y
            }
        } else {
            if (this.xAxisGlyph.axisReversed) {
                e = this.xAxisGlyph.getPoint2D(d + a).x;
                c = this.xAxisGlyph.getPoint2D(g + a).x
            } else {
                e = this.xAxisGlyph.getPoint2D(d).x;
                c = this.xAxisGlyph.getPoint2D(g).x
            }
        }
        return Math.abs(c - e) - f
    }, _dealBoundsGap4Unstacked: function () {
        if (!this.isStacked) {
            var m = this.getSeriesViewCount();
            if (m <= 1 || this.getCategoryCount() <= 0) {
                return
            }
            var n = this.getBarPercent(m);
            var k = this.xAxisGlyph.unitLength;
            var i = Math.round(this._getBoundsGap(m));
            var l = Math.round(k * n);
            var e = l * m + i * (m - 1);
            for (var g = 0; g < this.getCategoryCount(); g++) {
                var a = 0;
                if (this.isHorizontal) {
                    a = this.xAxisGlyph.getPoint2D(this.xAxisGlyph.getTickIndex4Value(g)).y
                } else {
                    a = this.xAxisGlyph.getPoint2D(this.xAxisGlyph.getTickIndex4Value(g)).x
                }
                if (this.isHorizontal) {
                    var c = Math.round(a - (k - e) / 2);
                    if (this.xAxisGlyph.axisReversed) {
                        c = Math.round(a + (k - e) / 2)
                    }
                    var j = 0;
                    for (var b = 0; b < this.dataSeries.length; b++) {
                        if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                            continue
                        }
                        var h = this.dataSeries[b].points[g].glyph;
                        if (h && h.shape) {
                            var f = h.shape;
                            if (this.xAxisGlyph.axisReversed) {
                                f.y = c + j * (l + i)
                            } else {
                                f.y = c - j * (l + i) - l
                            }
                            f.height = l
                        }
                        j++
                    }
                } else {
                    var d = Math.round(a + (k - e) / 2);
                    if (this.xAxisGlyph.axisReversed) {
                        d = Math.round(a - (k + e) / 2)
                    }
                    var j = 0;
                    for (var b = 0; b < this.dataSeries.length; b++) {
                        if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                            continue
                        }
                        var h = this.dataSeries[b].points[g].glyph;
                        if (h && h.shape) {
                            var f = h.shape;
                            f.x = d + j * (l + i);
                            f.width = l
                        }
                        j++
                    }
                }
            }
        }
    }, _isOutPlotBounds: function (h) {
        var g = this.getBounds();
        var e = parseInt(h.x);
        var f = parseInt(e + h.width);
        var c = parseInt(h.y);
        var b = parseInt(c + h.height);
        var d = parseInt(g.x);
        var a = parseInt(g.y);
        if (e < d || f > d + g.width + 1) {
            return true
        }
        if (c < a || b > a + g.height + 1) {
            return true
        }
        return false
    }, dealBarShape4LargeDataStockChart: function (o, l, j, t, d, c, u) {
        for (var v = 0; v < o.getDataPointCount(); v++) {
            o.points[v].revert2Original()
        }
        var b = [];
        var e = [];
        var q = 0;
        var k = null;
        var r = null;
        var n = [];
        for (var v = 0; v < o.getDataPointCount(); v++) {
            var h = o.points[v];
            h.glyph = null;
            h.lastGlyph = null;
            h.animateGlyph = null;
            if (h.dataLabel) {
                h.dataLabel.bounds = null
            }
            if (h.valueIsNull) {
                continue
            }
            var f = this.getBarShape(o, l, v, j, t, d, c);
            if (this._isOutPlotBounds(f)) {
                continue
            }
            var w = j.getDate4Value(v);
            if (n.length === 0) {
                k = w;
                n[0] = h;
                r = h;
                h.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(w, u);
                r.stockDataPointCount = 1;
                continue
            } else {
                if (FR.Chart.ChartUtils.isBelongToSameUnit(k, w, u)) {
                    r.addDataPoint4StockCategory(h);
                    r.stockDataPointCount++;
                    h.valueIsNull = true;
                    continue
                }
            }
            var m = this.getStockDateRangeIndex(n, w, j, u);
            if (m !== -1) {
                n[m].addDataPoint4StockCategory(h);
                h.valueIsNull = true;
                r.stockDataPointCount++
            } else {
                n[n.length] = h;
                h.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(w, u);
                k = w;
                r = h;
                r.stockDataPointCount = 1
            }
        }
        t.oldMin = t.minValue;
        t.oldMax = t.maxValue;
        t.oldTick = t.tickLength;
        t.initMinMaxValue(this.getMinValueFromData(t.isLog, FR.Chart.CustomAttr.Axis_LEFT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_LEFT));
        t.calculateAxisGlyph(this.bounds);
        j.stockChartMainType = u;
        for (var m = 0; m < n.length; m++) {
            var h = n[m];
            var f = this.getBarShape(o, l, h.categoryIndex, j, t, d, c);
            var w = j.getDate4Value(h.categoryIndex);
            if (this._isOutPlotBounds(f)) {
                h.glyph = null;
                h.lastGlyph = null;
                h.animateGlyph = null;
                if (h.dataLabel) {
                    h.dataLabel.bounds = null
                }
                continue
            }
            var a = FR.Chart.ChartUtils.date2Int(w, j.mainType);
            if (!j.stockChartMinDateInt) {
                j.stockChartMinDateInt = a
            } else {
                j.stockChartMinDateInt = Math.min(a, j.stockChartMinDateInt)
            }
            var g = new FR.Chart.ShapeGlyph();
            h.glyph = g;
            g.setShape(f);
            if (this.dataSeries.length === 1) {
                g.info.dealCondition(this.conditionCollection, h, this.createColors4Series());
                g.info.dealConditionWithSeriesColor(this.conditionCollection, h, this.createColors4Cate())
            } else {
                g.info.dealCondition(this.conditionCollection, h, this.createColors4Series())
            }
            g.toolTipBackground = g.info.getBackground();
            var p = h.value;
            var i = true;
            if (this.isHorizontal) {
                if ((f.y < 0 && f.y + f.height < 0)) {
                    i = false
                }
            } else {
                if ((f.x < 0 && f.x + f.width < 0) || (f.x > this.getBounds().x + this.getBounds().width)) {
                    i = false
                }
            }
            if (i) {
                var s = (p > 0) != (t.axisReversed);
                if (s) {
                    b[q] = f.x + f.width / 2;
                    e[q] = f.y
                } else {
                    b[q] = f.x + f.width / 2;
                    e[q] = f.y + f.height
                }
                q++
            }
            h.dataPointStyle = null;
            if (this.plotStyle !== FR.Chart.Constants.STYLE_NONE) {
                this.addChartStyle4DataPoint(this.plotStyle, h, g, f);
                g.dataPointStyle = h.dataPointStyle;
                if (h.seriesIndex == this.getLastSeriesViewIndex() && h.dataPointStyle) {
                    h.dataPointStyle.isFirst = true
                }
            }
            this.dealDataPointLabel(h)
        }
        if (!this.isStacked && !this.isHorizontal) {
            this.trendLineFitting(b, e, o, t)
        }
    }, dealShape4Bar: function (l, j, i, p, c, b) {
        var a = [];
        var d = [];
        var n = 0;
        var k = null;
        if (this.isStockChart) {
            for (var q = 0; q < l.getDataPointCount(); q++) {
                l.points[q].revert2Original()
            }
        }
        i.stockChartMainType = null;
        i.stockChartMinDateInt = null;
        for (var q = 0; q < l.getDataPointCount(); q++) {
            var g = l.points[q];
            g.lastGlyph = this.getLastDataPointGlyph(g);
            if (g.valueIsNull) {
                g.glyph = null;
                g.lastGlyph = null;
                continue
            }
            var f = new FR.Chart.ShapeGlyph();
            g.glyph = f;
            var e = this.getBarShape(l, j, q, i, p, c, b);
            if (this._isOutPlotBounds(e)) {
                g.glyph = null;
                g.lastGlyph = null;
                g.animateGlyph = null;
                if (g.dataLabel) {
                    g.dataLabel.bounds = null
                }
                continue
            }
            if (this.isStockChart) {
                var r = i.getDate4Value(q);
                if ((this.isHorizontal ? e.height : e.width) < 2 && k) {
                    return this.getStockChartAdjustDateType(r, k)
                }
                k = r
            }
            f.setShape(e);
            if (this.dataSeries.length === 1) {
                f.info.dealCondition(this.conditionCollection, g, this.createColors4Series());
                f.info.dealConditionWithSeriesColor(this.conditionCollection, g, this.createColors4Cate())
            } else {
                f.info.dealCondition(this.conditionCollection, g, this.createColors4Series())
            }
            f.toolTipBackground = f.info.getBackground();
            var m = j.getDataPointPercentValue(l.seriesIndex, q);
            var h = true;
            if (this.isHorizontal) {
                if ((e.y < 0 && e.y + e.height < 0)) {
                    h = false
                }
            } else {
                if ((e.x < 0 && e.x + e.width < 0) || (e.x > this.getBounds().x + this.getBounds().width)) {
                    h = false
                }
            }
            if (h) {
                var o = (m > 0) != (p.axisReversed);
                if (o) {
                    a[n] = e.x + e.width / 2;
                    d[n] = e.y
                } else {
                    a[n] = e.x + e.width / 2;
                    d[n] = e.y + e.height
                }
                n++
            }
            g.dataPointStyle = null;
            if (this.plotStyle !== FR.Chart.Constants.STYLE_NONE) {
                this.addChartStyle4DataPoint(this.plotStyle, g, f, e);
                f.dataPointStyle = g.dataPointStyle;
                if (g.seriesIndex == this.getLastSeriesViewIndex() && g.dataPointStyle) {
                    g.dataPointStyle.isFirst = true
                }
            }
            this.dealDataPointLabel(g)
        }
        if (!this.isStacked && !this.isHorizontal) {
            this.trendLineFitting(a, d, l, p)
        }
        return -1
    }, addChartStyle4DataPoint: function (d, c, f, e) {
        if (f.info.getBackground().color) {
            var b = f.info.getBackground().color;
            var a = {
                "color": b,
                "rect": e,
                "avoidOriginDraw": true,
                "isHorizontal": this.isHorizontal,
                "axisReversed": this.yAxisGlyph.axisReversed
            };
            var g = {"color": b, "rect": e, "avoidOriginDraw": false, "isHorizontal": this.isHorizontal};
            if (d == FR.Chart.Constants.STYLE_3D) {
                if (this.isStacked) {
                    c.dataPointStyle = new FR.Chart.StackedBar3DStyle(a)
                } else {
                    if (this.isHorizontal) {
                        c.dataPointStyle = new FR.Chart.BarHorizontal3DStyle(a)
                    } else {
                        c.dataPointStyle = new FR.Chart.BarVertical3DStyle(a)
                    }
                }
            } else {
                if (d == FR.Chart.Constants.STYLE_OUTER) {
                    if (this.isStacked) {
                        c.dataPointStyle = new FR.Chart.StackedBarHighLightStyle(a)
                    } else {
                        c.dataPointStyle = new FR.Chart.BarHighLightStyle(a)
                    }
                    c.dataPointStyle.plotBounds = this.bounds
                } else {
                    if (d == FR.Chart.Constants.STYLE_SHADE) {
                        if (this.isStacked) {
                            c.dataPointStyle = new FR.Chart.StackedBarTopDownShadeStyle(g);
                            c.dataPointStyle.animateGlyph = f
                        } else {
                            c.dataPointStyle = new FR.Chart.BarTopDownShadeStyle(a)
                        }
                    } else {
                        if (d == FR.Chart.Constants.STYLE_TRANSPARENT) {
                            if (this.isStacked) {
                                c.dataPointStyle = new FR.Chart.StackedBarTransparentChartStyle(a)
                            } else {
                                c.dataPointStyle = new FR.Chart.BarTransparentChart(a)
                            }
                        }
                    }
                }
            }
            if (this.conditionCollection.isContainsAttr(c, new FR.Chart.AttrAlpha())) {
                c.dataPointStyle.alpha = f.info.getAlpha()
            }
            if (this.conditionCollection.isContainsAttr(c, new FR.Chart.AttrBorder())) {
                c.dataPointStyle.borderColor = f.info.getBorderColor();
                c.dataPointStyle.borderWidth = f.info.getBorderStyle()
            }
        }
    }, categoryInBounds: function (a, c) {
        if (!a.glyph) {
            return false
        }
        var b = a.glyph.getShape();
        if (b != null) {
            return FR.Chart.ChartUtils.rectangleOverlapped(b, c)
        }
    }, setTotalRectForStackedBar: function (a) {
        var f = a.stackedList;
        for (var c = 0; c < f.length; c++) {
            var h = f[c];
            var g = [];
            for (var e = 0; e < h.length; e++) {
                var d = a.dataSeries[h[e]];
                g[e] = d;
                if (e == h.length - 1) {
                    this.setSeriesIsFirst(d, true)
                } else {
                    this.setSeriesIsFirst(d, false)
                }
            }
            if (g.length <= 0) {
                continue
            }
            for (var b = 0; b < this.getCategoryCount(); b++) {
                this.getTotalRectWhenStacked(g, b)
            }
        }
    }, setSeriesIsFirst: function (d, a) {
        for (var c = 0; c < d.getDataPointCount(); c++) {
            var b = d.points[c];
            if (b.dataPointStyle) {
                b.dataPointStyle.isFirst = a
            }
        }
    }, getTotalRectWhenStacked: function (c, k) {
        var j = this.bounds.x + this.bounds.width, i = this.bounds.y + this.bounds.height;
        var b = 0, l = 0;
        var d = null;
        for (var e = 0; e < c.length; e++) {
            var a = c[e].points[k];
            if (a.glyph) {
                var h = a.glyph.getShape();
                j = Math.min(j, h.x);
                i = Math.min(i, h.y);
                if (this.isHorizontal) {
                    b += h.width;
                    l = h.height
                } else {
                    b = h.width;
                    l += h.height
                }
            }
        }
        var g = new FR.Chart.Bounds(j, i, b, l);
        for (var f = 0; f < c.length; f++) {
            var a = c[f].points[k];
            if (a && a.glyph && a.dataPointStyle) {
                a.dataPointStyle.totalRect = g
            }
        }
    }, _setTotalRectWhenStacked: function () {
        for (var j = 0; j < this.getCategoryCount(); j++) {
            var i = this.bounds.x + this.bounds.width, h = this.bounds.y + this.bounds.height;
            var b = 0, k = 0;
            var c = null;
            for (var d = 0; d < this.dataSeries.length; d++) {
                var a = this.dataSeries[d].points[j];
                if (a.glyph) {
                    var g = a.glyph.getShape();
                    i = Math.min(i, g.x);
                    h = Math.min(h, g.y);
                    if (this.isHorizontal) {
                        b += g.width;
                        k = g.height
                    } else {
                        b = g.width;
                        k += g.height
                    }
                }
            }
            var f = new FR.Chart.Bounds(i, h, b, k);
            for (var e = 0; e < this.dataSeries.length; e++) {
                var a = this.dataSeries[e].points[j];
                if (a && a.glyph && a.dataPointStyle) {
                    a.dataPointStyle.totalRect = f
                }
            }
        }
    }
});
FR.Chart.Bar3DPlotGlyph = FR.extend(FR.Chart.BarPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.ZP = 70;
        this.LABEL_GAP = 8;
        this.deep = FR.pick(a.deep, -1);
        this.horizontalDrawBar = FR.pick(a.horizontalDrawBar, false);
        this.projection = new FR.Chart.Projection(a.projection);
        FR.Chart.Bar3DPlotGlyph.superclass.initConstants.apply(this, [a])
    }, layoutAxisGlyph: function () {
        this.layoutAxisGlyph4ThreeD(this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph)
    }, layoutDataSeriesGlyph: function () {
        var d = new FR.Chart.GeneralPath();
        var g = this.getSeriesViewCount(), c = -1;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var e = this.dataSeries[b];
            if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                for (var f = 0; f < e.getDataPointCount(); f++) {
                    var a = e.points[f];
                    a.lastGlyph = a.glyph;
                    a.glyph = null
                }
                continue
            }
            c++;
            this.dealShape4CubicBar(e, this, this.xAxisGlyph, this.yAxisGlyph, g, c);
            this.dealLabelBoundsInOrder()
        }
    }, dealShape4CubicBar: function (p, m, k, n, c, b) {
        var q = 0;
        for (var r = 0; r < p.getDataPointCount(); r++) {
            var i = p.points[r];
            i.lastGlyph = i.glyph;
            if (i.valueIsNull) {
                i.glyph = null;
                continue
            }
            var h = new FR.Chart.ShapeGlyph();
            i.glyph = h;
            var f = this.getBarShape(p, m, r, k, n, c, b);
            var g = new FR.Chart.Cubic(f.x, f.y, f.width, f.height);
            var o = m.get3DDeep();
            var l = 0;
            var a = !!m.horizontalDrawBar;
            var j = !!m.isStacked;
            if (!j) {
                o = o / c;
                l = -o * b
            }
            if (m.isNeedDefaultDeep()) {
                l = 0;
                o = this.ZP
            }
            g.horizontalDrawBar = m.isHorizontal;
            g.deep = o;
            g.projection = m.projection;
            g.z = l;
            if (m.isHorizontal) {
                var e = ((a || j) ? g.getGapWidth() : m.threeDBase.getGapWidth());
                g.setCubicPosition(g.x - e, g.y)
            } else {
                var d = ((a || j) ? g.getGapHeight() : m.threeDBase.getGapHeight());
                g.setCubicPosition(g.x, g.y + d)
            }
            h.setShape(g);
            if (m.dataSeries.length === 1) {
                h.info.dealCondition(this.conditionCollection, i, this.createColors4Series());
                h.info.dealConditionWithSeriesColor(this.conditionCollection, i, this.createColors4Cate())
            } else {
                h.info.dealCondition(this.conditionCollection, i, this.createColors4Series())
            }
            h.toolTipBackground = h.info.getBackground();
            this.dealDataPointLabel(i)
        }
    }, isNeedDefaultDeep: function () {
        return this.horizontalDrawBar || this.isStacked
    }, get3DDeep: function () {
        var a = this.deep;
        if (a == -1) {
            a = this.projection.projecteeDeep(this.deepBase)
        }
        if (this.isNeedDefaultDeep()) {
            return this.ZP
        }
        return a
    }, getDrawSequence: function () {
        if (this.horizontalDrawBar || this.isStacked) {
            return FR.Chart.Bar3DPlotGlyph.superclass.getDrawSequence.apply(this, [])
        } else {
            var a = [];
            for (var b = 0; this.dataSeries && b < this.dataSeries.length;
                 b++) {
                a[b] = this.dataSeries.length - b - 1
            }
            return a
        }
    }, draw: function (a, c, b) {
        this.draw3DInfo(a);
        if (this.xAxisGlyph != null) {
            this.xAxisGlyph.draw4ThreeD(a[1])
        }
        if (this.yAxisGlyph != null) {
            this.yAxisGlyph.draw4ThreeD(a[1])
        }
        FR.Chart.Bar3DPlotGlyph.superclass.draw.apply(this, [a, c, b])
    }, drawWhenStacked: function (a, c, b) {
        this.drawBar3DStackSeries(a, c, b, c.dataSeries)
    }, drawWhenUnStacked: function (a, e, d) {
        var b = e.getDrawSequence();
        for (var c = 0; c < e.dataSeries.length; c++) {
            e.dataSeries[b[c]].drawAnimateGlyph(a, d)
        }
    }, doAnimate4SeriesDraw: function (a, d, c) {
        if (d.isStacked) {
            this.drawWhenStacked(a, d, c)
        } else {
            this.drawWhenUnStacked(a, d, c)
        }
        for (var b = d.dataSeries.length - 1; b >= 0; b--) {
            d.dataSeries[b].drawAnimateGlyph4TrendLine(a, c)
        }
    }, drawInfo: function (a) {
        this.info.paint(a[0], this.getOutline4Fill())
    }, getOutline4Fill: function () {
        var e = this.threeDBase.getPoints()[4];
        var d = this.yAxisGlyph.bounds.width;
        var c = this.yAxisGlyph.bounds.height;
        var b = this.threeDBase.width;
        var a = this.threeDBase.height;
        if (this.isHorizontal) {
            return new FR.Chart.Bounds(e.x, e.y, b, a - c)
        } else {
            return new FR.Chart.Bounds(e.x + d, e.y, b - d, a)
        }
    }
});
FR.Chart.LinePlotGlyph = FR.extend(FR.Chart.CategoryPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isCurve = a.isCurve;
        FR.Chart.LinePlotGlyph.superclass.initConstants.apply(this, [a])
    }, isSupportLabelWrap: function () {
        return true
    }, configSeries: function (e) {
        this.isCurve = FR.pick(e.isCurve, false);
        this.isNullValueBreak = FR.pick(e.isNullValueBreak, true);
        var d = this.conditionCollection.defaultAttr;
        if (e.lineStyle != null && e.lineStyle != undefined) {
            var c = new FR.Chart.AttrLineStyle();
            c.lineStyle = e.lineStyle;
            d.addAttr(c)
        }
        var a = e.markerType || "NullMarker";
        var b = new FR.Chart.AttrMarkerType();
        b.markerType = a;
        d.addAttr(b);
        FR.Chart.LinePlotGlyph.superclass.configSeries.apply(this, [e])
    }, getLegendMarkerIcon: function (b, a) {
        return this.getLegendMarkerIcon4Line(b, a)
    }, dealAttr4LegendGlyph: function (c) {
        if (!c || !c.items) {
            return
        }
        for (var a = 0; a < this.dataSeries.length; a++) {
            if (!this.dataSeries[a].glyph || !this.dataSeries[a].glyph.lineStyleInfo || !this.dataSeries[a].glyph.lineStyleInfo.attrLineColor) {
                continue
            }
            var b = c.items[a].lineMarkerIcon;
            if (b && b.marker && b.marker.background && b.marker.background instanceof FR.Chart.ColorBackground) {
                b.marker.background.color = this.dataSeries[a].glyph.lineStyleInfo.attrLineColor.seriesColor
            }
        }
    }, layoutDataSeriesGlyph: function () {
        for (var a = 0; a < this.dataSeries.length; a++) {
            var c = this.dataSeries[a];
            c.lastGlyph = this.getLastSeriesGlyph(c);
            if (c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                c.glyph = null;
                continue
            }
            var d = this.getSeriesAxisGlyph(a);
            var b = this.dealLine4PlotGlyph(c, this, this.xAxisGlyph, d);
            if (b !== -1) {
                this.dealLine4StockChartLargeData(c, this, this.xAxisGlyph, d, b)
            }
            if (this.isStockChart) {
                this.refreshDataPointLabel()
            }
        }
        this.dealLabelBoundsInOrder()
    }, dealLine4StockChartLargeData: function (s, k, h, v, w) {
        for (var y = 0; y < s.getDataPointCount(); y++) {
            s.points[y].revert2Original()
        }
        var o = this.isSeriesCurve(s);
        var i = null;
        var u = null;
        var d = -1;
        var r = [];
        for (var y = 0; y < s.getDataPointCount(); y++) {
            var g = s.points[y];
            if (g.valueIsNull) {
                g.glyph = null;
                continue
            }
            var m = h.getPoint2D(h.getTickIndex4Value(y) + h.labelOffset).x;
            if (this.isDataPointXNotInPlotBounds(m)) {
                g.glyph = null;
                continue
            }
            var z = h.getDate4Value(y);
            if (r.length === 0) {
                i = z;
                r[0] = g;
                u = g;
                g.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(z, w);
                u.stockDataPointCount = 1;
                d = parseInt(m);
                continue
            } else {
                if (FR.Chart.ChartUtils.isBelongToSameUnit(z, i, w)) {
                    u.addDataPoint4StockCategory(g);
                    u.stockDataPointCount++;
                    g.valueIsNull = true;
                    continue
                }
            }
            var p = this.getStockDateRangeIndex(r, z, h, w);
            if (p !== -1) {
                r[p].addDataPoint4StockCategory(g);
                g.valueIsNull = true;
                u.stockDataPointCount++
            } else {
                d = parseInt(m);
                g.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(z, w);
                r[r.length] = g;
                i = z;
                u = g;
                u.stockDataPointCount = 1;
                d = parseInt(m)
            }
        }
        var q = r.length;
        for (var p = 0; p < q; p++) {
            var B = r[p];
            B.value = B.value / B.stockDataPointCount;
            B.percentValue = B.percentValue / B.stockDataPointCount
        }
        v.oldMin = v.minValue;
        v.oldMax = v.maxValue;
        v.oldTick = v.tickLength;
        v.initMinMaxValue(this.getMinValueFromData(v.isLog, FR.Chart.CustomAttr.Axis_LEFT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_LEFT));
        v.calculateAxisGlyph(this.bounds);
        h.stockChartMainType = w;
        var c = [];
        var f = [];
        var t = 0;
        var b = true;
        var a = new FR.Chart.GeneralPath();
        var x = new FR.Chart.GeneralPath();
        if (h.axisReversed) {
            a.axisReversed = true;
            x.axisReversed = true
        }
        var j = this.getBounds();
        for (var p = 0; p < q; p++) {
            var B = r[p];
            var n = this.getStockChartDatePointX(h, B, w, this.getBounds());
            var l = v.getPoint2D(B.value).y;
            c[t] = n;
            f[t] = l;
            t++;
            this.deal4LinePath(o, b, a, x, n, l, B);
            if (b) {
                b = false
            }
        }
        if (o) {
            FR.Chart.FoldLine.curveTo(a, x)
        }
        var A = new FR.Chart.FoldLine(a);
        s.glyph = A;
        A.lineStyleInfo.dealCondition(this.conditionCollection, s, this.createColors4Series());
        if (A.lineStyleInfo.attrLineColor.seriesColor) {
            var e = new FR.Chart.ColorBackground();
            e.color = A.lineStyleInfo.attrLineColor.seriesColor;
            A.toolTipBackground = e
        }
        this.trendLineFitting(c, f, s, v)
    }, deal4LinePath: function (c, b, e, h, g, f, a) {
        if (c) {
            if (b) {
                FR.Chart.FoldLine.curveTo(e, h);
                h.clear();
                h.moveTo(g, f);
                e.moveTo(g, f)
            } else {
                h.lineTo(g, f)
            }
        } else {
            if (b) {
                e.moveTo(g, f)
            } else {
                e.lineTo(g, f)
            }
        }
        if (!this.isDataPointXNotInPlotBounds(g)) {
            var d = new FR.Chart.MarkerGlyph();
            d.dealCondition4Line(this.conditionCollection, a, this.createColors4Series());
            d.setShape(new FR.Chart.Bounds(g - FR.Chart.Constants.MarkerDefaultSize / 2, f - FR.Chart.Constants.MarkerDefaultSize / 2, FR.Chart.Constants.MarkerDefaultSize, FR.Chart.Constants.MarkerDefaultSize));
            d.background = this.getBackground() !== null ? this.getBackground() : this.wholeChartBackground;
            a.glyph = d;
            d.toolTipBackground = d.background;
            this.dealDataPointLabel(a)
        }
    }, dealLine4PlotGlyph: function (p, j, i, s) {
        var d = [];
        var g = [];
        var r = 0;
        i.stockChartMinDateInt = null;
        i.stockChartMainType = null;
        var a = new FR.Chart.GeneralPath();
        var v = new FR.Chart.GeneralPath();
        if (i.axisReversed) {
            a.axisReversed = true;
            v.axisReversed = true
        }
        if (this.isStockChart) {
            for (var u = 0; u < p.getDataPointCount(); u++) {
                p.points[u].revert2Original()
            }
        }
        var b = true;
        var n = this.isSeriesCurve(p);
        var e = this.isSeriesNullValueBreak(p);
        var o = -1;
        var k = null;
        for (var u = 0; u < p.getDataPointCount(); u++) {
            var h = p.points[u];
            if (h.valueIsNull) {
                if (e) {
                    b = true
                }
                continue
            }
            var c = i.zoomBackward !== 0 || i.zoomForward !== 0;
            var q = j.getDataPointPercentValue(p.seriesIndex, u);
            var m = i.getPoint2D(i.getTickIndex4Value(u) + i.labelOffset).x;
            if (this.isDataPointXNotInPlotBounds(m)) {
                h.glyph = null;
                if (!c || (c && h.isOutBounds)) {
                    h.isOutBounds = true;
                    continue
                }
            }
            if (this.isStockChart && o === parseInt(m)) {
                var t = i.getDate4Value(u);
                return this.getStockChartAdjustDateType(t, k)
            } else {
                o = parseInt(m)
            }
            if (this.isStockChart) {
                k = i.getDate4Value(u)
            }
            var l = s.getPoint2D(q).y;
            d[r] = m;
            g[r] = l;
            r++;
            this.deal4LinePath(n, b, a, v, m, l, h);
            if (b) {
                b = false
            }
        }
        if (n) {
            FR.Chart.FoldLine.curveTo(a, v)
        }
        var w = new FR.Chart.FoldLine(a);
        p.glyph = w;
        w.lineStyleInfo.dealCondition(this.conditionCollection, p, this.createColors4Series());
        if (w.lineStyleInfo.attrLineColor.seriesColor) {
            var f = new FR.Chart.ColorBackground();
            f.color = w.lineStyleInfo.attrLineColor.seriesColor;
            w.toolTipBackground = f
        }
        this.trendLineFitting(d, g, p, s);
        return -1
    }, getDataPointLabelBoundsWithPosition: function (c, b, a) {
        return this.getDataPointLabelBoundsWithPosition4Line(c, b, a)
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (b, a) {
        this.drawAfterAnimate4LineMarker(b, a);
        this.drawAlertLinesAfterSeriesAnimateDraw(b)
    }, categoryInBounds: function (a, c) {
        if (!a.glyph) {
            return false
        }
        var b = a.glyph.getShape();
        if (b != null) {
            return c.containsPoint(b.x, b.y)
        }
    }, findOnMoveGlyph: function (a, c, b) {
        this._findOnMoveGlyph4Line(a, c, b)
    }
});
FR.Chart.Donut2DPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.innerRadiusPercent = FR.pick(a.innerRadiusPercent, 0.5);
        this.seriesGap = FR.pick(a.seriesGap, 0.05);
        this.categoryGap = FR.pick(a.categoryGap, 0.2);
        FR.Chart.Donut2DPlotGlyph.superclass.initConstants.apply(this, [a]);
        this.MARGIN_GAP = 3;
        this.arcWidth = 0;
        this.middleX = 0;
        this.middleY = 0;
        this.innerRadius = 0;
        this.radius = 0
    }, configSeries: function (a) {
        this.innerRadiusPercent = FR.pick(a.innerRadiusPercent, 0.5);
        this.seriesGap = FR.pick(a.seriesGap, 0.05);
        this.categoryGap = FR.pick(a.categoryGap, 0.2)
    }, layoutAxisGlyph: function () {
    }, layoutDataSeriesGlyph: function () {
        this.initArcValues();
        var a = new FR.Chart.BoundsManager();
        for (var b = 0; b < this.dataSeries[0].points.length; b++) {
            this.dealWithDataSeries(b, a)
        }
    }, initArcValues: function () {
        this.radius = Math.min(this.bounds.width, this.bounds.height) / 2 - this.MARGIN_GAP;
        if (this.plotStyle == FR.Chart.Constants.STYLE_OUTER) {
            this.outerArcRadius = this.radius;
            this.radius = this.outerArcRadius * 0.9
        }
        var a = this.radius * (1 - this.innerRadiusPercent);
        this.arcWidth = a / this.dataSeries[0].points.length;
        this.innerRadius = this.radius * this.innerRadiusPercent;
        this.middleX = this.bounds.x + this.bounds.width / 2;
        this.middleY = this.bounds.y + this.bounds.height / 2
    }, dealWithDataSeries: function (f, a) {
        for (var c = 0; c < this.dataSeries.length; c++) {
            var d = this.dataSeries[c];
            var b = d.points[f];
            b.lastGlyph = this.getLastDataPointGlyph(b);
            if (b.value <= 0 || d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                b.glyph = null;
                b.lastGlyph = null;
                continue
            }
            var e = new FR.Chart.ShapeGlyph();
            e.shape = this._getRing4DataPoint(b);
            e.info.dealCondition(this.conditionCollection, b, this.createColors4Series());
            e.toolTipBackground = e.info.getBackground();
            b.glyph = e;
            b.dataPointStyle = null;
            if (this.plotStyle !== FR.Chart.Constants.STYLE_NONE) {
                this.addChartStyle4DataPoint(this.plotStyle, b, e);
                e.dataPointStyle = b.dataPointStyle
            }
            this.dealWithLabelBounds(b, a)
        }
    }, addChartStyle4DataPoint: function (d, c, e) {
        if (e.info.getBackground().color) {
            var b = e.info.getBackground().color;
            var f = e.shape;
            var a = {
                "color": b,
                "arcShape": f,
                "avoidOriginDraw": true,
                "totalRadius": this.radius - this.arcWidth * this.categoryGap / 2,
                "count": this.getCategoryCount()
            };
            if (d == FR.Chart.Constants.STYLE_3D) {
                if (!this.arc3DStyleBase) {
                    this.arc3DStyleBase = new FR.Chart.Arc3DStyleBase(this.get3DStyleBaseShape())
                }
                c.dataPointStyle = new FR.Chart.ArcPlane3DStyle(a)
            } else {
                if (d == FR.Chart.Constants.STYLE_OUTER) {
                    if (FR.Browser.isIE8Before()) {
                        c.dataPointStyle = null
                    } else {
                        if (!this.arcOuterBase) {
                            this.arcOuterBase = new FR.Chart.ArcOuterBase(this.outerArcRadius - this.arcWidth * this.categoryGap / 2, new FR.Chart.Point2D(this.middleX, this.middleY), this.innerRadius + this.arcWidth * this.categoryGap / 2)
                        }
                        c.dataPointStyle = new FR.Chart.DonutOuterStyle(a)
                    }
                } else {
                    if (d == FR.Chart.Constants.STYLE_SHADE) {
                        c.dataPointStyle = new FR.Chart.ArcTopDownShadeStyle(a)
                    } else {
                        if (d == FR.Chart.Constants.STYLE_TRANSPARENT) {
                            c.dataPointStyle = new FR.Chart.ArcTransparentChartStyle(a)
                        }
                    }
                }
            }
        }
    }, doAnimate4SeriesDraw: function (a, e, d) {
        var b = e.getDrawSequence();
        for (var c = 0; c < e.dataSeries.length; c++) {
            e.dataSeries[b[c]].drawAnimateGlyph(a, d)
        }
        if (this.plotStyle == FR.Chart.Constants.STYLE_3D) {
            for (var c = 0; c < e.dataSeries.length; c++) {
                e.dataSeries[b[c]].drawAnimateGlyph(a, d)
            }
        }
    }, get3DStyleBaseShape: function () {
        var a = this.radius * (1 - this.innerRadiusPercent / 7);
        var b = a - this.radius * (1 - this.innerRadiusPercent);
        return new FR.Chart.Ring(this.middleX, this.middleY, a, 0, 360, b, 0, 360)
    }, dealWithLabelBounds: function (c, l) {
        var f = c.dataLabel;
        if (f == null || f.text == null || f.text.length === 0) {
            return
        }
        var h = c.seriesIndex;
        var m = c.categoryIndex;
        var j = this.getLabelDim(c);
        var k = this.getSeriesStartAngle(m, h, false) % 360;
        var n = this.getPercent(h, m) * (360 - this._getSeriesGapAngle(m, h, false));
        var e = n / 2 + k;
        var d = this.getArcInnerRadius(m) + this.arcWidth / 2;
        var b = this.middleX - d * Math.cos((e / 180) * Math.PI);
        var o = this.middleY - d * Math.sin((e / 180) * Math.PI);
        var a = new FR.Chart.Bounds(b - j.width / 2, o - j.height / 2, j.width, j.height);
        f.bounds = a;
        if (l.isInteract(a)) {
            for (var g = 0; g < 6; g++) {
                var i = parseInt(g / 2) + 1;
                if (g % 2 === 0) {
                    i = 4 - i
                } else {
                    i = 4 + i
                }
                e = (k + i * n / 8) % 360;
                b = b = this.middleX - d * Math.cos((e / 180) * Math.PI);
                o = this.middleY - d * Math.sin((e / 180) * Math.PI);
                a = a = new FR.Chart.Bounds(b - j.width / 2, o - j.height / 2, j.width, j.height);
                if (!l.isInteract(a)) {
                    f.bounds = a;
                    l.addBounds(a);
                    break
                }
            }
            if (g === 6) {
                f.bounds = null
            }
        } else {
            f.bounds = a;
            l.addBounds(a)
        }
    }, getLabelDim: function (a) {
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        var b = c.textAttr;
        if (b == null) {
            b = new FR.Chart.TextAttr()
        }
        return FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a.dataLabel.text, b)
    }, getSeriesStartAngle: function (l, d, m) {
        var h = 90;
        var j = this._getSeriesGapAngle(l, d, m);
        var c = 0;
        var a = [];
        for (var g = 0; g < this.dataSeries.length; g++) {
            var f = this.dataSeries[g];
            if (f.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                a[g] = c++
            }
        }
        var k = j / (this.getSeriesViewCount());
        var b = 0;
        for (var e = 0; e < d; e++) {
            b += this.getPercent(e, l) * (360 - j)
        }
        h += b + k * a[d] + k / 2;
        return h
    }, _getSeriesGapAngle: function (f, a, d) {
        var e = this.seriesGap;
        if (this._getNonzeroSeriesCount(f) <= 1) {
            e = 0
        }
        var c = e * 2 * Math.PI * this.innerRadius;
        var b = d ? this.getArcInnerRadius(f) : this.getActOuterRadius(f);
        return (c / b) * 360 / (2 * Math.PI)
    }, _getNonzeroSeriesCount: function (f) {
        var e = 0;
        for (var d = 0, b = this.dataSeries.length; d < b; d++) {
            var c = this.dataSeries[d];
            if (c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var a = c.points[f];
            if (a && a.value > 0) {
                e++
            }
        }
        return e
    }, getPercent: function (c, d) {
        if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return 0
        }
        var b = this.getTotalValue(d);
        if (b <= 0) {
            return 0
        }
        var a = this.dataSeries[c].points[d];
        return Math.abs(a.value) / b
    }, getTotalValue: function (e) {
        var c = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var d = this.dataSeries[b];
            var a = d.points[e];
            if (a.valueIsNull || d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            c += Math.abs(a.value)
        }
        return c
    }, _getRing4DataPoint: function (a) {
        var h = a.categoryIndex;
        var d = a.seriesIndex;
        var f = this.getActOuterRadius(h);
        var c = this.getSeriesStartAngle(h, d, false) % 360;
        var i = this.getPercent(d, h) * (360 - this._getSeriesGapAngle(h, d, false));
        var g = this.getArcInnerRadius(h);
        var e = this.getSeriesStartAngle(h, d, true) % 360;
        var b = this.getPercent(d, h) * (360 - this._getSeriesGapAngle(h, d, true));
        return new FR.Chart.Ring(this.middleX, this.middleY, f, c, i, g, e, b)
    }, getArcInnerRadius: function (a) {
        var b = this.arcWidth * this.categoryGap / 2;
        return this.innerRadius + this.arcWidth * a + b
    }, getActOuterRadius: function (a) {
        var b = this.arcWidth * this.categoryGap / 2;
        return this.innerRadius + this.arcWidth * (a + 1) - b
    }, draw: function (a, c, b) {
        this.drawInfo(a);
        FR.Chart.Donut2DPlotGlyph.superclass.draw.apply(this, [a, c, b])
    }
});
FR.Chart.Donut3DPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.innerRadiusPercent = FR.pick(a.innerRadiusPercent, 0.5);
        this.seriesGap = FR.pick(a.seriesGap, 0.05);
        this.categoryGap = FR.pick(a.categoryGap, 0.2);
        this.projection = new FR.Chart.Projection(a.projection || {elevation: 33, rotation: 0});
        FR.Chart.Donut3DPlotGlyph.superclass.initConstants.apply(this, [a]);
        this.ring4cate = [];
        this.MARGIN_GAP = 3;
        this.arcWidth = 0;
        this.middleX = 0;
        this.middleY = 0;
        this.innerRadius = 0;
        this.radius = 0
    }, layoutAxisGlyph: function () {
    }, layoutDataSeriesGlyph: function () {
        this.initArcValues();
        this.ring4cate = [];
        for (var b = 0, c = this.getCategoryCount(); b < c; b++) {
            var a = new FR.Chart.Ring3D(this.projection);
            this.dealWithDataSeries(b, a);
            this.ring4cate.push(a)
        }
    }, initArcValues: function () {
        this.radius = Math.min(this.bounds.width, this.bounds.height) / 2 - this.MARGIN_GAP;
        var a = this.radius * (1 - this.innerRadiusPercent);
        this.arcWidth = a / this.dataSeries[0].points.length;
        this.innerRadius = this.radius * this.innerRadiusPercent;
        this.middleX = this.bounds.x + this.bounds.width / 2;
        this.middleY = this.bounds.y + this.bounds.height / 2
    }, dealWithDataSeries: function (e, d) {
        for (var b = 0; b < this.dataSeries.length; b++) {
            var c = this.dataSeries[b];
            var a = c.points[e];
            a.lastGlyph = a.glyph;
            if (a.valueIsNull || c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            this.calculateShapeGlyph4DifferentSub(a, d, e, b)
        }
    }, calculateShapeGlyph4DifferentSub: function (a, k, l, e) {
        var i = this.getArcInnerRadius(l);
        var g = this.getActOuterRadius(l);
        var h = this.getSeriesStartAngle(l, e) % 360;
        var m = this.getPercent(e, l) * 360 * (1 - this.seriesGap);
        if (this.getSeriesViewCount() === 1 || this.getPercent(e, l) === 1) {
            h = 0;
            m = 360
        }
        var f = this.radius * 0.16;
        var j = new FR.Chart.Pie3D(0, f, g);
        j.info.dealCondition(this.conditionCollection, a, this.createColors4Series());
        var d = new FR.Chart.Pie3D(0, f, i);
        d.info.dealCondition(this.conditionCollection, a, this.createColors4Series());
        j.setAttribute(this.middleX, this.middleY, h, m, this.projection);
        d.setAttribute(this.middleX, this.middleY, h, m, this.projection);
        var c = new FR.Chart.Ring3D(this.projection);
        c.addCylinder(j, d);
        k.addCylinder(j, d);
        var b = new FR.Chart.ShapeGlyph();
        b.shape = c;
        b.info.dealCondition(this.conditionCollection, a, this.createColors4Series());
        b.toolTipBackground = b.info.getBackground();
        a.glyph = b;
        this.dealDataPointLabel(a)
    }, dealDataPointLabel: function (b) {
        var a = b.dataLabel;
        if (!a) {
            return
        }
        var h = b.getShape().getTopArcCenterPoint();
        if (h != null) {
            var g = this.getLabelDim(b);
            var e = g.width;
            var f = g.height;
            var d = h.x - e / 2;
            var c = h.y - f / 2;
            a.bounds = new FR.Chart.Bounds(d, c, e, f)
        } else {
            a.bounds = null
        }
    }, getLabelDim: function (a) {
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        var b = c.textAttr;
        if (b == null) {
            b = new FR.Chart.TextAttr()
        }
        return FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a.dataLabel.text, b)
    }, getArcInnerRadius: function (a) {
        var b = this.arcWidth * this.categoryGap / 2;
        return this.innerRadius + this.arcWidth * a + b
    }, getActOuterRadius: function (a) {
        var b = this.arcWidth * this.categoryGap / 2;
        return this.innerRadius + this.arcWidth * (a + 1) - b
    }, getPercent: function (c, d) {
        if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return 0
        }
        var b = this.getTotalValue(d);
        if (b <= 0) {
            return 0
        }
        var a = this.dataSeries[c].points[d];
        return Math.abs(a.value) / b
    }, getTotalValue: function (e) {
        var c = 0;
        for (var b = 0; b < this.dataSeries.length;
             b++) {
            var d = this.dataSeries[b];
            var a = d.points[e];
            if (a.valueIsNull || d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            c += Math.abs(a.value)
        }
        return c
    }, getSeriesStartAngle: function (l, d) {
        var h = 90;
        var j = 360 * this.seriesGap;
        var c = 0;
        var a = [];
        for (var g = 0; g < this.dataSeries.length; g++) {
            var f = this.dataSeries[g];
            if (f.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                a[g] = c++
            }
        }
        var k = j / (c);
        var b = 0;
        for (var e = 0; e < d; e++) {
            b += this.getPercent(e, l) * (360 - j)
        }
        h += b + k * a[d] + k / 2;
        return h
    }, draw: function (c, f, e) {
        var b = c[1];
        this.drawInfo(c);
        for (var d = this.ring4cate.length - 1; d >= 0; d--) {
            this._drawBackHalf(d, b)
        }
        for (var d = 0; d < this.ring4cate.length; d++) {
            this._drawFrontHalf(d, b)
        }
        var a = FR.Chart.currentDivKey;
        this.drawMarkersLabelAfterSeriesAnimateDraw(b, a);
        FR.Chart.GraphHelper.isDrawingEnd = true
    }, _drawBackHalf: function (c, b) {
        var a = this.ring4cate[c].calculateBackHalf();
        a.drawSide(b);
        a.drawBack(b);
        a.drawPositive(b);
        a.drawTop(b)
    }, _drawFrontHalf: function (b, a) {
        var c = this.ring4cate[b].calculateFrontHalf();
        c.drawSide(a);
        c.drawBack(a);
        c.drawPositive(a);
        c.drawTop(a)
    }
});
FR.Chart.PiePlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.PiePlotGlyph.superclass.initConstants.apply(this, [a]);
        this.MAX_SERIES_MODE = 5;
        this.OUTSIDE_LABEL_RADIUS_COEFFICIENT = 1.3;
        this.separatePercent = 10;
        this.radius = 0;
        this.maxLabelWidth = 0;
        this.radiusPercent = 0.9;
        this.leftUp = [];
        this.leftDown = [];
        this.rightUp = [];
        this.rightDown = [];
        this.adjustAngle = 0.1
    }, seriesLabelsInSide: function (a) {
        if (!this.conditionCollection || !a) {
            return true
        }
        var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (!b) {
            return true
        }
        return b.position === FR.Chart.Constants.INSIDE
    }, installSeriesWithOptionData: function (f, c) {
        this.dataSeries = [];
        for (var b = 0; b < f.length; b++) {
            var e = f[b];
            var d = new FR.Chart[c.dataSeries]();
            d.points = [];
            d.seriesIndex = b;
            d.seriesName = e[0];
            var a = new FR.Chart[c.dataPoint]();
            a.categoryIndex = 0;
            a.seriesIndex = b;
            a.seriesName = e[0];
            a.value = e[1];
            d.points[0] = a;
            this.dataSeries[b] = d
        }
    }, getDataPointByPara: function (b) {
        var a = b[0];
        for (var d = 0; d < this.dataSeries.length; d++) {
            var c = this.dataSeries[d];
            if (FR.equals(a, c.seriesName) && c.points[0]) {
                return c.points[0]
            }
        }
    }, layoutAxisGlyph: function () {
    }, isExistOuterLabels: function () {
        return this.leftUp.length > 0 || this.leftDown.length > 0 || this.rightUp.length > 0 || this.rightDown.length > 0
    }, doAnimate4SeriesDraw: function (a, g, f) {
        var b = g.getDrawSequence();
        for (var d = 0; d < g.dataSeries.length; d++) {
            g.dataSeries[b[d]].drawAnimateGlyph(a, f)
        }
        for (var d = 0; d < g.dataSeries.length; d++) {
            var e = g.dataSeries[b[d]];
            var h = e.points;
            for (var c = 0; c < e.getDataPointCount(); c++) {
                if (h[c].isBorderDefault(f)) {
                    h[c].drawOnlyBorder(a, f)
                }
            }
        }
        for (var d = 0; d < g.dataSeries.length;
             d++) {
            var e = g.dataSeries[b[d]];
            var h = e.points;
            for (var c = 0; c < e.getDataPointCount(); c++) {
                if (!h[c].isBorderDefault(f)) {
                    h[c].drawOnlyBorder(a, f)
                }
            }
        }
    }, layoutDataSeriesGlyph: function () {
        for (var a = 0; this.dataSeries[0] && a < this.dataSeries[0].points.length; a++) {
            this.dealEachCategory(a)
        }
        this.dealLabelBoundsInOrder()
    }, dealLabelBoundsOutPlotBounds: function (c, p, h, b, a, s) {
        if (!c.isShowLabel || c.dataLabel === null || c.dataLabel.text === null || c.dataLabel.text.length <= 0) {
            return
        }
        var j = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), c);
        if (!j.isShowGuidLine) {
            FR.Chart.PiePlotGlyph.superclass.dealLabelBoundsOutPlotBounds.apply(this, [c, p, h, b, a, s])
        }
        if (p.x >= h.x && p.x + p.width <= h.x + h.width) {
            return
        }
        var m = p.width;
        if (p.x < h.x) {
            m = p.x + p.width - h.x
        } else {
            if (p.x + p.width > h.x + h.width) {
                m = (h.x + h.width) - p.x
            }
        }
        var k = FR.Chart.TextUtils.changeAllReline2Normal(c.dataLabel.text);
        k = k.split("\n");
        var l = j.textAttr;
        if (l == null) {
            l = new FR.Chart.TextAttr()
        }
        var g = [];
        for (var f = 0; f < k.length; f++) {
            var d = k[f];
            var e = 0;
            for (; e < d.length; e++) {
                var r = d.substring(0, e) + "...";
                var n = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(r, l);
                if (n.width > m) {
                    break
                }
            }
            if (e === 0) {
                g[f] = "..."
            } else {
                if (e == d.length) {
                    g[f] = d
                } else {
                    g[f] = d.substring(0, e - 1) + "..."
                }
            }
        }
        c.showLabel = "";
        for (var o = 0; o < g.length; o++) {
            if (o == g.length - 1) {
                c.showLabel += g[o]
            } else {
                c.showLabel += g[o] + "\n"
            }
        }
        var q = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c.showLabel, l);
        if (p.x < h.x) {
            p.setRect(h.x, p.y, q.width, p.height)
        } else {
            p.setRect(p.x, p.y, q.width, p.height)
        }
        c.dataLabel.bounds = p
    }, dealEachCategory: function (a) {
        this.initLabelData(a);
        this.dealWithDataSeries(a)
    }, initLabelData: function (a) {
        this.radius = this.getPieDimension(a) / (2 + 2 * this.separatePercent * 0.01);
        if (this.plotStyle == FR.Chart.Constants.STYLE_TRANSPARENT) {
            this.radius -= 4
        }
        this.maxLabelWidth = this.getMaxLabelWidth(a);
        this.getSeriesCountWithQuadrant(a)
    }, dealWithDataSeries: function (e) {
        this.arc3DStyleBase = null;
        this.arcOuterBase = null;
        var f = new FR.Chart.BoundsManager();
        for (var b = 0; b < this.dataSeries.length; b++) {
            var c = this.dataSeries[b];
            var a = c.points[e];
            a.lastGlyph = this.getLastDataPointGlyph(a);
            if (a.valueIsNull || c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                a.glyph = null;
                a.lastGlyph = null;
                continue
            }
            a.glyph = this.calculateShapeGlyph4DifferentSub(a);
            if (!this.subType) {
                a.dataPointStyle = null;
                if (this.plotStyle !== FR.Chart.Constants.STYLE_NONE) {
                    var d = a.glyph;
                    this.addChartStyle4DataPoint(this.plotStyle, a, d);
                    d.dataPointStyle = a.dataPointStyle
                }
            }
        }
        this.dealWithCategoryLabels(e, f)
    }, dealWithCategoryLabels: function (a, b) {
        if (this.isExistOuterLabels()) {
            this.dealOutSideLabels(a);
            this.dealLabelBoundsOverLay(this.leftUp, true, 90, 180);
            this.dealLabelBoundsOverLay(this.leftDown, true, 180, 270);
            this.dealLabelBoundsOverLay(this.rightUp, false, 0, 90);
            this.dealLabelBoundsOverLay(this.rightDown, false, 270, 360)
        }
        this.dealInsideLabels(a, b)
    }, dealOutSideLabels: function (b) {
        var a = 0;
        a = Math.max(a, this.dealEachArea(this.leftUp));
        a = Math.max(a, this.dealEachArea(this.leftDown));
        a = Math.max(a, this.dealEachArea(this.rightUp));
        a = Math.max(a, this.dealEachArea(this.rightDown));
        if (a === 0) {
            return
        }
        this.radiusPercent -= 0.05;
        if (this.radiusPercent >= 0.5) {
            this.dealEachCategory(b)
        } else {
            this.radiusPercent += 0.05
        }
    }, isLabelBoundsOutPlotBounds: function (a, d, f) {
        if (a == null) {
            return false
        }
        var e = 3;
        var c = this.getBounds().height / 2 + this.getBounds().y;
        var b = this.getBounds().height + this.getBounds().y;
        if (d >= 180 && f <= 360) {
            return a.y < c + e || a.y + a.height + e > this.bounds.y + this.bounds.height
        } else {
            return a.y < this.bounds.y - e || a.y + a.height > c
        }
    }, dealLabelBoundsOverLay: function (h, j, e, a) {
        var k = new FR.Chart.GeneralPath();
        var c = true;
        for (var f = 0; f < h.length; f++) {
            var b = j ? h[f] : h[h.length - 1 - f];
            var d = b.dataLabel;
            if (d == null || d.text == null || d.text.length === 0) {
                continue
            }
            if (!b.isShowLabel) {
                continue
            }
            var g = new FR.Chart.Bounds(d.bounds.x, d.bounds.y, d.bounds.width, d.bounds.height);
            if (k.verticalIntersects(g.y, g.height) || this.isLabelBoundsOutPlotBounds(g, e, a)) {
                if (!this.adjustLabelBoundsY(j, k, b, g, e, a)) {
                    c = false
                }
            } else {
                k.append(g, false)
            }
        }
        if (c) {
            return
        }
        this.moveLabelUp(h, j, e, a)
    }, moveLabelUp: function (j, l, e, a) {
        var m = new FR.Chart.GeneralPath();
        var c = l ? a : e;
        for (var g = 0; g < j.length; g++) {
            var b = l ? j[j.length - 1 - g] : j[g];
            var d = b.dataLabel;
            if (d == null || d.text == null || d.text.length === 0) {
                continue
            }
            if (!b.isShowLabel) {
                continue
            }
            var h = b.dataLabel.bounds;
            var k = !this.isLabelBoundsInRange(b, h, e, a) || this.isLabelBoundsOutPlotBounds(h, e, a);
            while (!this.isLabelBoundsInRange(b, h, e, a) || this.isLabelBoundsOutPlotBounds(h, e, a)) {
                c += (l ? -1 : 1) * this.adjustAngle;
                this.calculateLabelBoundsWithAngle(c, b, h);
                if (c < e || c > a) {
                    break
                }
            }
            if (k) {
                b.dataLabel.bounds = h;
                var f = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), b);
                if (f.isShowGuidLine) {
                    this.relayLabelLine(b, h, c)
                }
            }
            if (m.verticalIntersects(h.y, h.height)) {
                c = this.adjustLabel4MoveUp(c, !l, m, b, h, e, a)
            } else {
                m.append(h, false)
            }
        }
    }, isLabelBoundsInRange: function (b, h, f, a) {
        var j = 3;
        var i = this.getCenterPoint(b.seriesIndex, b.categoryIndex);
        var e = h.y + h.height <= this.bounds.y + this.bounds.height;
        var d = h.y + h.height <= i.y - j;
        var c = h.y + j >= this.bounds.y;
        var g = h.y >= i.y + j;
        if (f === 0 && a === 90) {
            return c && d && h.x >= i.x
        } else {
            if (f === 90 && a === 180) {
                return h.x + h.width <= i.x && d && c
            } else {
                if (f === 180 && a === 270) {
                    return g && e && h.x + h.width <= i.x
                } else {
                    return g && e && h.x >= i.x
                }
            }
        }
    }, adjustLabel4MoveUp: function (d, f, h, a, b, e, g) {
        while (h.verticalIntersects(b.y, b.height) || this.isLabelBoundsOutPlotBounds(b, e, g)) {
            d += (f ? 1 : -1) * this.adjustAngle;
            this.calculateLabelBoundsWithAngle(d, a, b);
            if (d < e || d > g) {
                break
            }
        }
        a.dataLabel.bounds = b;
        h.append(b, false);
        if (d < e || d > g || !this.isLabelBoundsInRange(a, b, e, g) || this.isLabelBoundsOutPlotBounds(b, e, g)) {
            a.leadLine = null;
            return d
        }
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (!c.isShowGuidLine || !a.isShowLabel) {
            return d
        }
        this.relayLabelLine(a, b, d);
        return d
    }, adjustLabelBoundsY: function (f, h, a, b, e, g) {
        var d = this.getCenterAngle4DataPoint(a.categoryIndex, a.seriesIndex);
        while (h.verticalIntersects(b.y, b.height) || this.isLabelBoundsOutPlotBounds(b, e, g)) {
            d += (f ? 1 : -1) * this.adjustAngle;
            this.calculateLabelBoundsWithAngle(d, a, b);
            if (d < e || d > g) {
                break
            }
        }
        a.dataLabel.bounds = b;
        h.append(b, false);
        if (d < e || d > g || !this.isLabelBoundsInRange(a, b, e, g) || this.isLabelBoundsOutPlotBounds(b, e, g)) {
            a.leadLine = null;
            return false
        }
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (!c.isShowGuidLine || !a.isShowLabel) {
            return true
        }
        this.relayLabelLine(a, b, d);
        return true
    }, relayLabelLine: function (b, f, c) {
        var i = new FR.Chart.GeneralPath();
        var a = 0;
        var j = 0;
        c = this.getCenterAngle4DataPoint(b.categoryIndex, b.seriesIndex);
        if (c >= 90 && c < 270) {
            a = f.x + f.width + 2
        } else {
            a = f.x - 2
        }
        j = f.y + f.height / 2 + 3;
        i.moveTo(a, j);
        if (c >= 90 && c < 270) {
            a += 0.1 * this.radius
        } else {
            a -= 0.1 * this.radius
        }
        i.lineTo(a, j);
        var g = this.getCenterPoint(b.seriesIndex, b.categoryIndex);
        var d = this.radius + 2;
        a = g.x + d * Math.cos((c / 180) * Math.PI);
        j = g.y - d * Math.sin((c / 180) * Math.PI);
        i.lineTo(a, j);
        var h = new FR.Chart.FoldLine(i);
        b.leadLine = h;
        var e = new FR.Chart.AttrLineStyle();
        e.lineStyle = FR.Chart.Constants.LINE_THIN;
        h.lineStyleInfo.attrLineStyle = e
    }, dealEachArea: function (f) {
        var e = this.bounds.x + this.bounds.width;
        var a = this.bounds.x;
        var d = 0;
        this.checkPointsShowLabel(f);
        for (var c = 0; c < f.length; c++) {
            var g = f[c].dataLabel;
            if (f[c].glyph == null || g == null || g.text == null || g.text.length === 0) {
                continue
            }
            var b = new FR.Chart.Bounds();
            this.dealOutsideLabelBoundsWhenNormal(b, f[c]);
            if (b.x < a) {
                d = a - b.x
            }
            if (b.x + b.width > e) {
                d = b.x + b.width - e
            }
        }
        return d
    }, dealOutsideLabelBoundsWhenNormal: function (b, a) {
        this.dealWithLabelLine(a);
        var c = this.getCenterAngle4DataPoint(a.categoryIndex, a.seriesIndex);
        this.calculateLabelBoundsWithAngle(c, a, b);
        a.dataLabel.bounds = b
    }, dealWithLabelLine: function (a) {
        var h = this.getCenterPoint(a.seriesIndex, a.categoryIndex);
        var c = this.getCenterAngle4DataPoint(a.categoryIndex, a.seriesIndex);
        var j = new FR.Chart.GeneralPath();
        var f = this.radius + 3;
        var d = h.x + f * Math.cos((c / 180) * Math.PI);
        var b = h.y - f * Math.sin((c / 180) * Math.PI);
        j.moveTo(d, b);
        f = this.radius * 1.2;
        d = h.x + f * Math.cos((c / 180) * Math.PI);
        b = h.y - f * Math.sin((c / 180) * Math.PI);
        b += 3;
        j.lineTo(d, b);
        var c = this.getCenterAngle4DataPoint(a.categoryIndex, a.seriesIndex);
        if (c >= 90 && c < 270) {
            d -= this.radius * 0.1
        } else {
            d += this.radius * 0.1
        }
        j.lineTo(d, b);
        var e = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (e.isShowGuidLine && a.isShowLabel) {
            var i = new FR.Chart.FoldLine(j);
            a.leadLine = i;
            var g = new FR.Chart.AttrLineStyle();
            g.lineStyle = FR.Chart.Constants.LINE_THIN;
            i.lineStyleInfo.attrLineStyle = g
        }
    }, calculateLabelBoundsWithAngle: function (d, b, h) {
        var i = this.getCenterPoint(b.seriesIndex, b.categoryIndex);
        var g = this.getLabelDim(b);
        var f = this.radius * 1.2;
        var e = i.x + f * Math.cos(Math.PI * d / 180);
        var c = i.y - f * Math.sin(Math.PI * d / 180);
        var a = 0.1 * this.radius + 2;
        if (d >= 90 && d < 270) {
            h.setRect(e - a - g.width, c - g.height / 2, g.width, g.height)
        } else {
            h.setRect(e + a, c - g.height / 2, g.width, g.height)
        }
    }, createDataLabel4DataPointWithCondition: function (a, c, d) {
        var b = a.getDataPointLabelString(c, d);
        if (a.isCustomLabel && a.dataLabel) {
            b = a.dataLabel.text
        }
        var e = new FR.Chart.TextGlyph();
        e.text = b;
        e.textAttr = c.textAttr;
        a.dataLabel = e;
        a.showLabel = b
    }, checkPointsShowLabel: function (d) {
        var c = 0;
        var a;
        for (var b = 0; b < d.length; b++) {
            if (d[b].glyph == null) {
                d[b].isShowLabel = false;
                continue
            }
            var a = d[b];
            var e = d[b].dataLabel;
            if (e != null && e.text != null && e.text.length > 0) {
                c += this.getLabelDim(d[b]).height
            }
        }
        if (c > this.halfHeight4Shape(a)) {
            this.removeAngleExtendMinPoint(d);
            this.checkPointsShowLabel(d)
        }
    }, halfHeight4Shape: function () {
        return this.radius * 1.2
    }, removeAngleExtendMinPoint: function (e) {
        if (e == null || e.length <= 0) {
            return
        }
        var b = -1;
        for (var c = 0; c < e.length; c++) {
            var d = 0;
            var a = 0;
            if (e[c].glyph == null) {
                e[c].isShowLabel = false;
                continue
            }
            b = b == -1 ? c : b;
            if (e[c].glyph.shape instanceof FR.Chart.Arc2D) {
                d = e[c].glyph.shape.getExtent()
            }
            if (e[b].glyph.shape instanceof FR.Chart.Arc2D) {
                a = e[b].glyph.shape.getExtent()
            }
            if (d < a) {
                b = c
            }
        }
        if (e[b]) {
            e[b].isShowLabel = false;
            e.splice(b, 1)
        }
    }, dealInsideLabels: function (d, g) {
        for (var b = 0; b < this.dataSeries.length; b++) {
            var c = this.dataSeries[b];
            var a = c.points[d];
            if (a.valueIsNull || c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                a.glyph = null;
                continue
            }
            if (this.isOutsideLabel(a)) {
                continue
            }
            var f = a.dataLabel;
            if (f == null) {
                continue
            }
            var e = f.text;
            if (e != null && e.length > 0) {
                this.dealInsideLabelBounds(a, g)
            }
        }
    }, calculateShapeGlyph4DifferentSub: function (a) {
        var b = new FR.Chart.ShapeGlyph();
        b.shape = this.getArc2D(a);
        b.info.dealCondition(this.conditionCollection, a, this.createColors4Series());
        b.toolTipBackground = b.info.getBackground();
        return b
    }, getArc2D: function (a) {
        var d = a.categoryIndex;
        var b = a.seriesIndex;
        var c = this.getSeriesStartAngle(d, b) % 360;
        var e = this.getCenterPoint(b, d);
        return this.getDataPointShape(e, b, d, c, this.radius, a.isSeparateOut)
    }, getCenterPoint: function (b, d) {
        var c = this.getBounds().width / this.dataSeries[0].points.length;
        var a = d * c + c / 2 + this.getBounds().x;
        return new FR.Chart.Point2D(a, this.getBounds().height / 2 + this.getBounds().y)
    }, addChartStyle4DataPoint: function (i, a, c, h) {
        if (c.info.getBackground().color) {
            var d = c.info.getBackground().color;
            var e = c.shape;
            var j = {"color": d, "arcShape": e, "avoidOriginDraw": true};
            if (i == FR.Chart.Constants.STYLE_3D) {
                if (!this.arc3DStyleBase) {
                    this.arc3DStyleBase = new FR.Chart.Arc3DStyleBase(this.get3DStyleBaseShape())
                }
                a.dataPointStyle = new FR.Chart.ArcPlane3DStyle(j);
                if (!a.isSeparateOut) {
                    var b = (this.separatePercent / 100 * this.radius) / 6;
                    var g = this.getSeriesStartAngle(a.categoryIndex, a.seriesIndex);
                    var f = this.getHalfAngle(g, a.seriesIndex, a.categoryIndex);
                    c.shape.x += b * Math.cos((360 - f) * Math.PI / 180);
                    c.shape.y += b * Math.sin((360 - f) * Math.PI / 180)
                }
            } else {
                if (i == FR.Chart.Constants.STYLE_OUTER) {
                    if (FR.Browser.isIE8Before()) {
                        a.dataPointStyle = null
                    } else {
                        if (!this.arcOuterBase) {
                            this.arcOuterBase = new FR.Chart.ArcOuterBase(this.radius, this.getCenterPoint(0, 0))
                        }
                        a.dataPointStyle = new FR.Chart.ArcTopDownShadeStyle(j);
                        c.shape.radius = this.radius * 0.85
                    }
                } else {
                    if (i == FR.Chart.Constants.STYLE_SHADE) {
                        a.dataPointStyle = new FR.Chart.ArcTopDownShadeStyle(j)
                    } else {
                        if (i == FR.Chart.Constants.STYLE_TRANSPARENT) {
                            a.dataPointStyle = new FR.Chart.ArcTransparentChartStyle(j)
                        }
                    }
                }
            }
        }
    }, get3DStyleBaseShape: function () {
        var a = this.radius * 11 / 12;
        var b = this.getCenterPoint(0, 0);
        return new FR.Chart.Arc2D(b.x, b.y, a, 0, 360)
    }, isPieSeperateOut: function (d) {
        var e = false;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var c = this.dataSeries[b];
            var a = c.points[d];
            if (a.isSeparateOut) {
                e = true;
                break
            }
        }
        return e
    }, dealLeadLineSeries: function () {
        for (var e = 0; this.dataSeries[0] && e < this.dataSeries[0].points.length; e++) {
            for (var b = 0; b < this.dataSeries.length; b++) {
                var d = this.dataSeries[b];
                var a = d.points[e];
                if (a.valueIsNull || d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    a.glyph = null;
                    continue
                }
                var c = this.getSeriesStartAngle(e, b);
                var f = this.getHalfAngle(c, b, e);
                if (a.glyph && a.glyph.shape) {
                    if (a.glyph.shape instanceof FR.Chart.Arc2D) {
                        this.dealLeadLine(a.glyph.shape, a, f % 360)
                    }
                }
            }
        }
    }, getPieDimension: function (c) {
        var d = this.getBounds();
        var b = d.width / this.dataSeries[0].points.length;
        var a = 0;
        if (b > d.height) {
            a = d.height
        } else {
            a = b
        }
        a = this.deal4BestRad(a, c);
        return a
    }, deal4BestRad: function (c, b) {
        var a = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), this.dataSeries[0].points[b]);
        if (a.position == FR.Chart.Constants.OUTSIDE) {
            c *= this.radiusPercent;
            if (this.getCategoryCount() > 1) {
                c *= 0.8
            }
        }
        return c
    }, getDataPointShape: function (i, d, j, b, f, e) {
        var a = this.separatePercent / 100 * f;
        if (!e) {
            a = 0
        }
        if (this.plotStyle == FR.Chart.Constants.STYLE_TRANSPARENT) {
            a += 2
        }
        var h = this.getHalfAngle(b, d, j);
        var g = b % 360;
        var c = this.getPercent(d, j) * 360;
        var k = new FR.Chart.Arc2D(i.x + a * Math.cos((360 - h) * Math.PI / 180), i.y + a * Math.sin((360 - h) * Math.PI / 180), f, g, c);
        return k
    }, dealLeadLine: function (f, i, q) {
        var s = i.dataLabel;
        if (s == null) {
            return
        }
        var j = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), i);
        var e = s.text;
        if (e != null && s.bounds != null && j.isShowGuidLine) {
            var h = s.bounds;
            if (f instanceof FR.Chart.Arc2D) {
                var l = f.getArcPoint(-q)
            } else {
                var l = f.top().getMiddlePoint()
            }
            var p = l.x;
            var o = l.y;
            var b = h.x;
            var a = h.y;
            var n = h.x;
            var m = h.y;
            var c = this.bounds.height * 0.01;
            q = q % 360;
            var g = f.containsPoint(h.x, h.y) || f.containsPoint(h.x + h.width, h.y) || f.containsPoint(h.x, h.y + h.height) || f.containsPoint(h.x + h.width, h.y + h.height);
            if (!g) {
                if (p < b - c) {
                    n = h.x - c;
                    m = h.y + h.height / 2;
                    b = h.x;
                    a = h.y + h.height / 2
                } else {
                    if (p > b + h.width + c) {
                        n = h.x + h.width;
                        m = h.y + h.height / 2;
                        b = h.x + h.width - c;
                        a = h.y + h.height / 2
                    } else {
                        if (q > 80 && q < 100 || q > 260 && q < 280) {
                            if (o > h.y + h.height) {
                                n = h.x + h.width / 2;
                                m = h.y + h.height + c;
                                b = h.x + h.width / 2;
                                a = h.y + h.height
                            } else {
                                if (o < h.y) {
                                    n = h.x + h.width / 2;
                                    m = h.y - c;
                                    b = h.x + h.width / 2;
                                    a = h.y
                                } else {
                                    return
                                }
                            }
                        } else {
                            if (q >= 100 && q <= 260) {
                                n = h.x + h.width;
                                m = h.y + h.height / 2;
                                b = h.x + h.width - c;
                                a = h.y + h.height / 2
                            } else {
                                n = h.x + c;
                                m = h.y + h.height / 2;
                                b = h.x + c * 2;
                                a = h.y + h.height / 2
                            }
                        }
                    }
                }
                var k = new FR.Chart.GeneralPath();
                k.moveTo(p, o);
                k.curveTo(n, m, (p + b) * 0.5, (o + a) * 0.5, b, a);
                var r = new FR.Chart.FoldLine(k);
                i.leadLine = r;
                var d = new FR.Chart.AttrLineStyle();
                d.lineStyle = FR.Chart.Constants.LINE_THIN;
                r.lineStyleInfo.attrLineStyle = d
            } else {
                i.leadLine = null
            }
        }
    }, getLabelRadius: function (e, d, b, g) {
        var h = g.y + g.height / 2;
        var f = Math.sin(Math.PI * b / 180);
        var i = 0;
        if (f === 0) {
            i = d - h
        } else {
            i = (d - h) / f
        }
        i = Math.abs(i);
        var c = e + i * Math.cos(Math.PI * b / 180);
        var a = d - i * Math.sin(Math.PI * b / 180);
        if (b >= 90 && b <= 270) {
            if (c <= g.x + g.width) {
                c = g.x + g.width;
                a = g.y + g.height / 2
            }
        } else {
            if (c >= g.x) {
                c = g.x;
                a = g.y + g.height / 2
            }
        }
        return new FR.Chart.Point2D(c, a)
    }, avoidCoverLabelBounds: function (a, e, h, d, g, f) {
        if (e == null) {
            return null
        }
        if (h == null || d == null || g == null || f == null) {
            return FR.Chart.PiePlotGlyph.superclass.avoidCoverLabelBounds.apply(this, [a, e])
        }
        var b = h;
        this.whileTmp(a, e, b, g, f, d, 0.5);
        if (!a.isInteract(e)) {
            var c = new FR.Chart.Bounds(e.x, e.y, e.width + 2, e.height);
            a.addBounds(c);
            return c
        }
        return null
    }, whileTmp: function (k, a, h, j, i, e, d) {
        if (e == null || d == null) {
            return FR.Chart.PiePlotGlyph.superclass.whileTmp.apply(this, [k, a, h, j, i])
        }
        var f = a.clone();
        var g = 0;
        while (k.isInteract(a)) {
            h += d;
            if (g > 360) {
                a.setRect(f.x, f.y, f.width, f.height);
                break
            }
            var c = j + e * Math.cos(Math.PI * h / 180);
            var b = i - e * Math.sin(Math.PI * h / 180);
            if (h > 90 && h < 225) {
                a.setRect(c - a.width, b - a.height / 2, a.width, a.height)
            } else {
                if (h >= 225 && h < 270) {
                    a.setRect(c - a.width, b - a.height, a.width, a.height)
                } else {
                    if (h >= 270 && h < 315) {
                        a.setRect(c, b - a.height, a.width, a.height)
                    } else {
                        a.setRect(c, b - a.height / 2, a.width, a.height)
                    }
                }
            }
            g += d
        }
    }, isOutsideLabel: function (a) {
        var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        return b.position == FR.Chart.Constants.OUTSIDE || b.isShowGuidLine
    }, dealOutsideLabelBounds: function (a, h) {
        var b = a.seriesIndex;
        var f = a.categoryIndex;
        var c = new FR.Chart.Bounds();
        var d = this.getSeriesStartAngle(f, b);
        var g = this.getHalfAngle(d, b, f) % 360;
        if (this instanceof FR.Chart.Pie3DPlotGlyph) {
            g = a.getShape().top().getMiddleAngle();
            g = (180 - g + 360) % 360
        }
        var e = 0;
        if (g >= 90 && g < 180) {
            e = this.leftUp.length
        } else {
            if (g >= 180 && g < 270) {
                e = this.leftDown.length
            } else {
                if (g >= 270 && g <= 360) {
                    e = this.rightDown.length
                } else {
                    e = this.rightUp.length
                }
            }
        }
        if (e >= this.MAX_SERIES_MODE) {
            this.dealOutsideLabelBoundsWithLargeSeriesSize(c, g, a)
        } else {
            this.dealOutsideLabelBoundsWithLittleSeriesSize(c, g, a, h)
        }
        a.dataLabel.bounds = c
    }, dealLabelBounds: function (a, d) {
        var c = a.dataLabel;
        if (c == null) {
            return
        }
        var b = c.text;
        if (b != null && b.length > 0) {
            if (this.isOutsideLabel(a)) {
                this.dealOutsideLabelBounds(a, d)
            } else {
                this.dealInsideLabelBounds(a, d)
            }
        }
    }, dealInsideLabelBounds: function (f, p) {
        var n = f.seriesIndex;
        var s = f.categoryIndex;
        var k = this.getCenterPoint(n, s);
        var m = this.getLabelDim(f);
        var u = m.width;
        var l = m.height;
        var e = 0.5;
        var a = this.changeRadius(s, n);
        var t = f.dataLabel;
        var g = this.getSeriesStartAngle(s, n) % 360;
        var r = this.getHalfAngle(g, n, s) % 360;
        if (r == g) {
            this.dealOutsideLabelBounds(f, p);
            return
        }
        var h = this.getDataPointShape(k, n, s, g, a, false);
        var q = a * Math.cos(Math.PI * r / 180);
        var o = a * Math.sin(Math.PI * r / 180);
        for (e; e < 1; e += 0.1) {
            var c = k.x + q * e;
            var b = k.y - o * e;
            var j = c - u / 2, i = b - l / 2;
            var d = new FR.Chart.Bounds(j, i, m.width, m.height);
            if (h.containsPoint(j, i) && h.containsPoint(j + m.width, i) && h.containsPoint(j, i + m.height) && h.containsPoint(j + m.width, i + m.height)) {
                t.bounds = d;
                break
            }
        }
        if (e >= 0.9) {
            t.bounds = null
        }
    }, dealOutsideLabelBoundsWithLittleSeriesSize: function (l, n, e, m) {
        var k = e.seriesIndex;
        var o = e.categoryIndex;
        var h = this.getCenterPoint(k, o);
        var j = this.getLabelDim(e);
        var r = j.width;
        var i = j.height;
        var g = h.x;
        var f = h.y;
        var c = this.changeRadius(o, k);
        var d = g + c * Math.cos(Math.PI * n / 180);
        var b = f - c * Math.sin(Math.PI * n / 180);
        var q = this.getBounds().x;
        var p = this.getBounds().y;
        var a = (n >= 90 && n <= 270) ? "right" : "left";
        d += a == "left" ? 20 : -20;
        if (n > 90 && n < 225) {
            l.setRect(Math.max(q, d - r), Math.max(p, b - i / 2), r, i)
        } else {
            if (n >= 225 && n < 270) {
                l.setRect(Math.max(q, d - r), Math.max(p, b - i / 2), r, i)
            } else {
                if (n >= 270 && n < 315) {
                    l.setRect(d, Math.max(p, b - i / 2), r, i)
                } else {
                    l.setRect(d, Math.max(p, b), r, i)
                }
            }
        }
        l = this.avoidCoverLabelBounds(m, l, n, c, g, f)
    }, changeRadius: function (b, a) {
        return this.radius * this.OUTSIDE_LABEL_RADIUS_COEFFICIENT + this.separatePercent * this.radius / 100
    }, getLabelDim: function (a) {
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        var b = c.textAttr;
        if (b == null) {
            b = new FR.Chart.TextAttr()
        }
        return FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(a.dataLabel.text, b)
    }, getLabelMargin: function (a, b) {
        return Math.max((this.bounds.height / 2 - b * a) / (a + 1), 1)
    }, dealOutsideLabelBoundsWithLargeSeriesSize: function (j, c, a) {
        var k = a.categoryIndex;
        var i = this.getLabelDim(a);
        var h = i.width;
        var b = i.height;
        var l = this.bounds.width / this.getCategoryCount();
        var n = (l - this.getPieDimension(k)) / 2;
        var e = (n - this.maxLabelWidth) / 2;
        var g = 0;
        var f = 0;
        var d = 0;
        if (c >= 90 && c < 180) {
            g = this.getLabelMargin(this.leftUp.length, b);
            f = (e > 0 ? (n - e - h) : (l * 0.01)) + l * k;
            var m = this.leftUp.indexOf(c);
            d = m * (g + b) + g;
            if (m >= 0 && m < this.leftUp.length) {
                this.leftUp[m] = Number.MAX_VALUE
            }
        } else {
            if (c >= 180 && c < 270) {
                g = this.getLabelMargin(this.leftDown.length, b);
                f = (e > 0 ? (n - e - h) : (l * 0.01)) + l * k;
                var m = this.leftDown.indexOf(c);
                d = m * (g + b) + g + this.bounds.height / 2;
                if (m >= 0 && m < this.leftDown.length) {
                    this.leftDown[m] = Number.MAX_VALUE
                }
            } else {
                if (c >= 270 && c < 360) {
                    g = this.getLabelMargin(this.rightDown.length, b);
                    f = (e > 0 ? (n + this.getPieDimension(k) + e) : (l * 0.99 - h)) + l * k;
                    var m = this.rightDown.indexOf(c);
                    d = this.bounds.height - m * (b + g);
                    if (m >= 0 && m < this.rightDown.length) {
                        this.rightDown[m] = Number.MAX_VALUE
                    }
                } else {
                    g = this.getLabelMargin(this.rightUp.length, b);
                    f = (e > 0 ? (n + this.getPieDimension(k) + e) : (l * 0.99 - h)) + l * k;
                    var m = this.rightUp.indexOf(c);
                    d = this.bounds.height / 2 - m * (b + g);
                    if (m >= 0 && m < this.rightUp.length) {
                        this.rightUp[m] = Number.MAX_VALUE
                    }
                }
            }
        }
        j.setRect(f + this.getBounds().x, d + this.getBounds().y, h, b)
    }, getSeriesCountWithQuadrant: function (c) {
        this.leftUp.length = 0;
        this.leftDown.length = 0;
        this.rightDown.length = 0;
        this.rightUp.length = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var d = this.getCenterAngle4DataPoint(c, b);
            if (this.dataSeries[b].points[c].valueIsNull) {
                continue
            }
            if (!this.isOutsideLabel(this.dataSeries[b].points[c])) {
                continue
            }
            this.dataSeries[b].points[c].isShowLabel = true;
            var a = this.dataSeries[b].points[c];
            if (d >= 90 && d < 180) {
                this.leftUp.push(a)
            } else {
                if (d >= 180 && d < 270) {
                    this.leftDown.push(a)
                } else {
                    if (d >= 270 && d < 360) {
                        this.rightDown.push(a)
                    } else {
                        this.rightUp.push(a)
                    }
                }
            }
        }
        this._sortList()
    }, getCenterAngle4DataPoint: function (b, a) {
        return this.getHalfAngle(this.getSeriesStartAngle(b, a), a, b) % 360
    }, _sortList: function () {
        this.bubbleSort(this.leftUp);
        this.bubbleSort(this.rightUp);
        this.bubbleSort(this.leftDown);
        this.bubbleSort(this.rightDown)
    }, bubbleSort: function (e) {
        var a = 0;
        var d = e.length - 1;
        var c = 0;
        var b = 0;
        while (a < d) {
            for (b = a; b < d; ++b) {
                if (this.getCenterAngle4DataPoint(e[b].categoryIndex, e[b].seriesIndex) > this.getCenterAngle4DataPoint(e[b + 1].categoryIndex, e[b + 1].seriesIndex)) {
                    c = e[b];
                    e[b] = e[b + 1];
                    e[b + 1] = c
                }
            }
            --d;
            for (b = d; b > a; --b) {
                if (this.getCenterAngle4DataPoint(e[b].categoryIndex, e[b].seriesIndex) < this.getCenterAngle4DataPoint(e[b - 1].categoryIndex, e[b - 1].seriesIndex)) {
                    c = e[b];
                    e[b] = e[b - 1];
                    e[b - 1] = c
                }
            }
            ++a
        }
    }, getMaxLabelWidth: function (e) {
        var h = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var a = this.dataSeries[b].points[e];
            if (a == null || a.dataLabel == null) {
                continue
            }
            var g = a.dataLabel.text;
            if (g != null && g.length > 0) {
                var d = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
                if (d != null) {
                    var c = d.textAttr;
                    if (c == null) {
                        c = new FR.Chart.TextAttr()
                    }
                    var f = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(g, c);
                    h = Math.max(h, f.width)
                }
            }
        }
        return h
    }, getSeriesStartAngle: function (d, a) {
        var c = 90;
        for (var b = 0; b < a; b++) {
            c = c + this.getPercent(b, d) * 360
        }
        return c
    }, getHalfAngle: function (b, a, c) {
        return b + 0.5 * this.getPercent(a, c) * 360
    }, getPercent: function (c, d) {
        if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return 0
        }
        var b = this.getTotalValue(d);
        if (b <= 0) {
            return 0
        }
        var a = this.dataSeries[c].points[d];
        return Math.abs(a.value) / b
    }, getTotalValue: function (e) {
        var c = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var d = this.dataSeries[b];
            var a = d.points[e];
            if (a == null) {
                continue
            }
            if (a.valueIsNull || d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            c += Math.abs(a.value)
        }
        return c
    }, draw: function (a, c, b) {
        this.drawInfo(a);
        FR.Chart.PiePlotGlyph.superclass.draw.apply(this, [a, c, b])
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (b, a) {
        FR.Chart.PiePlotGlyph.superclass.drawMarkersLabelAfterSeriesAnimateDraw.apply(this, [b, a])
    }
});
FR.Chart.FunnelPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        FR.Chart.FunnelPlotGlyph.superclass.initConstants.apply(this, [a]);
        this.TOP_BOTTOM_GAP = 0.1;
        this.LEFT_RIGHT_GAP = 0.05;
        this.LABEL_GAP = 0.06;
        this.LEAD_LINE_GAP = 0.01;
        this.MAX_LABEL_WIDTH = 0.46;
        this.LABEL_VALUE_GAP = 0.02;
        this.SERIES_GAP = 1;
        this.seriesX = [];
        this.seriesY = [];
        this.seriesHeight = [];
        this.seriesWidth = [];
        this.labelWidth = 0;
        this.labelX = 0;
        this.showLabel = true;
        this.originalPoint
    }, layoutAxisGlyph: function () {
    }, isSupportLegend: function () {
        return false
    }, getTotalHeight: function (d) {
        var c = 0;
        for (var b = 1; b < this.dataSeries.length; b++) {
            var a = this.dataSeries[b - 1].points[d];
            var e = this.dataSeries[b].points[d];
            c += Math.abs(Math.abs(a.value) - Math.abs(e.value))
        }
        return c
    }, initSeriesHeight: function (e) {
        var d = this.getTotalHeight(e);
        var c = this.bounds.height * (1 - this.TOP_BOTTOM_GAP * 2);
        this.seriesHeight[0] = 0;
        for (var b = 1; b < this.dataSeries.length; b++) {
            var a = this.dataSeries[b - 1].points[e];
            var f = this.dataSeries[b].points[e];
            this.seriesHeight[b] = Math.abs(Math.abs(a.value) - Math.abs(f.value)) / d * c;
            if (f.valueIsNull) {
                this.seriesHeight[b] = 0
            }
        }
    }, initSeriesWidth: function (c) {
        var d = this.bounds.width * (1 - this.LEFT_RIGHT_GAP * 2 - this.LEAD_LINE_GAP * 2 - this.LABEL_GAP) - this.labelWidth;
        if (!this.showLabel) {
            d = this.bounds.width * (1 - this.LEFT_RIGHT_GAP * 2 - this.LEAD_LINE_GAP * 2)
        }
        var b = this._getMaxValue(c);
        for (var a = 0; a < this.dataSeries.length; a++) {
            var e = this.dataSeries[a].points[c];
            this.seriesWidth[a] = Math.abs(e.value) / b * d
        }
    }, _getMaxValue: function (c) {
        var d = Number.MIN_VALUE;
        for (var b = 0; b < this.dataSeries.length; b++) {
            if (this.dataSeries[b].points[c]) {
                var a = this.dataSeries[b].points[c];
                d = Math.max(d, Math.abs(a.value))
            }
        }
        return d
    }, _getMaxSeriesWidth: function () {
        if (this.seriesWidth && this.seriesWidth[0]) {
            var b = this.seriesWidth[0];
            for (var a = 0; a < this.seriesWidth.length; a++) {
                b = Math.max(b, this.seriesWidth[a])
            }
            return b
        }
        return 0
    }, calculateOriginalPoint: function () {
        var a = this.bounds.x + this.bounds.width * this.LEFT_RIGHT_GAP + this._getMaxSeriesWidth() / 2;
        var b = this.bounds.y + this.bounds.height * this.TOP_BOTTOM_GAP;
        this.originalPoint = new FR.Chart.Point2D(a, b)
    }, calculateSeriesXY: function () {
        this.calculateOriginalPoint();
        var a = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            this.seriesX[b] = this.originalPoint.x - this.seriesWidth[b] / 2;
            a += this.seriesHeight[b];
            this.seriesY[b] = this.originalPoint.y + a
        }
    }, initSeriesBounds: function (a) {
        this.initSeriesHeight(a);
        this.initSeriesWidth(a);
        this.calculateSeriesXY()
    }, calculateLabelWidth: function (h) {
        var m = 0;
        var b = 0;
        var i = this.bounds.width * this.MAX_LABEL_WIDTH;
        var l = this.bounds.width * this.LABEL_VALUE_GAP;
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[h];
            var g = a.dataLabel;
            if (g == null) {
                this.labelWidth = 0;
                this.showLabel = false;
                return
            }
            a.valueGap = l;
            var k = a.getSeriesValueString();
            var e = g.textAttr;
            var f = null;
            var d = null;
            if (k != null) {
                if (!FR.isEmpty(k[0])) {
                    f = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(k[0], e)
                }
                if (!FR.isEmpty(k[1])) {
                    d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(k[1], e)
                }
            }
            if (f != null && f.width > m) {
                m = f.width
            }
            if (d != null && d.width > b) {
                b = d.width
            }
        }
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[h];
            var g = a.dataLabel;
            if (g == null) {
                continue
            }
            a.valueWidth = b
        }
        this.labelWidth = Math.min(m + b + l, i);
        this.labelX = this.bounds.x + this.bounds.width * (1 - this.LEFT_RIGHT_GAP) - this.labelWidth
    }, initLabelData: function (a) {
        this.calculateLabelWidth(a)
    }, layoutDataSeriesGlyph: function () {
        var a = this.dataSeries.length, d = [];
        for (var b = 0; b < a; b++) {
            var c = this.dataSeries[b];
            var f = c.points[0];
            if (f && !f.valueIsNull) {
                d.push(c)
            }
        }
        this.dataSeries = d;
        for (var e = 0; e < this.getCategoryCount(); e++) {
            this.deal4EachCategory(e)
        }
        this.dealLabelBoundsInOrder()
    }, _indexOfDataPoint: function (b) {
        var a = this.dataSeries.length;
        for (var c = 0; c < a; c++) {
            var d = this.dataSeries[c];
            if (d.points[0] == b) {
                return c
            }
        }
        return 0
    }, deal4EachCategory: function (a) {
        this.initLabelData(a);
        this.initSeriesBounds(a);
        this.dealLabelBounds(a);
        this.dealWithDataSeries(a)
    }, dealWithDataSeries: function (f) {
        var b = this.dataSeries.length;
        for (var c = 0; c < b; c++) {
            var d = this.dataSeries[c];
            var g = d.points[f];
            var a;
            if (c > 0) {
                a = this.dataSeries[c - 1].points[f]
            } else {
                a = g
            }
            if (g.valueIsNull) {
                continue
            }
            var e = this.calculateShapeGlyph4DifferentSub(a, g);
            g.glyph = (e)
        }
    }, calculateShapeGlyph4DifferentSub: function (a, f) {
        var e = new FR.Chart.GeneralPath();
        var b = this._indexOfDataPoint(a);
        var d = this._indexOfDataPoint(f);
        if (b != d) {
            e.moveTo(this.seriesX[b], this.seriesY[b] + this.SERIES_GAP);
            e.lineTo(this.seriesX[b] + this.seriesWidth[b], this.seriesY[b] + this.SERIES_GAP);
            e.lineTo(this.seriesX[d] + this.seriesWidth[d], this.seriesY[d] - this.SERIES_GAP);
            e.lineTo(this.seriesX[d], this.seriesY[d] - this.SERIES_GAP);
            e.closePath()
        }
        var c = new FR.Chart.ShapeGlyph();
        c.setShape(e);
        c.info.dealCondition(this.conditionCollection, f, this.createColors4Series());
        c.toolTipBackground = c.info.getBackground();
        return c
    }, isGuideLineShow: function (a) {
        var d = a.dataLabel;
        if (d == null) {
            return false
        }
        var c = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (c) {
            var b = d.text;
            return b != null && c.isShowGuidLine && d.bounds != null
        }
        return false
    }, isCoverLabelBounds: function (c, b) {
        if (b == null) {
            return false
        }
        if (!c.verticalIntersects(b.y, b.height)) {
            var a = new FR.Chart.Bounds(b.x, b.y, b.width + 2, b.height);
            c.append(a, false);
            return false
        }
        return true
    }, checkCoverLabelBounds: function (d) {
        var e = new FR.Chart.GeneralPath();
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[d];
            if (a == null) {
                continue
            }
            var f = a.dataLabel;
            if (f == null) {
                continue
            }
            var b = f.text;
            if (b != null && b.length > 0) {
                if (this.isCoverLabelBounds(e, f.getBounds())) {
                    return true
                }
            }
        }
        return false
    }, adjustCoverLabelBounds: function (d) {
        var e = new FR.Chart.GeneralPath();
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[d];
            if (a == null) {
                continue
            }
            var f = a.dataLabel;
            if (f == null) {
                continue
            }
            var b = f.text;
            if (b != null && b.length > 0) {
                if (this.isCoverLabelBounds(e, f.getBounds())) {
                    f.bounds = null;
                    a.leadLine = null
                }
            }
        }
    }, dealLabelBounds: function (d) {
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[d];
            if (a == null) {
                continue
            }
            var e = a.dataLabel;
            if (e == null) {
                return
            }
            var b = e.text;
            if (b != null && b.length > 0) {
                this.dealOutsideLabelBounds(e, a, this._indexOfDataPoint(a))
            }
        }
        if (this.checkCoverLabelBounds(d)) {
            this.dealLabelBoundsWithCover(d)
        }
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[d];
            if (a == null) {
                continue
            }
            var e = a.dataLabel;
            if (e == null) {
                return
            }
            a.initLabelBounds()
        }
    }, dealLabelBoundsWithCover: function (d) {
        for (var c = 0; c < this.dataSeries.length; c++) {
            var a = this.dataSeries[c].points[d];
            if (a == null) {
                continue
            }
            var e = a.dataLabel;
            if (e == null) {
                return
            }
            var b = e.text;
            if (b != null && b.length > 0) {
                this.dealOutsideLabelBoundsWithCover(e, a, this._indexOfDataPoint(a))
            }
        }
        this.adjustCoverLabelBounds(d)
    }, dealOutsideLabelBounds: function (f, a, b) {
        var c = new FR.Chart.Bounds();
        var d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(f.text, f.textAttr);
        var e = this.seriesY[b] - d.height / 2;
        c.setRect(this.labelX, e, this.labelWidth, d.height);
        this.dealOutsideLabelBoundsWhenNormal(c, a, b)
    }, dealOutsideLabelBoundsWithCover: function (g, a, b) {
        var c = new FR.Chart.Bounds();
        var d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(g.text, g.textAttr);
        var f = (this.bounds.height * (1 - this.TOP_BOTTOM_GAP * 2)) / (this.seriesY.length - 1);
        var e = this.seriesY[0] + f * b - d.height / 2;
        c.setRect(this.labelX, e, this.labelWidth, d.height);
        this.dealOutsideLabelBoundsWhenNormal(c, a)
    }, dealOutsideLabelBoundsWhenNormal: function (c, a, b) {
        a.dataLabel.bounds = c;
        if (this.isGuideLineShow(a)) {
            this.dealWidthLine(a, b)
        }
    }, dealWidthLine: function (b, f) {
        var k = new FR.Chart.GeneralPath();
        var e = this.seriesX[f] + this.seriesWidth[f] + this.bounds.width * this.LEAD_LINE_GAP;
        var c = this.seriesY[f];
        var h = this.labelX - this.bounds.width * (this.LEAD_LINE_GAP + this.LABEL_GAP);
        var j = this.labelX - this.bounds.width * this.LEAD_LINE_GAP;
        var i = c;
        if (b.dataLabel) {
            var a = b.dataLabel.bounds;
            if (a) {
                i = a.y + a.height / 2
            }
        }
        k.moveTo(e, c);
        k.lineTo(h, i);
        k.lineTo(j, i);
        var g = new FR.Chart.FoldLine(k);
        b.leadLine = g;
        var d = new FR.Chart.AttrLineStyle();
        d.lineStyle = FR.Chart.Constants.LINE_THIN;
        g.lineStyleInfo.attrLineStyle = d
    }, draw: function (a, c, b) {
        this.drawInfo(a);
        FR.Chart.PiePlotGlyph.superclass.draw.apply(this, [a, c, b])
    }
});
FR.Chart.Pie3DPlotGlyph = FR.extend(FR.Chart.PiePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.depth = FR.pick(a.depth, 0);
        this.projection = new FR.Chart.Projection(a.projection || {rotation: 0, elevation: 25});
        FR.Chart.Pie3DPlotGlyph.superclass.initConstants.apply(this, [a]);
        this.pie3DList = []
    }, dealEachCategory: function (m) {
        var o = this.bounds.width / this.getCategoryCount();
        this.initLabelData(m);
        var q = new FR.Chart.BoundsManager();
        for (var h = 0; h < this.dataSeries.length; h++) {
            var j = this.dataSeries[h];
            var a = j.points[m];
            a.lastGlyph = a.glyph;
            a.leadLine = null;
            if (a.valueIsNull || j.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                a.glyph = null;
                continue
            }
            var f = this.getSeriesStartAngle(m, h) % 360;
            var g = m * o + o / 2 + this.bounds.x;
            var e = new FR.Chart.Point2D(g, this.bounds.height / 2 + this.bounds.y);
            var i = this.radius / 5;
            var c = new FR.Chart.Pie3D(0, i, this.radius);
            var p = this.getPercent(h, m) * 360;
            var d = this.projection.projecteeArc(0, this.radius, f, p);
            var n = this.separatePercent / 100 * d.width / 2;
            var l = this.separatePercent / 100 * d.height / 2;
            if (!a.isSeparateOut) {
                n = 0;
                l = 0
            }
            var k = d.getMiddleAngle();
            k = (k / 180) * Math.PI + Math.PI;
            c.x = e.x + n * Math.cos(k);
            c.y = e.y + l * Math.sin(k);
            c.start = f;
            c.extent = p;
            c.projection = this.projection;
            var b = new FR.Chart.ShapeGlyph();
            b.shape = c;
            b.info.dealColorCondition(this.conditionCollection, a, this.createColors4Series());
            b.toolTipBackground = b.info.getBackground();
            a.glyph = b;
            this.pie3DList.push(new FR.Chart.Pie3DSide(b, true));
            this.pie3DList.push(new FR.Chart.Pie3DSide(b, false));
            this.dealLabelBounds(a, q)
        }
        this.dealWithCategoryLabels(m, q)
    }, relayLabelLine: function (a, j, l) {
        var n = new FR.Chart.GeneralPath();
        var c = a.glyph.shape;
        var f = c.bottom().getMiddlePoint();
        var d = this.getCenterAngle4DataPoint(a.categoryIndex, a.seriesIndex);
        if (d >= 0 && d <= 180) {
            f = c.top().getMiddlePoint()
        }
        var e = f.x;
        var b = f.y;
        n.moveTo(e, b);
        var g = c.top();
        var m = new FR.Chart.Ellipse(g.x, g.y, g.width * 1.2, g.width * 0.93, g.start, g.extent, g.type);
        f = m.getPointWithAngle((180 - l + 360) % 360);
        e = f.x;
        b = f.y + 3;
        n.lineTo(e, b);
        if (d >= 90 && d < 270) {
            e -= this.radius * 0.1
        } else {
            e += this.radius * 0.1
        }
        n.lineTo(e, b);
        var h = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        if (h.isShowGuidLine && a.isShowLabel) {
            var k = new FR.Chart.FoldLine(n);
            a.leadLine = k;
            var i = new FR.Chart.AttrLineStyle();
            i.lineStyle = FR.Chart.Constants.LINE_THIN;
            k.lineStyleInfo.attrLineStyle = i
        }
    }, calculateLabelBoundsWithAngle: function (d, a, i) {
        var e = a.glyph.shape;
        var h = this.getLabelDim(a);
        var g = e.top();
        var j = new FR.Chart.Ellipse(g.x, g.y, g.width * 1.2, g.width * 0.93, g.start, g.extent, g.type);
        var f = j.getPointWithAngle((180 - d + 360) % 360);
        var c = f.x;
        var b = f.y;
        if (d >= 90 && d < 270) {
            c -= this.radius * 0.1 + 2
        } else {
            c += this.radius * 0.1 + 2
        }
        if (d >= 90 && d < 270) {
            i.setRect(c - h.width, b - h.height / 2, h.width, h.height)
        } else {
            i.setRect(c, b - h.height / 2, h.width, h.height)
        }
    }, dealWithLabelLine: function (a) {
        this.relayLabelLine(a, a.dataLabel.bounds, this.getCenterAngle4DataPoint(a.categoryIndex, a.seriesIndex))
    }, halfHeight4Shape: function (b) {
        if (b && b.glyph && b.glyph.shape) {
            var c = b.glyph.shape;
            var a = c.top();
            return a.width * 0.93 / 2 - 3
        }
        return 0
    }, removeAngleExtendMinPoint: function (e) {
        if (e == null || e.length <= 0) {
            return
        }
        var b = -1;
        for (var c = 1; c < e.length; c++) {
            var d = 0;
            var a = 0;
            if (e[c].glyph == null) {
                e[c].isShowLabel = false;
                continue
            }
            b = b == -1 ? c : b;
            if (e[c].glyph.shape instanceof FR.Chart.Pie3D) {
                d = e[c].glyph.shape.extent
            }
            if (e[b].glyph.shape instanceof FR.Chart.Pie3D) {
                a = e[b].glyph.shape.extent
            }
            if (d < a) {
                b = c
            }
        }
        if (e[b]) {
            e[b].isShowLabel = false;
            e.splice(b, 1)
        }
    }, whileTmp: function (k, a, h, j, i, e, d) {
        if (e == null || d == null) {
            return FR.Chart.Pie3DPlotGlyph.superclass.whileTmp.apply(this, [k, a, h, j, i])
        }
        h = (180 - h + 360) % 360;
        var f = a.clone();
        var g = 0;
        while (k.isInteract(a)) {
            h += d;
            if (g > 360) {
                a.setRect(f.x, f.y, f.width, f.height);
                break
            }
            var c = j - e * Math.cos(Math.PI * h / 180);
            var b = i - e * Math.sin(Math.PI * h / 180);
            if (h >= 315 || h < 90) {
                a.setRect(c - a.width, b - a.height / 2, a.width, a.height)
            } else {
                if (h >= 270 && h < 315) {
                    a.setRect(c - a.width, b - a.height, a.width, a.height)
                } else {
                    if (h >= 225 && h < 270) {
                        a.setRect(c, b - a.height, a.width, a.height)
                    } else {
                        a.setRect(c, b - a.height / 2, a.width, a.height)
                    }
                }
            }
            g += d
        }
    }, getCenterAngle4DataPoint: function (e, a) {
        var c = this.getSeriesStartAngle(e, a) % 360;
        var b = this.getPercent(a, e) * 360;
        var d = this.projection.projecteeArc(0, this.radius, c, b);
        var f = d.getMiddleAngle();
        return (180 - f + 360) % 360
    }, getSeriesCountWithQuadrant: function (c) {
        this.leftUp.length = 0;
        this.leftDown.length = 0;
        this.rightDown.length = 0;
        this.rightUp.length = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            if (this.dataSeries[b].points[c].valueIsNull) {
                continue
            }
            this.dataSeries[b].points[c].isShowLabel = true;
            var d = this.getCenterAngle4DataPoint(c, b);
            var a = this.dataSeries[b].points[c];
            if (d >= 90 && d < 180) {
                this.leftUp.push(a)
            } else {
                if (d >= 180 && d < 270) {
                    this.leftDown.push(a)
                } else {
                    if (d >= 270 && d < 360) {
                        this.rightDown.push(a)
                    } else {
                        this.rightUp.push(a)
                    }
                }
            }
        }
        this._sortList()
    }, dealInsideLabelBounds: function (a, m) {
        var f = a.seriesIndex;
        var l = a.categoryIndex;
        var e = this.getSeriesStartAngle(l, f) % 360;
        var c = this.getHalfAngle(e, f, l) % 360;
        if (c == e) {
            this.dealOutsideLabelBounds(a, m);
            return
        }
        var d = a.dataLabel;
        var j = a.getShape().getTopArcCenterPoint();
        if (j != null) {
            var h = this.getLabelDim(a);
            var g = h.width;
            var b = h.height;
            var k = j.x - g / 2;
            var i = j.y - b / 2;
            d.bounds = new FR.Chart.Bounds(k, i, g, b)
        } else {
            d.bounds = null
        }
    }, dealLeadLineSeries: function () {
        for (var d = 0; this.dataSeries[0] && d < this.dataSeries[0].points.length; d++) {
            for (var b = 0; b < this.dataSeries.length; b++) {
                var c = this.dataSeries[b];
                var a = c.points[d];
                if (a.valueIsNull || c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    a.glyph = null;
                    continue
                }
                var e = a.getShape().top().getMiddleAngle();
                if (a.glyph && a.glyph.shape) {
                    this.dealLeadLine(a.glyph.shape, a, e % 360)
                }
            }
        }
    }, doAnimate4SeriesDraw: function (a, g, f) {
        var b = g.getDrawSequence();
        this.pie3DList = [];
        for (var c = 0; c < g.dataSeries.length; c++) {
            var e = g.dataSeries[b[c]];
            if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var h = e.points;
            for (var d = 0; d < e.getDataPointCount(); d++) {
                if (h[d].valueIsNull) {
                    continue
                }
                if (h[d].animatesGlyph && h[d].animatesGlyph.length > f) {
                    this.pie3DList.push(new FR.Chart.Pie3DSide(h[d].animateGlyph[f], true));
                    this.pie3DList.push(new FR.Chart.Pie3DSide(h[d].animateGlyph[f], false))
                }
            }
        }
        this.pie3DList.sort(FR.Chart.ChartUtils.sortPie3DSide);
        this.drawSide(a);
        for (var d = 0; d < g.dataSeries.length; d++) {
            g.dataSeries[b[d]].drawAnimateGlyph(a, f)
        }
    }, getDrawSequence: function () {
        var a = [];
        var c = [];
        for (var b = 0; this.dataSeries && b < this.dataSeries.length; b++) {
            a.push(b);
            c.push(this.dataSeries[b].points[0])
        }
        return a.sort(function (d, i) {
            var h = c[d].glyph;
            var g = c[i].glyph;
            if (!h || !g) {
                return 0
            }
            var f = Math.abs(270 - h.shape.top().start);
            var e = Math.abs(270 - g.shape.top().start);
            return f > e ? -1 : (f < e ? 1 : 0)
        })
    }, drawSide: function (a) {
        for (var b = 0;
             b < this.pie3DList.length; b++) {
            if (!a) {
                return
            }
            a.save();
            var c = this.pie3DList[b].cylinder;
            if (!!c) {
                if (c.extent === 0) {
                    continue
                }
                a.fillStyle = this.pie3DList[b].shapeGlyph.info.seriesAttrBackground.seriesBackground.color;
                if (this.pie3DList[b].isStart) {
                    c.paintStartSide(a)
                } else {
                    c.paintEndSide(a)
                }
            }
            a.restore()
        }
    }
});
FR.Chart.CompositePiePlotGlyph = FR.extend(FR.Chart.PiePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.subType = FR.pick(a.subType, 2);
        this.smallPercent = FR.pick(a.smallPercent, 0.05);
        FR.Chart.CompositePiePlotGlyph.superclass.initConstants.apply(this, [a]);
        this.Pie_Normal = 1, this.Pie_Pie = 2, this.Pie_Bar = 3, this.SMALLPERCENT_LABEL_RADIUS_COEFFICIENT = 0.7;
        this.list = []
    }, calculatePercentValue: function () {
        for (var c = 0; c < this.getCategoryCount(); c++) {
            var d = 0;
            var f = 0;
            var g = this.dataSeries.length - 1;
            for (var b = 0; b < g; b++) {
                if (this.dataSeries[b].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                    continue
                }
                d += Math.abs(this.dataSeries[b].points[c].value)
            }
            for (var b = 0; b < g; b++) {
                if (this.dataSeries[b].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                    continue
                }
                var a = this.dataSeries[b].points[c];
                var e = Math.abs(a.value);
                a.percentValue = e / d;
                if (a.percentValue < this.smallPercent) {
                    f += e
                }
            }
            if (g > 0) {
                var a = this.dataSeries[g].points[c];
                a.value = f;
                a.percentValue = f / d
            }
        }
    }, getLastDataPointGlyph: function (a) {
        return null
    }, configSeries: function (a) {
        this.subType = 2;
        if (a.subType && a.subType == "bar") {
            this.subType = 3
        }
        this.smallPercent = FR.pick(a.smallPercent, 0.05)
    }, layoutDataSeriesGlyph: function () {
        this.list.length = 0;
        for (var b = 0; this.dataSeries[0] && b < this.dataSeries[0].points.length; b++) {
            this.initLabelData(b);
            this.dealWithDataSeries(b);
            var a = this.getLinePath(b);
            if (a != null) {
                this.list.push(a)
            }
        }
        this.dealLabelBoundsInOrder()
    }, isOutsideLabel: function (a) {
        var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), a);
        return (b.position == FR.Chart.Constants.OUTSIDE || b.isShowGuidLine) && this._isMainPie(a.seriesIndex, a.categoryIndex)
    }, getPercent: function (c, d) {
        if (this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return 0
        }
        var e = this._isMainPie(c, d);
        var b = this.getTotalValue(d, e);
        if (b <= 0) {
            return 0
        }
        var a = this.dataSeries[c].points[d];
        return Math.abs(a.value) / b
    }, getTotalValue: function (f, e) {
        var c = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            if (this.dataSeries[b].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var a = this.dataSeries[b].points[f];
            var d = a.percentValue;
            if (e) {
                if (d >= this.smallPercent || b == this.dataSeries.length - 1) {
                    c += Math.abs(a.value)
                }
            } else {
                if (d < this.smallPercent && b != this.dataSeries.length - 1) {
                    c += Math.abs(a.value)
                }
            }
        }
        return c
    }, getCenterPoint: function (e, h) {
        var f = this.dataSeries[e];
        var a = f.points[h];
        if (a.valueIsNull || f.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return null
        }
        var g = this.getBounds();
        var i = g.width / this.dataSeries[0].points.length;
        if (this.subType == this.Pie_Pie || this.subType == this.Pie_Bar) {
            var c = g.y + g.height / 2;
            if (a.percentValue < this.smallPercent && e != this.dataSeries.length - 1) {
                var b = h * i + i * 0.8 + g.x;
                return new FR.Chart.Point2D(b, c)
            } else {
                var d = h * i + i * 0.3 + g.x;
                return new FR.Chart.Point2D(d, c)
            }
        }
        return null
    }, getAngle4Pie: function (a, g, e) {
        var b = Math.abs(g.x - e.x);
        var d = Math.abs(g.y - e.y);
        var f = Math.atan(d / b);
        var c = Math.acos(a * Math.sin(f) / d);
        return f + c
    }, getLinePath: function (a) {
        if (this.subType == this.Pie_Pie && this.getPercent(this.dataSeries.length - 1, a) > 0) {
            return this._getLinePath4PieSub(a)
        } else {
            if (this.subType == this.Pie_Bar && this.getPercent(this.dataSeries.length - 1, a) > 0) {
                return this._getLinePath4BarSub(a)
            }
        }
        return null
    }, _getLinePath4BarSub: function (i) {
        var j = new FR.Chart.GeneralPath();
        var f = this.dataSeries[this.dataSeries.length - 1].points[i];
        var b = f.glyph.shape;
        var g = b.getEndPoint().y > b.getStartPoint().y ? b.getStartPoint() : b.getEndPoint();
        var a = b.getEndPoint().y > b.getStartPoint().y ? b.getEndPoint() : b.getStartPoint();
        var k = this.getBounds().width / this.dataSeries[0].points.length;
        var e = i * k + k * 0.8 + this.getBounds().x;
        var h = new FR.Chart.Point2D(e, this.getBounds().height / 2 + this.getBounds().y);
        if (g) {
            if (b.extent >= 180) {
                var c = new FR.Chart.Point2D(b.x, b.y);
                var d = this.getAngle4Pie(this.radius, c, new FR.Chart.Point2D(h.x - this.radius / 4, h.y - this.radius / 2));
                g = new FR.Chart.Point2D(c.x + Math.cos(d) * this.radius, c.y - Math.sin(d) * this.radius + 1)
            }
            j.moveTo(h.x - this.radius / 4, h.y - this.radius / 2);
            j.lineTo(g.x, g.y)
        }
        if (a) {
            if (b.extent >= 180) {
                var c = new FR.Chart.Point2D(b.x, b.y);
                var d = this.getAngle4Pie(this.radius, c, new FR.Chart.Point2D(h.x - this.radius / 4, h.y - this.radius / 2));
                a = new FR.Chart.Point2D(c.x + Math.cos(d) * this.radius, c.y + Math.sin(d) * this.radius - 1)
            }
            j.moveTo(a.x, a.y);
            j.lineTo(h.x - this.radius / 4, h.y + this.radius / 2)
        }
        return j
    }, _getLinePath4PieSub: function (i) {
        var j = new FR.Chart.GeneralPath();
        var e = this.dataSeries[this.dataSeries.length - 1].points[i];
        var b = e.glyph.shape;
        var f = b.getEndPoint().y > b.getStartPoint().y ? b.getStartPoint() : b.getEndPoint();
        var a = b.getEndPoint().y > b.getStartPoint().y ? b.getEndPoint() : b.getStartPoint();
        var d = this._getSubLineFrom(i, true);
        var g = this._getSubLineFrom(i, false);
        if (d) {
            if (b.extent >= 180) {
                var c = new FR.Chart.Point2D(b.x, b.y);
                var h = this.getAngle4Pie(this.radius, c, d);
                f = new FR.Chart.Point2D(c.x + Math.cos(h) * this.radius, c.y - Math.sin(h) * this.radius)
            }
            j.moveTo(d.x, d.y);
            j.lineTo(f.x, f.y)
        }
        if (g) {
            if (b.extent >= 180) {
                var c = new FR.Chart.Point2D(b.x, b.y);
                var k = this.getAngle4Pie(this.radius, c, g);
                a = new FR.Chart.Point2D(c.x + Math.cos(k) * this.radius, c.y + Math.sin(k) * this.radius)
            }
            j.moveTo(a.x, a.y);
            j.lineTo(g.x, g.y)
        }
        return j
    }, getSeriesStartAngle: function (f, b) {
        var g = this.dataSeries[b].points[f];
        var a = g.percentValue >= this.smallPercent || b == this.dataSeries.length - 1;
        var e = this.getStartAngle(b, f);
        for (var d = 0; d < b; d++) {
            var c = this.dataSeries[d].points[f];
            if (a) {
                if (c.percentValue >= this.smallPercent || d == this.dataSeries.length - 1) {
                    e = e + this.getPercent(d, f) * 360
                }
            } else {
                if (c.percentValue < this.smallPercent && d != this.dataSeries.length - 1) {
                    e = e + this.getPercent(d, f) * 360
                }
            }
        }
        return e
    }, getArc2D: function (a) {
        var d = a.categoryIndex;
        var b = a.seriesIndex;
        var c = this.getSeriesStartAngle(d, b) % 360;
        var e = this.getCenterPoint(b, d);
        if (!(a.percentValue < this.smallPercent && b != this.dataSeries.length - 1)) {
            return this.getDataPointShape(e, b, d, c, this.radius, a.isSeparateOut)
        } else {
            if (this.subType == this.Pie_Pie) {
                return this.getDataPointShape(e, b, d, c, this.radius / 2, a.isSeparateOut)
            } else {
                if (this.subType == this.Pie_Bar) {
                    return this._get4PieBar(b, d, e, this.radius / 2)
                }
            }
        }
        return null
    }, _isMainPie: function (b, c) {
        var a = this.dataSeries[b].points[c];
        return a.percentValue >= this.smallPercent || b == this.dataSeries.length - 1
    }, _get4PieBar: function (c, l, k, g) {
        var d = 0;
        var b = this._isMainPie(c, l);
        for (var e = 0; e < c; e++) {
            var f = this._isMainPie(e, l);
            if (f == b) {
                var j = this.getPercent(e, l);
                d += j
            }
        }
        var h = this.getPercent(c, l);
        var a = new FR.Chart.Bounds(k.x - g / 2, k.y - g + d * g * 2, g, g * 2 * h);
        return a
    }, changeRadius: function (b, a) {
        var c = this._isMainPie(a, b);
        return (c ? this.radius * this.OUTSIDE_LABEL_RADIUS_COEFFICIENT : this.radius * this.SMALLPERCENT_LABEL_RADIUS_COEFFICIENT) + this.separatePercent * this.radius / 100
    }, getStartAngle: function (a, c) {
        var b = this.dataSeries[a].points[c];
        if (b.percentValue >= this.smallPercent || a == this.dataSeries.length - 1) {
            var d = this.getPercent(this.dataSeries.length - 1, c) * 180;
            return d
        }
        return 90
    }, _getSubLineFrom: function (p, i) {
        var n = null;
        for (var e = 0; e < this.dataSeries.length; e++) {
            var g = this.dataSeries[e];
            var b = g.points[p];
            if (b.valueIsNull || g.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var h = b;
            var c = h.glyph.shape;
            if (h.percentValue < this.smallPercent && e != this.dataSeries.length - 1) {
                var a = c.getBounds2D();
                var k = a.y;
                if (!i) {
                    k = a.y + a.height
                }
                var f = c.radius;
                var m = c.y;
                var o = c.x;
                var d = (m - k) / f;
                d = Math.min(1, d);
                d = Math.max(-1, d);
                var j = Math.asin(d) * 180 / Math.PI;
                var l = o + f * Math.cos(Math.PI * j / 180);
                if (n == null || (i && k <= n.y) || (!i && k >= n.y)) {
                    n = new FR.Chart.Point2D(l, k)
                }
            }
        }
        return n
    }, deal4BestRad: function (b, a) {
        return FR.Chart.CompositePiePlotGlyph.superclass.deal4BestRad.apply(this, [b, a]) * 0.8
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (b, a) {
        FR.Chart.CompositePiePlotGlyph.superclass.drawMarkersLabelAfterSeriesAnimateDraw.apply(this, [b, a]);
        if (!b) {
            return
        }
        b.save();
        b.strokeStyle = "rgb(125, 125, 125)";
        for (var c = 0; c < this.list.length; c++) {
            var d = this.list[c];
            d.draw(b)
        }
        b.restore()
    }
});
FR.Chart.AreaPlotGlyph = FR.extend(FR.Chart.CategoryPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isCurve = a.isCurve;
        FR.Chart.AreaPlotGlyph.superclass.initConstants.apply(this, [a])
    }, configSeries: function (c) {
        this.isCurve = FR.pick(c.isCurve, false);
        var b = this.conditionCollection.defaultAttr;
        if (c.markerType) {
            var a = new FR.Chart.AttrMarkerType();
            a.markerType = c.markerType;
            b.addAttr(a)
        }
    }, isSupportLabelWrap: function () {
        return true
    }, layoutDataSeriesGlyph: function () {
        for (var a = 0; a < this.dataSeries.length; a++) {
            var c = this.dataSeries[a];
            if (c == null) {
                continue
            }
            c.lastGlyph = this.getLastSeriesGlyph(c);
            if (c.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                c.glyph = null;
                continue
            }
            var b = this.dealAreaShape4PlotGlyph(c, this, this.xAxisGlyph, this.getSeriesAxisGlyph(a));
            if (b !== -1) {
                this.dealAreaLargeData4StockChart(c, this, this.xAxisGlyph, this.getSeriesAxisGlyph(a), b)
            }
            if (this.isStockChart) {
                this.refreshDataPointLabel()
            }
        }
        this.dealLabelBoundsInOrder()
    }, dealAreaLargeData4StockChart: function (u, l, h, A, B) {
        if (u == null) {
            return
        }
        for (var D = 0; D < u.getDataPointCount(); D++) {
            u.points[D].revert2Original()
        }
        var k = null;
        var y = null;
        var c = -1;
        var t = [];
        for (var D = 0; D < u.getDataPointCount(); D++) {
            var f = u.points[D];
            if (f.valueIsNull) {
                f.glyph = null;
                continue
            }
            var n = h.getPoint2D(h.getTickIndex4Value(D)).x;
            if (this.isDataPointXNotInPlotBounds(n)) {
                f.glyph = null;
                continue
            }
            var E = h.getDate4Value(D);
            if (t.length === 0) {
                k = E;
                t[0] = f;
                f.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(E, B);
                y = f;
                y.stockDataPointCount = 1;
                c = parseInt(n);
                continue
            } else {
                if (FR.Chart.ChartUtils.isBelongToSameUnit(E, k, B)) {
                    y.addDataPoint4StockCategory(f);
                    y.stockDataPointCount++;
                    f.valueIsNull = true;
                    continue
                }
            }
            var r = this.getStockDateRangeIndex(t, E, h, B);
            if (r !== -1) {
                t[r].addDataPoint4StockCategory(f);
                f.valueIsNull = true;
                y.stockDataPointCount++
            } else {
                c = parseInt(n);
                f.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(E, B);
                t[t.length] = f;
                k = E;
                y = f;
                y.stockDataPointCount = 1;
                c = parseInt(n)
            }
        }
        var s = t.length;
        for (var r = 0; r < s; r++) {
            var F = t[r];
            F.value = F.value / F.stockDataPointCount;
            F.percentValue = F.percentValue / F.stockDataPointCount
        }
        A.oldMin = A.minValue;
        A.oldMax = A.maxValue;
        A.oldTick = A.tickLength;
        A.initMinMaxValue(this.getMinValueFromData(A.isLog, FR.Chart.CustomAttr.Axis_LEFT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_LEFT));
        A.calculateAxisGlyph(this.bounds);
        h.stockChartMainType = B;
        var q = this.isSeriesCurve(u);
        var d = new FR.Chart.GeneralPath();
        var j = new FR.Chart.FoldLine(d);
        u.topFoldLine = j;
        var e = new FR.Chart.GeneralPath();
        var C = new FR.Chart.GeneralPath();
        var G = new FR.Chart.ShapeGlyph();
        G.shape = e;
        u.glyph = G;
        G.info.dealCondition(this.conditionCollection, u, this.createColors4Series());
        if (!this.conditionCollection.isContainsAttr(u, new FR.Chart.AttrAlpha())) {
            G.info.seriesAttrAlpha.alpha = 0.5
        }
        G.toolTipBackground = G.info.getBackground();
        var x = "rgb(0,0,255)";
        if (G.info.seriesAttrBackground.seriesBackground instanceof FR.Chart.ColorBackground) {
            x = G.info.seriesAttrBackground.seriesBackground.color
        }
        var a = new FR.Chart.AttrColor();
        a.seriesColor = x;
        var b = new FR.Chart.AttrLineStyle();
        b.lineStyle = FR.Chart.Constants.LINE_THICK;
        j.lineStyleInfo.attrLineColor = a;
        j.lineStyleInfo.attrLineStyle = b;
        var p = [];
        for (var r = 0; r < s; r++) {
            var F = t[r];
            var o = this.getStockChartDatePointX(h, F, B, this.getBounds());
            var g = l.getPreSum4Area(u.seriesIndex, F.categoryIndex);
            var v = l.getDataPointPercentValue(u.seriesIndex, F.categoryIndex);
            var m = A.getPoint2D(g + v).y;
            p[r] = A.getPoint2D(g).y;
            this.dealLinePath4Area(q, C, e, o, m, f)
        }
        if (q) {
            FR.Chart.FoldLine.curveTo(e, C);
            C.clear()
        }
        if (q) {
            for (var z = p.length - 1; z >= 0; z--) {
                var f = t[z];
                if (f.valueIsNull) {
                    continue
                }
                var w = this.getStockChartDatePointX(h, f, B, this.getBounds());
                if (this.isDataPointXNotInPlotBounds(o)) {
                    continue
                }
                if (z == p.length - 1) {
                    C.moveTo(w, p[z])
                } else {
                    C.lineTo(w, p[z])
                }
            }
            FR.Chart.FoldLine.curveTo(e, C);
            C.clear()
        } else {
            for (var z = p.length - 1;
                 z >= 0; z--) {
                var f = t[z];
                if (f.valueIsNull) {
                    continue
                }
                var w = this.getStockChartDatePointX(h, f, B, this.getBounds());
                if (this.isDataPointXNotInPlotBounds(o)) {
                    continue
                }
                e.lineTo(w, p[z])
            }
        }
        e.closePath();
        if (this.plotStyle !== FR.Chart.Constants.STYLE_NONE) {
            this.addChartStyle4DataSeries(this.plotStyle, u, G, e);
            G.dataPointStyle = u.dataSeriesStyle
        }
    }, dealLinePath4Area: function (d, g, f, c, b, a) {
        if (d) {
            if (g.x.length === 0) {
                g.moveTo(c, b)
            } else {
                g.lineTo(c, b)
            }
        } else {
            if (f.x.length === 0) {
                f.moveTo(c, b)
            } else {
                f.lineTo(c, b)
            }
        }
        if (!this.isDataPointXNotInPlotBounds(c)) {
            var e = new FR.Chart.MarkerGlyph();
            e.dealCondition4Line(this.conditionCollection, a, this.createColors4Series());
            e.setShape(new FR.Chart.Bounds(c - FR.Chart.Constants.MarkerDefaultSize / 2, b - FR.Chart.Constants.MarkerDefaultSize / 2, FR.Chart.Constants.MarkerDefaultSize, FR.Chart.Constants.MarkerDefaultSize));
            e.background = this.getBackground() !== null ? this.getBackground() : this.wholeChartBackground;
            a.glyph = e;
            e.toolTipBackground = e.background;
            this.dealDataPointLabel(a)
        }
    }, dealAreaShape4PlotGlyph: function (s, m, h, x) {
        if (s == null) {
            return
        }
        h.stockChartMinDateInt = null;
        h.stockChartMainType = null;
        if (this.isStockChart) {
            for (var z = 0; z < s.getDataPointCount(); z++) {
                s.points[z].revert2Original()
            }
        }
        var d = new FR.Chart.GeneralPath();
        var k = new FR.Chart.FoldLine(d);
        s.topFoldLine = k;
        var f = new FR.Chart.GeneralPath();
        var A = new FR.Chart.GeneralPath();
        var B = new FR.Chart.ShapeGlyph();
        B.shape = f;
        s.glyph = B;
        B.info.dealCondition(this.conditionCollection, s, this.createColors4Series());
        if (!this.conditionCollection.isContainsAttr(s, new FR.Chart.AttrAlpha())) {
            B.info.seriesAttrAlpha.alpha = 0.5
        }
        B.toolTipBackground = B.info.getBackground();
        var v = "rgb(0,0,255)";
        if (B.info.seriesAttrBackground.seriesBackground instanceof FR.Chart.ColorBackground) {
            v = B.info.seriesAttrBackground.seriesBackground.color
        }
        var b = new FR.Chart.AttrColor();
        b.seriesColor = v;
        var c = new FR.Chart.AttrLineStyle();
        c.lineStyle = FR.Chart.Constants.LINE_THICK;
        k.lineStyleInfo.attrLineColor = b;
        k.lineStyleInfo.attrLineStyle = c;
        var p = [];
        var j = 0;
        if (x.isLog) {
            j = 1
        }
        var q = this.isSeriesCurve(s);
        var o = h.getPoint2D(h.getCrossValue()).x;
        var n = x.getPoint2D(j).y;
        var r = -1;
        var l = null;
        for (var z = 0;
             z < s.getDataPointCount(); z++) {
            var e = s.points[z];
            if (e.valueIsNull) {
                continue
            }
            var a = h.zoomBackward !== 0 || h.zoomForward !== 0;
            o = h.getPoint2D(h.getTickIndex4Value(z)).x;
            if (this.isDataPointXNotInPlotBounds(o)) {
                e.glyph = null;
                if (!a || (a && e.isOutBounds)) {
                    e.isOutBounds = true;
                    continue
                }
            }
            if (this.isStockChart && r === parseInt(o)) {
                var y = h.getDate4Value(z);
                return this.getStockChartAdjustDateType(y, l)
            } else {
                r = parseInt(o)
            }
            if (this.isStockChart) {
                l = h.getDate4Value(z)
            }
            var g = m.getPreSum4Area(s.seriesIndex, z);
            var t = m.getDataPointPercentValue(s.seriesIndex, z);
            n = x.getPoint2D(g + t).y;
            p[z] = x.getPoint2D(g).y;
            this.dealLinePath4Area(q, A, f, o, n, e)
        }
        if (q) {
            FR.Chart.FoldLine.curveTo(f, A);
            A.clear()
        }
        if (q) {
            for (var w = p.length - 1; w >= 0; w--) {
                var e = s.points[w];
                if (e.valueIsNull) {
                    continue
                }
                var u = h.getPoint2D(h.getTickIndex4Value(w)).x;
                if (this.isDataPointXNotInPlotBounds(u) && e.isOutBounds) {
                    continue
                }
                if (w == p.length - 1) {
                    A.moveTo(u, p[w])
                } else {
                    A.lineTo(u, p[w])
                }
            }
            FR.Chart.FoldLine.curveTo(f, A);
            A.clear()
        } else {
            for (var w = p.length - 1; w >= 0; w--) {
                var u = h.getPoint2D(h.getTickIndex4Value(w)).x;
                var e = s.points[w];
                if (e.valueIsNull) {
                    continue
                }
                if (this.isDataPointXNotInPlotBounds(u) && e.isOutBounds) {
                    continue
                }
                f.lineTo(u, p[w])
            }
        }
        f.closePath();
        if (this.plotStyle !== FR.Chart.Constants.STYLE_NONE) {
            this.addChartStyle4DataSeries(this.plotStyle, s, B, f);
            B.dataPointStyle = s.dataSeriesStyle
        }
        return -1
    }, addChartStyle4DataSeries: function (d, e, f, c) {
        if (f.info.getBackground().color) {
            var b = f.info.getBackground().color;
            var a = {"color": b, "avoidOriginDraw": true, "areaPath": c, "axisReversed": this.yAxisGlyph.axisReversed};
            if (d == FR.Chart.Constants.STYLE_3D) {
                f.info.seriesAttrAlpha.alpha = 1;
                e.dataSeriesStyle = new FR.Chart.AreaPlane3DStyle(a);
                e.dataSeriesStyle.animateGlyph = f
            } else {
                if (d == FR.Chart.Constants.STYLE_OUTER) {
                    e.dataSeriesStyle = new FR.Chart.AreaHighLightStyle(a)
                } else {
                    if (d == FR.Chart.Constants.STYLE_SHADE) {
                        e.dataSeriesStyle = new FR.Chart.AreaTopDownShadeStyle(a)
                    } else {
                        if (d == FR.Chart.Constants.STYLE_TRANSPARENT) {
                            e.dataSeriesStyle = new FR.Chart.AreaTransparentChartStyle(a)
                        }
                    }
                }
            }
        }
    }, getDataPointLabelBoundsWithPosition: function (c, b, a) {
        return this.getDataPointLabelBoundsWithPosition4Line(c, b, a)
    }, getDrawSequence: function () {
        if (this.isStacked) {
            var b = [];
            for (var d = 0; this.dataSeries && d < this.dataSeries.length; d++) {
                b[d] = this.dataSeries.length - d - 1
            }
            return b
        }
        var a = [];
        var f = [];
        for (var d = 0; d < this.dataSeries.length; d++) {
            a[d] = d;
            f[d] = -1;
            var e = this.dataSeries[d];
            for (var c = 0; c < e.getDataPointCount(); c++) {
                if ((!e.points[c].valueIsNull) && Math.abs(e.points[c].value) > f[d]) {
                    f[d] = Math.abs(e.points[c].value)
                }
            }
        }
        a.sort(function (g, h) {
            return f[g] > f[h] ? -1 : f[g] < f[h] ? 1 : 0
        });
        return a
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (b, a) {
        this.drawAfterAnimate4LineMarker(b, a);
        this.drawAlertLinesAfterSeriesAnimateDraw(b)
    }, categoryInBounds: function (a, c) {
        if (!a.glyph) {
            return false
        }
        var b = a.glyph.getShape();
        if (b != null) {
            return c.containsPoint(b.x, b.y)
        }
    }, findOnMoveGlyph: function (a, c, b) {
        this._findOnMoveGlyph4Line(a, c, b)
    }
});
FR.Chart.Area3DPlotGlyph = FR.extend(FR.Chart.CategoryPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.seriesIntervalPercent = FR.pick(a.seriesIntervalPercent, 1);
        this.deep = FR.pick(a.deep, -1);
        this.projection = new FR.Chart.Projection(a.projection);
        FR.Chart.Area3DPlotGlyph.superclass.initConstants.apply(this, [a])
    }, isSupportLabelWrap: function () {
        return true
    }, get3DDeep: function () {
        return 50
    }, layoutAxisGlyph: function () {
        this.layoutAxisGlyph4ThreeD(this.xAxisGlyph, this.yAxisGlyph)
    }, layoutDataSeriesGlyph: function () {
        var f = this.get3DDeep();
        var g = 0;
        for (var c = 0; c < this.dataSeries.length; c++) {
            var e = this.dataSeries[c];
            if (e == null) {
                continue
            }
            e.lastGlyph = e.glyph;
            if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                e.glyph = null;
                continue
            }
            var k = new FR.Chart.Area3D(g, f);
            k.projection = this.projection;
            k.topSize = e.getDataPointCount();
            var b = new FR.Chart.ShapeGlyph();
            b.shape = k;
            e.glyph = b;
            b.info.dealCondition(this.conditionCollection, e, this.createColors4Series());
            b.info.seriesAttrAlpha.alpha = 0.8;
            b.toolTipBackground = b.info.getBackground();
            var h = [];
            for (var j = 0; j < e.getDataPointCount(); j++) {
                var a = e.points[j];
                this._calculatePreValueWithStacked(k, a, h, g, j, c)
            }
            for (var d = h.length - 1; d >= 0; d--) {
                k.lineTo(this.xAxisGlyph.getPoint2D(d).x, h[d])
            }
            k.closePath();
            k.preSize = h.length;
            if (c == this._getFirstSeriesIndexToDrawAreaSide()) {
                k.isFirst = true
            }
        }
        this.dealLabelBoundsInOrder()
    }, _getPrePercentValue: function (g, e) {
        var a = 0;
        var d = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var c = this.dataSeries[b];
            var f = Math.abs(c.points[e].value);
            d = d + f;
            if (b <= g && c.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                a += f
            }
        }
        if (!this.yAxisGlyph.isPercentage) {
            return a
        }
        if (d === 0) {
            return 0
        }
        return a / d
    }, _getFirstSeriesIndexToDrawAreaSide: function () {
        for (var a = 0; a < this.dataSeries.length; a++) {
            if (this.dataSeries[a].paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                return a
            }
        }
    }, _calculatePreValueWithStacked: function (l, a, g, e, j, c) {
        var k, i;
        var h = this.getDataPointPercentValue(c, j);
        k = this.xAxisGlyph.getPointInBounds(j).x;
        var b = this._getPrePercentValue(c, j);
        var d = this._getPrePercentValue(c - 1, j);
        i = this.threeDBase.getGapHeight() + this.getSeriesAxisGlyph(c).getPointInBounds(b).y;
        g[j] = this.threeDBase.getGapHeight() + this.getSeriesAxisGlyph(c).getPointInBounds(d).y;
        this.dealPointPath(a, l, k, i, e, j);
        this.dealDataPointLabel(a);
        var f = new FR.Chart.MarkerGlyph();
        f.dealCondition4Line(this.conditionCollection, a, this.createColors4Series());
        f.setShape(new FR.Chart.Bounds(k - FR.Chart.Constants.MarkerDefaultSize / 2, i - FR.Chart.Constants.MarkerDefaultSize / 2, FR.Chart.Constants.MarkerDefaultSize, FR.Chart.Constants.MarkerDefaultSize));
        f.background = this.getBackground() !== null ? this.getBackground() : this.wholeChartBackground;
        a.glyph = f;
        f.toolTipBackground = f.background
    }, dealPointPath: function (b, f, c, a, g, d) {
        if (d === 0) {
            f.moveTo(c, a)
        } else {
            f.lineTo(c, a)
        }
        var e = this.projection.projectee(c, a, g);
        b.setShape(new FR.Chart.Arc2D(e.x - 3, e.y - 3, 3, 0, 360, FR.Chart.Arc2D.PIE))
    }, draw: function (a, c, b) {
        this.draw3DInfo(a);
        if (this.xAxisGlyph != null) {
            this.xAxisGlyph.draw4ThreeD(a[1])
        }
        if (this.yAxisGlyph != null) {
            this.yAxisGlyph.draw4ThreeD(a[1])
        }
        FR.Chart.Bar3DPlotGlyph.superclass.draw.apply(this, [a, c, b])
    }, drawInfo: function (a) {
        this.info.paint(a[0], this.getOutline4Fill())
    }, getOutline4Fill: function () {
        var d = this.threeDBase.getPoints()[4];
        var c = this.yAxisGlyph.bounds.width;
        var b = this.threeDBase.width;
        var a = this.threeDBase.height;
        return new FR.Chart.Bounds(d.x + c, d.y, b - c, a)
    }, getDataPointLabelBoundsWithPosition: function (c, b, a) {
        return this.getDataPointLabelBoundsWithPosition4Line(c, b, a)
    }
});
FR.Chart.RadarPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isFilled = FR.pick(a.isFilled, false);
        this.intervalColor = a.intervalColor;
        this.radarAxisGlyph = new FR.Chart.RadarAxisGlyph(a.radarAxisGlyph || a.radarAxis);
        FR.Chart.RadarPlotGlyph.superclass.initConstants.apply(this, [a])
    }, configSeries: function (f) {
        this.isFilled = FR.pick(f.isFilled, false);
        this.isNullValueBreak = FR.pick(f.isNullValueBreak, true);
        var d = this.conditionCollection.defaultAttr;
        if (this.isFilled) {
            var e = new FR.Chart.AttrAlpha();
            e.alpha = 0.7;
            d.addAttr(e)
        }
        if (f.lineStyle != null && f.lineStyle != undefined) {
            var c = new FR.Chart.AttrLineStyle();
            c.lineStyle = f.lineStyle;
            d.addAttr(c)
        }
        var a = f.markerType || "NullMarker";
        var b = new FR.Chart.AttrMarkerType();
        b.markerType = a;
        d.addAttr(b)
    }, configAxisLabelsWithOptionData: function (a) {
        if (this.radarAxisGlyph && a && a.category) {
            this.radarAxisGlyph.labelList = a.category;
            this.radarAxisGlyph.categoryCount = a.category.length
        }
    }, addSeries2PlotGlyph: function (b, a) {
        FR.Chart.RadarPlotGlyph.superclass.addSeries2PlotGlyph.apply(this, [b, a]);
        this.radarAxisGlyph.categoryCount = this.getCategoryCount()
    }, getLegendMarkerIcon: function (b, a) {
        return this.getLegendMarkerIcon4Line(b, a)
    }, isSupportTwoStepDraw: function () {
        return true
    }, layoutAxisGlyph: function () {
        var b = this.getBounds();
        var a = 20;
        this.radarAxisGlyph.dealPlotBoundsWithAxisLabel(b);
        b.height = b.height - a;
        b.y = b.y + a / 2;
        this.radarAxisGlyph.init(b);
        this.radarAxisGlyph.calculateAxisLengthUnit()
    }, layoutDataSeriesGlyph: function () {
        for (var e = 0; e < this.dataSeries.length; e++) {
            var f = this.dataSeries[e];
            f.lastGlyph = f.glyph;
            if (f.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                f.glyph = null;
                continue
            }
            var m = new FR.Chart.GeneralPath();
            m.centerPoint = this.radarAxisGlyph.getPointInBounds(0, this.radarAxisGlyph.getCrossValue());
            for (var l = 0; l < f.getDataPointCount(); l++) {
                var b = f.points[l];
                var j = b.value;
                var k = this.radarAxisGlyph.getPointInBounds(l, j);
                if (b.valueIsNull) {
                    if (!this.isNullValueBreak) {
                        continue
                    }
                    k = this.radarAxisGlyph.originPoint
                }
                if (l === 0) {
                    m.moveTo(k.x, k.y)
                } else {
                    m.lineTo(k.x, k.y)
                }
                var i = new FR.Chart.MarkerGlyph();
                i.dealCondition4Line(this.conditionCollection, b, this.createColors4Series());
                i.setShape(new FR.Chart.Bounds(k.x - FR.Chart.Constants.MarkerDefaultSize / 2, k.y - FR.Chart.Constants.MarkerDefaultSize / 2, FR.Chart.Constants.MarkerDefaultSize, FR.Chart.Constants.MarkerDefaultSize));
                i.background = this.getBackground() != null ? this.getBackground() : this.wholeChartBackground;
                b.glyph = i;
                i.toolTipBackground = i.background;
                this.dealDataPointLabel(b)
            }
            m.closePath();
            var h = new FR.Chart.FoldLine(m);
            h.lineStyleInfo.dealCondition(this.conditionCollection, f, this.createColors4Series());
            f.glyph = h;
            if (h.lineStyleInfo.attrLineColor.seriesColor) {
                var n = new FR.Chart.ColorBackground();
                n.color = h.lineStyleInfo.attrLineColor.seriesColor;
                h.toolTipBackground = n
            }
            if (this.isFilled) {
                var c = new FR.Chart.ShapeGlyph();
                c.shape = m;
                var g = FR.Chart.ColorBackground.getInstance(h.lineStyleInfo.attrLineColor.seriesColor);
                var d = new FR.Chart.AttrBackground();
                d.seriesBackground = g;
                var a = new FR.Chart.AttrAlpha();
                a.alpha = h.lineStyleInfo.seriesAttrAlpha.alpha;
                c.info.seriesAttrBackground = d;
                c.info.seriesAttrAlpha = a;
                c.toolTipBackground = g;
                f.glyph = c
            }
        }
        this.dealLabelBoundsInOrder()
    }, getDataPointLabelBoundsWithPosition: function (c, b, a) {
        return this.getDataPointLabelBoundsWithPosition4Line(c, b, a)
    }, refreshAxisGlyph: function () {
        this.radarAxisGlyph.oldMin = this.radarAxisGlyph.minValue;
        this.radarAxisGlyph.oldMax = this.radarAxisGlyph.maxValue;
        this.radarAxisGlyph.oldTick = this.radarAxisGlyph.tickLength;
        this.radarAxisGlyph.initMinMaxValue(this.getMinValueFromData(this.radarAxisGlyph.isLog), this.getMaxValueFromData());
        var a = [];
        var d = [];
        if (this.radarAxisGlyph.isAllMaxMin) {
            for (var c = 0; c < this.getCategoryCount(); c++) {
                a[c] = this.radarAxisGlyph.maxValue;
                d[c] = this.radarAxisGlyph.minValue
            }
        } else {
            for (var c = 0; c < this.getCategoryCount(); c++) {
                d[c] = this._getMinValueFromaCateData(c);
                var b = this._getMaxValueFromCateData(c);
                if (b <= d[c]) {
                    b = b + 10
                }
                a[c] = b
            }
        }
        this.radarAxisGlyph.radarMax = a;
        this.radarAxisGlyph.radarMin = d
    }, _getMaxValueFromCateData: function (c) {
        var d = 0;
        for (var a = 0; a < this.dataSeries.length; a++) {
            if (this.dataSeries[a].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var b = this.dataSeries[a].points[c];
            if (!b.valueIsNull) {
                d = (b.value > d) ? b.value : d
            }
        }
        if (d == this.getMinValueFromData(false)) {
            return d + 10
        }
        return d
    }, _getMinValueFromaCateData: function (d) {
        var c = 0;
        for (var a = 0; a < this.dataSeries.length; a++) {
            if (this.dataSeries[a].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var b = this.dataSeries[a].points[d];
            if (!b.valueIsNull) {
                c = (b.value < c) ? b.value : c
            }
        }
        return c
    }, getDrawSequence: function () {
        var a = [];
        var e = [];
        for (var c = 0; c < this.dataSeries.length; c++) {
            a[c] = c;
            e[c] = -1;
            var d = this.dataSeries[c];
            for (var b = 0; b < d.getDataPointCount(); b++) {
                if ((!d.points[b].valueIsNull) && Math.abs(d.points[b].value) > e[c]) {
                    e[c] = Math.abs(d.points[b].value)
                }
            }
        }
        a.sort(function (f, g) {
            return e[f] > e[g] ? -1 : e[f] < e[g] ? 1 : 0
        });
        return a
    }, draw: function (c, g, e) {
        this.drawInfo(c);
        if (this.radarAxisGlyph) {
            this.radarAxisGlyph.draw(c[1])
        }
        for (var d = 0, a = this.dataSeries.length; d < a; d++) {
            var b = 6;
            if (FR.Browser.isIE6()) {
                b = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[1];
                g = FR.Chart.ChartPaintConstants.ACTION_TIME[1]
            } else {
                if (e) {
                    b = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[e];
                    g = FR.Chart.ChartPaintConstants.ACTION_TIME[e]
                }
            }
            this.dataSeries[d].getAnimateGlyph(b, e)
        }
        var f = this.getAnimateStepNumber();
        if (f > 0) {
            this.animateGlyphDraw(c[2], g, f)
        } else {
            this.animateGlyphDraw(c[2], 1, 1)
        }
    }, getAnimateStepNumber: function () {
        var a = 0;
        while (this.dataSeries[a] && !(this.dataSeries[a].getAnimateStepNumber() > 0 && this.dataSeries[a].paintState != FR.Chart.ChartPaintConstants.STATE_UNENABLE)) {
            a++
        }
        if (this.dataSeries[a]) {
            return this.dataSeries[a].getAnimateStepNumber()
        } else {
            return -1
        }
    }, drawInfo: function (a) {
        this.info.paint(a[0], this.getOutline4Fill());
        if (this.radarAxisGlyph != null) {
            this.radarAxisGlyph.drawAxisGrid(a[1]);
            if (this.intervalColor) {
                this.radarAxisGlyph.paintRadarBackground(a[1], this.intervalColor)
            }
        }
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (b, a) {
        this.drawAfterAnimate4LineMarker(b, a)
    }
});
FR.Chart.StockPlotGlyph = FR.extend(FR.Chart.RectanglePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.errorImageIESrc = a.iesrc;
        this.errorImageSrc = a.src;
        this.errorToopTip = a.errorToopTip;
        this.upBarBorderLineStyle = FR.pick(a.upBarBorderLineStyle, 1);
        this.upBarBorderLineBackground = FR.pick(a.upBarBorderLineBackground, "red");
        this.upBarBackground = FR.pick(a.upBarBackground, "red");
        this.downBarBorderLineStyle = FR.pick(a.downBarBorderLineStyle, 1);
        this.downBarBorderLineBackground = FR.pick(a.downBarBorderLineBackground, "green");
        this.downBarBackground = FR.pick(a.downBarBackground, "green");
        this.highLowLineStyle = FR.pick(a.highLowLineStyle, 1);
        this.highLowLineColor = FR.pick(a.highLowLineColor, "black");
        FR.Chart.StockPlotGlyph.superclass.initConstants.apply(this, [a])
    }, configAxisLabels: function (b) {
        var a = this.xAxisGlyph;
        a.categoryLabelList = b.cateTime || [];
        if (a.categoryLabelList) {
            a.maxValue = a.categoryLabelList.length;
            a.minValue = 0;
            a.tickLength = a.isCustomMainUnit ? a.tickLength : 1;
            a.smallTickLength = a.isCustomSecUnit ? a.smallTickLength : this.tickLength / 5
        }
    }, isSupportLegend: function () {
        return false
    }, refreshAxisGlyph: function (a) {
        if (!a) {
            this.refreshAxisGlyphFromData();
            return
        }
        this.yAxisGlyph.oldMin = this.yAxisGlyph.minValue;
        this.yAxisGlyph.oldMax = this.yAxisGlyph.maxValue;
        this.yAxisGlyph.oldTick = this.yAxisGlyph.tickLength;
        this.yAxisGlyph.initMinMaxValue(this.getMinValueFromTableData(a, this.yAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_LEFT), this.getMaxValueFromTableData(a, FR.Chart.CustomAttr.Axis_LEFT));
        if (this.secondAxisGlyph) {
            this.secondAxisGlyph.oldMin = this.secondAxisGlyph.minValue;
            this.secondAxisGlyph.oldMax = this.secondAxisGlyph.maxValue;
            this.secondAxisGlyph.oldTick = this.secondAxisGlyph.tickLength;
            this.secondAxisGlyph.initMinMaxValue(this.getMinValueFromTableData(a, this.secondAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_RIGHT), this.getMaxValueFromTableData(a, FR.Chart.CustomAttr.Axis_RIGHT))
        }
    }, refreshAxisGlyphFromData: function () {
        this.yAxisGlyph.oldMin = this.yAxisGlyph.minValue;
        this.yAxisGlyph.oldMax = this.yAxisGlyph.maxValue;
        this.yAxisGlyph.oldTick = this.yAxisGlyph.tickLength;
        this.yAxisGlyph.initMinMaxValue(this.getMinValueFromData(this.yAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_LEFT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_LEFT));
        if (this.secondAxisGlyph) {
            this.secondAxisGlyph.oldMin = this.secondAxisGlyph.minValue;
            this.secondAxisGlyph.oldMax = this.secondAxisGlyph.maxValue;
            this.secondAxisGlyph.oldTick = this.secondAxisGlyph.tickLength;
            this.secondAxisGlyph.initMinMaxValue(this.getMinValueFromData(this.secondAxisGlyph.isLog, FR.Chart.CustomAttr.Axis_RIGHT), this.getMaxValueFromData(FR.Chart.CustomAttr.Axis_RIGHT))
        }
    }, findOnMoveGlyph: function (a, c, b) {
        if (this.xAxisGlyph && this.xAxisGlyph.isZoom && this.bounds.containsPoint(a.x, a.y)) {
            c._lastHover = this;
            c._draggingTarget = c._isMouseDown ? this : null
        }
        FR.Chart.StockPlotGlyph.superclass.findOnMoveGlyph.apply(this, [a, c, b])
    }, categoryInBounds: function (a, c) {
        if (!a.glyph) {
            return false
        }
        var b = a.glyph.getShape();
        if (b != null) {
            return FR.Chart.ChartUtils.rectangleOverlapped(b, c)
        }
    }, onDragEnd: function (c, j) {
        if (!this.bounds.containsPoint(c.x, c.y) || !this.bounds.containsPoint(j.x, j.y)) {
            return
        }
        var b = Math.min(c.x, j.x);
        var m = Math.min(c.y, j.y);
        var d = Math.abs(c.x - j.x);
        var l = Math.abs(c.y - j.y);
        var g = new FR.Chart.Bounds(b, m, d, l);
        if (this.xAxisGlyph && (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP)) {
            var k = this.getCategoryCount();
            var i = 0;
            for (var e = 0; e < this.dataSeries.length; e++) {
                var f = this.dataSeries[e];
                for (var h = 0; h < this.getCategoryCount(); h++) {
                    var a = f.points[h];
                    if (a.glyph != null && this.categoryInBounds(a, g)) {
                        if (k > f.points.length - 1 || !this.categoryInBounds(f.points[k], g)) {
                            k = h
                        }
                        if (!this.categoryInBounds(f.points[i], g)) {
                            i = h
                        }
                        k = this.xAxisGlyph.getTickIndex4Value(k) < this.xAxisGlyph.getTickIndex4Value(h) ? k : h;
                        i = this.xAxisGlyph.getTickIndex4Value(i) > this.xAxisGlyph.getTickIndex4Value(h) ? i : h
                    }
                }
            }
            if (k < this.getCategoryCount()) {
                this.xAxisGlyph.zoomBackward = this.xAxisGlyph.getOriginalCrossValue() - this.xAxisGlyph.getTickIndex4Value(k);
                this.xAxisGlyph.zoomForward = this.xAxisGlyph.getTickIndex4Value(i) + 1 - this.xAxisGlyph.getOriginalArrowValue()
            }
        }
    }, getMinValueFromData: function (a, g) {
        var f = 0;
        if (a) {
            f = Number.MAX_VALUE
        }
        var e = this.dataSeries[0];
        if (!e || e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return f
        }
        for (var c = 0;
             c < this.getCategoryCount(); c++) {
            var b = e.points[c];
            if (g == FR.Chart.CustomAttr.Axis_LEFT) {
                var d = b.values[1];
                f = this.getMinValue(a, f, d);
                d = b.values[2];
                f = this.getMinValue(a, f, d);
                d = b.values[3];
                f = this.getMinValue(a, f, d);
                d = b.values[4];
                f = this.getMinValue(a, f, d)
            } else {
                var d = b.values[0];
                f = this.getMinValue(a, f, d)
            }
        }
        if (f == Number.MAX_VALUE) {
            return 1
        }
        return f
    }, getMaxValueFromData: function (f) {
        var e = 0;
        var d = this.dataSeries[0];
        if (!d || d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
            return e
        }
        for (var b = 0; b < this.getCategoryCount();
             b++) {
            var a = d.points[b];
            if (f == FR.Chart.CustomAttr.Axis_LEFT) {
                var c = a.values[1];
                e = this.getMaxValue(e, c);
                c = a.values[2];
                e = this.getMaxValue(e, c);
                c = a.values[3];
                e = this.getMaxValue(e, c);
                c = a.values[4];
                e = this.getMaxValue(e, c)
            } else {
                var c = a.values[0];
                if (!c || isNaN(c)) {
                    continue
                }
                e = this.getMaxValue(e, c)
            }
        }
        if (FR.Chart.CustomAttr.Axis_RIGHT == f) {
            e = e * 4
        }
        if (e == this.getMinValueFromData(false, f)) {
            return e + 10
        }
        return e
    }, getMinValueFromTableData: function (e, a, f) {
        var d = 0;
        if (a) {
            d = Number.MAX_VALUE
        }
        for (var c = 0; c < e.getCategoryLabelCount();
             c++) {
            if (f == FR.Chart.CustomAttr.Axis_LEFT) {
                var b = e.getOpenValue(c);
                d = this.getMinValue(a, d, b);
                b = e.getHighValue(c);
                d = this.getMinValue(a, d, b);
                b = e.getLowValue(c);
                d = this.getMinValue(a, d, b);
                b = e.getCloseValue(c);
                d = this.getMinValue(a, d, b)
            } else {
                var b = e.getVolume(c);
                d = this.getMinValue(a, d, b)
            }
        }
        if (d == Number.MAX_VALUE) {
            return 1
        }
        return d
    }, getMinValue: function (a, d, c) {
        if (c == null || c == undefined) {
            return d
        }
        if (a) {
            var b = c;
            if (b < d) {
                if (b > 0 && b < 1) {
                    d = b
                }
            }
        } else {
            d = (c < d) ? c : d
        }
        return d
    }, getMaxValueFromTableData: function (c, e) {
        var d = 0;
        for (var b = 0; b < c.getCategoryLabelCount(); b++) {
            if (e == FR.Chart.CustomAttr.Axis_LEFT) {
                var a = c.getOpenValue(b);
                d = this.getMaxValue(d, a);
                a = c.getHighValue(b);
                d = this.getMaxValue(d, a);
                a = c.getLowValue(b);
                d = this.getMaxValue(d, a);
                a = c.getCloseValue(b);
                d = this.getMaxValue(d, a)
            } else {
                var a = c.getVolume(b);
                d = this.getMaxValue(d, a)
            }
        }
        if (FR.Chart.CustomAttr.Axis_RIGHT == e) {
            d = d * 4
        }
        if (d == this.getMinValueFromData(c, false, e)) {
            return d + 10
        }
        return d
    }, dealLine4DemoGlyph: function (c, q, d, p) {
        var n = [];
        var g = [];
        var e = 0;
        var b = new FR.Chart.GeneralPath();
        var f = new FR.Chart.GeneralPath();
        if (d.axisReversed) {
            b.axisReversed = true;
            f.axisReversed = true
        }
        var k = true;
        for (var m = 0; m < c.getDataPointCount(); m++) {
            var a = c.points[m];
            if (a.valueIsNull) {
                if (this.isNullValueBreak) {
                    k = true
                }
                continue
            }
            var j = q.getDataPointPercentValue(c.seriesIndex, m);
            var l = d.getPoint2D(d.getTickIndex4Value(m) + d.labelOffset).x;
            if (this.isDataPointXNotInPlotBounds(l)) {
                continue
            }
            var i = p.getPoint2D(j).y;
            n[e] = l;
            g[e] = i;
            e++;
            if (this.isCurve) {
                if (k) {
                    FR.Chart.FoldLine.curveTo(b, f);
                    f.clear();
                    f.moveTo(l, i);
                    b.moveTo(l, i);
                    k = false
                } else {
                    f.lineTo(l, i)
                }
            } else {
                if (k) {
                    b.moveTo(l, i);
                    k = false
                } else {
                    b.lineTo(l, i)
                }
            }
        }
        if (this.isCurve) {
            FR.Chart.FoldLine.curveTo(b, f)
        }
        var h = new FR.Chart.FoldLine(b);
        c.glyph = h;
        h.lineStyleInfo.dealCondition(this.conditionCollection, c, this.createColors4Series());
        if (h.lineStyleInfo.attrLineColor.seriesColor) {
            var o = new FR.Chart.ColorBackground();
            o.color = h.lineStyleInfo.attrLineColor.seriesColor;
            h.toolTipBackground = o
        }
    }, getDataPointPercentValue: function (a, f) {
        var c = this.dataSeries[a].points[f].values[4];
        if (!this.yAxisGlyph.isPercentage) {
            return c
        }
        var e = 0;
        for (var b = 0; b < this.dataSeries.length; b++) {
            var d = this.dataSeries[b];
            e = e + Math.abs(d.points[f].values[4])
        }
        if (e === 0) {
            return 0
        }
        return c / e
    }, getMaxValue: function (b, a) {
        return a ? Math.max(a, b) : b
    }, addSeries2PlotGlyph: function (d, b) {
        this.dataSeries = [];
        var e = new FR.Chart[b.dataSeries];
        e.seriesName = "stock";
        e.seriesIndex = 0;
        e.points = [];
        this.dataSeries.push(e);
        for (var i = 0; i < d.getCategoryLabelCount(); i++) {
            var a = new FR.Chart[b.dataPoint];
            var j = d.getCloseValue(i);
            var h = d.getLowValue(i);
            var c = d.getHighValue(i);
            var g = d.getVolume(i);
            var f = d.getOpenValue(i);
            a.values = [];
            a.values.push(g);
            a.values.push(f);
            a.values.push(c);
            a.values.push(h);
            a.values.push(j);
            a.seriesIndex = 0;
            a.categoryIndex = i;
            a.categoryName = d.getCategoryLabel(i);
            a.seriesName = "stock";
            e.points[i] = a
        }
        this.refreshAxisGlyph(d)
    }, installSeriesWithOptionData: function (g, a) {
        if (g && g.category && g.value) {
            var e = g.category;
            var h = [];
            var j = [];
            var l = [];
            var b = [];
            var k = [];
            for (var f = 0; f < g.value.length; f++) {
                var d = g.value[f];
                if (d.length === 5) {
                    h.push(d[0]);
                    j.push(d[1]);
                    b.push(d[2]);
                    k.push(d[3]);
                    l.push(d[4])
                }
            }
            var c = new FR.Chart.StockChartData(e, j, l, k, b);
            this.addSeries2PlotGlyph(c, a);
            this.refreshAxisGlyph(c)
        }
    }, layoutAxisGlyph: function () {
        FR.Chart.StockPlotGlyph.superclass.layoutDoubleAxisGlyph.apply(this, [this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph])
    }, layoutLargeDataSeries4StockChart: function (r) {
        var s = this.dataSeries[0];
        if (!s) {
            return
        }
        this.xAxisGlyph.stockChartMinDateInt = null;
        if (this.isStockChart) {
            for (var w = 0; w < s.getDataPointCount(); w++) {
                s.points[w].revert2Original()
            }
            this.refreshDataPointLabel()
        }
        var k = null;
        var u = null;
        var p = [];
        var m = this.getBounds();
        for (var w = s.getDataPointCount() - 1, x = s.getDataPointCount(); w >= 0; w--) {
            var f = s.points[w];
            f.glyph = null;
            f.highLowLine = null;
            f.volumeGlyph = null;
            if (f.valueIsNull) {
                continue
            }
            var g = this.xAxisGlyph;
            var l = Math.round(g.getPoint2D(g.getTickIndex4Value(w) + g.labelOffset).x);
            if (l < m.x || l > m.x + m.width) {
                continue
            }
            var y = g.getDate4Value(w);
            if (p.length === 0) {
                k = y;
                p[0] = f;
                f.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(y, r);
                u = f;
                u.stockDataPointCount = 1;
                continue
            } else {
                if (FR.Chart.ChartUtils.isBelongToSameUnit(k, y, r)) {
                    u.addDataPoint4StockCategory(f);
                    u.stockDataPointCount++;
                    f.valueIsNull = true;
                    continue
                }
            }
            var o = this.getStockDateRangeIndex(p, y, g, r);
            if (o !== -1) {
                p[o].addDataPoint4StockCategory(f);
                f.valueIsNull = true;
                u.stockDataPointCount++
            } else {
                f.categoryName = FR.Chart.ChartUtils.calculateAdjustDateRange(y, r);
                p[p.length] = f;
                k = y;
                u = f;
                u.stockDataPointCount = 1
            }
        }
        this.xAxisGlyph.stockChartMainType = r;
        this.refreshAxisGlyphFromData();
        this.yAxisGlyph.calculateAxisGlyph(this.bounds);
        this.secondAxisGlyph.calculateAxisGlyph(this.bounds);
        var h = 0;
        if (this.secondAxisGlyph && this.secondAxisGlyph.isLog) {
            h = 1
        }
        var b = [];
        var c = [];
        var t = 0;
        var j = -1;
        for (var o = p.length - 1; o >= 0; o--) {
            var f = p[o];
            var z = f.values;
            var v = z[0], n = z[1], i = z[2], A = z[3], q = z[4];
            var e = this.xAxisGlyph.unitLength * f.stockDataPointCount;
            var d = parseInt(e * 0.5);
            var a = Math.max(e - d, 1);
            var l = this.getStockChartDatePointX(g, f, r, m);
            if (j < 0) {
                j = Math.abs(l - this.getStockChartDatePointX(g, p[o - 1], r, m))
            }
            this.dealDataPointGlyph(m, x, v, i, A, n, q, f, l, j, a, h, b, c, t);
            t++
        }
        this.trendLineFitting(b, c, s, this.yAxisGlyph);
        this.refreshDataPointLabel()
    }, dealDataPointGlyph: function (r, z, x, o, D, s, t, l, q, n, b, m, e, i, w) {
        if (FR.Browser.isIE9()) {
            q += 0.5
        }
        var A = l.categoryIndex;
        var a = q - n / 2;
        var y = n;
        if (A === 0 && a > r.x) {
            y += a - r.x;
            a = r.x
        } else {
            if (A === 0 && a < r.x) {
                y -= r.x - a;
                a = r.x
            } else {
                if (A === z - 1 && (a + y) < (r.x + r.width)) {
                    y += (r.x + r.width) - (a + y)
                }
            }
        }
        l.choosedBounds = new FR.Chart.Bounds(a, r.y, y, r.height);
        var h = this._getValueInBounds(this.yAxisGlyph.getPoint2D(o).y);
        var d = this._getValueInBounds(this.yAxisGlyph.getPoint2D(D).y);
        var u = this._getValueInBounds(this.yAxisGlyph.getPoint2D(s).y);
        var k = this._getValueInBounds(this.yAxisGlyph.getPoint2D(t).y);
        var c = parseInt(b);
        var p = new FR.Chart.ShapeGlyph();
        l.glyph = p;
        l.glyph.setShape(new FR.Chart.Bounds(0, 0, 0, 0));
        var f = new FR.Chart.FoldLine();
        var v = new FR.Chart.GeneralPath();
        v.yZero = d;
        v.moveTo(q, h);
        v.lineTo(q, d);
        f.generalPath = v;
        l.highLowLine = f;
        if (isNaN(x) && isNaN(s)) {
            p.setShape(new FR.Chart.Bounds(q - b, k, b, 1));
            p.info.dealCondition(this.conditionCollection, l, this.createColors4Series());
            f.lineStyleInfo.attrLineColor.seriesColor = this.highLowLineColor;
            f.lineStyleInfo.attrLineStyle.lineStyle = this.highLowLineStyle;
            if (f.lineStyleInfo.attrLineColor.seriesColor) {
                var g = new FR.Chart.ColorBackground();
                g.color = f.lineStyleInfo.attrLineColor.seriesColor;
                f.toolTipBackground = g
            }
        } else {
            if (isNaN(x)) {
                this._dealUpDown(u, k, q, f, p, b, null)
            } else {
                if (isNaN(s)) {
                    var j = this.secondAxisGlyph.getPoint2D(x).y;
                    var B = this.secondAxisGlyph.getPoint2D(m).y - j;
                    var C = new FR.Chart.ShapeGlyph();
                    C.setShape(new FR.Chart.Bounds(q - c / 2, j, c, B));
                    l.volumeGlyph = C;
                    C.info.dealCondition(this.conditionCollection, l, this.createColors4Series());
                    C.toolTipBackground = C.info.getBackground();
                    p.setShape(new FR.Chart.Bounds(q - b, k, b, 1));
                    p.info.dealCondition(this.conditionCollection, l, this.createColors4Series());
                    f.lineStyleInfo.attrLineColor.seriesColor = this.highLowLineColor;
                    f.lineStyleInfo.attrLineStyle.lineStyle = this.highLowLineStyle;
                    if (f.lineStyleInfo.attrLineColor.seriesColor) {
                        var g = new FR.Chart.ColorBackground();
                        g.color = f.lineStyleInfo.attrLineColor.seriesColor;
                        f.toolTipBackground = g
                    }
                } else {
                    var j = this.secondAxisGlyph.getPoint2D(x).y;
                    var B = this.secondAxisGlyph.getPoint2D(m).y - j;
                    var C = new FR.Chart.ShapeGlyph();
                    C.setShape(new FR.Chart.Bounds(q - c / 2, j, c, B));
                    l.volumeGlyph = C;
                    C.info.dealCondition(this.conditionCollection, l, this.createColors4Series());
                    C.toolTipBackground = C.info.getBackground();
                    this._dealUpDown(u, k, q, f, p, b, C)
                }
            }
        }
        p.toolTipBackground = p.info.getBackground();
        e[w] = q;
        i[w] = k
    }, layoutDataSeriesGlyph: function () {
        if (this.errorImageIESrc || this.errorImageSrc) {
            var z = "<br />";
            var t = "";
            t += FR.i18nText("Chart-Stock_Error") + z;
            t += this.errorToopTip + FR.i18nText("Chart-Use_Data") + z;
            t += FR.i18nText("Chart-Stock_Check_Data");
            this.errorDataTip = t;
            return
        }
        this.xAxisGlyph.stockChartMinDateInt = null;
        this.xAxisGlyph.stockChartMainType = null;
        var m = this.getBounds();
        var f = this.xAxisGlyph.unitLength;
        var e = parseInt(f * 0.5);
        var a = Math.max(f - e, 1);
        var b = parseInt(a);
        var i = 0;
        if (this.secondAxisGlyph && this.secondAxisGlyph.isLog) {
            i = 1
        }
        var r = this.dataSeries[0];
        if (!r) {
            return
        }
        if (this.isStockChart) {
            for (var x = 0;
                 x < r.getDataPointCount(); x++) {
                r.points[x].revert2Original()
            }
            this.refreshDataPointLabel()
        }
        var c = [];
        var d = [];
        var s = 0;
        var k = -1;
        var n = null;
        for (var x = 0, y = r.getDataPointCount(); x < y; x++) {
            var g = r.points[x];
            if (g.valueIsNull) {
                g.glyph = null;
                g.highLowLine = null;
                g.volumeGlyph = null;
                continue
            }
            var A = g.values;
            var u = A[0], o = A[1], j = A[2], B = A[3], q = A[4];
            var h = this.xAxisGlyph;
            var l = Math.round(h.getPoint2D(h.getTickIndex4Value(x) + h.labelOffset).x);
            if (l < m.x || l > m.x + m.width) {
                g.glyph = null;
                g.highLowLine = null;
                g.volumeGlyph = null;
                continue
            }
            if (this.isStockChart) {
                var w = h.getDate4Value(x);
                if (b < 2 && n) {
                    var v = this.getStockChartAdjustDateType(w, n);
                    if (v !== FR.Chart.Constants.YEAR || v !== FR.Chart.Constants.MONTH) {
                        v = FR.Chart.Constants.MONTH
                    }
                    return this.layoutLargeDataSeries4StockChart(v)
                }
                n = w
            }
            if (k < 0) {
                var p = Math.round(h.getPoint2D(h.getTickIndex4Value(x + 1) + h.labelOffset).x);
                k = p - l
            }
            this.dealDataPointGlyph(m, y, u, j, B, o, q, g, l, k, a, i, c, d, s);
            s++
        }
        this.trendLineFitting(c, d, r, this.yAxisGlyph)
    }, _getValueInBounds: function (a) {
        if (a < 0) {
            a = 0
        }
        if (a > this.bounds.y + this.bounds.height) {
            a = this.bounds.y + this.bounds.height
        }
        return a
    }, _dealUpDown: function (e, g, c, h, f, d, b) {
        if (e > g) {
            var a = new FR.Chart.Bounds(c - d / 2, g, d, e - g);
            a.upDown = 1;
            f.setBackground(FR.Chart.ColorBackground.getInstance(this.upBarBackground));
            f.setBorderColor(this.upBarBorderLineBackground);
            f.setBorderStyle(this.upBarBorderLineStyle);
            f.setShape(a);
            h.lineStyleInfo.attrLineColor.seriesColor = this.upBarBackground;
            h.generalPath.upDown = 1;
            if (b) {
                b.setBackground(FR.Chart.ColorBackground.getInstance(this.upBarBackground))
            }
        } else {
            var a = new FR.Chart.Bounds(c - d / 2, e, d, g - e);
            a.upDown = -1;
            f.setBackground(FR.Chart.ColorBackground.getInstance(this.downBarBackground));
            f.setBorderColor(this.downBarBorderLineBackground);
            f.setBorderStyle(this.downBarBorderLineStyle);
            f.setShape(a);
            h.lineStyleInfo.attrLineColor.seriesColor = this.downBarBackground;
            h.generalPath.upDown = -1;
            if (b) {
                b.setBackground(FR.Chart.ColorBackground.getInstance(this.downBarBackground))
            }
        }
    }, draw: function (b, g, d) {
        if (this.errorImageSrc || this.errorImageIESrc) {
            var a = b[2];
            if (!a) {
                return
            }
            a.save();
            var f = new Image();
            var e = this.getBounds().x + this.getBounds().width / 2;
            var c = this.getBounds().y + this.getBounds().height / 2;
            f.onload = function () {
                setTimeout(function () {
                    a.drawImage(f, e - f.width / 2, c - f.height / 2, f.width, f.height)
                }, 100)
            };
            if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
                f.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.errorImageIESrc
            } else {
                f.src = this.errorImageSrc
            }
            a.restore()
        }
        FR.Chart.StockPlotGlyph.superclass.draw.apply(this, [b, g, d])
    }
});
$.extend(FR.Chart.StockPlotGlyph, {
    HIGH_LOW_CLOSE: 0,
    OPEN_HIGH_LOW_CLOSE: 1,
    VOLUME_HIGH_LOW_CLOSE: 2,
    VOLUME_OPEN_HIGH_LOW_CLOSE: 3
});
FR.Chart.XYScatterPlotGlyph = FR.extend(FR.Chart.RectanglePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isCurve = a.isCurve;
        FR.Chart.XYScatterPlotGlyph.superclass.initConstants.apply(this, [a])
    }, getSecondValueAxisGlyph: function () {
        return this.xAxisGlyph
    }, configSeries: function (d) {
        this.isCurve = FR.pick(d.isCurve, false);
        this.isNullValueBreak = FR.pick(d.isNullValueBreak, true);
        var c = this.conditionCollection.defaultAttr;
        var b = new FR.Chart.AttrLineStyle();
        c.addAttr(b);
        if (d.lineStyle != null && d.lineStyle != undefined) {
            b.lineStyle = d.lineStyle
        } else {
            b.lineStyle = FR.Chart.Constants.LINE_NONE
        }
        if (d.markerType) {
            var a = new FR.Chart.AttrMarkerType();
            a.markerType = d.markerType;
            c.addAttr(a)
        }
        FR.Chart.XYScatterPlotGlyph.superclass.configSeries.apply(this, [d])
    }, addSeries2PlotGlyph: function (h, e) {
        this.dataSeries = [];
        for (var d = 0; d < h.getItemCount(); d++) {
            var c = new FR.Chart[e.dataSeries]();
            c.points = [];
            c.seriesIndex = d;
            c.seriesName = h.getOriginalItem(d);
            for (var g = 0; g < h.getCategoryLabelCount(); g++) {
                var a = new FR.Chart[e.dataPoint]();
                a.categoryIndex = g;
                a.seriesIndex = d;
                var b = h.getX(d, g);
                var f = h.getY(d, g);
                a.x = b ? b : 0;
                a.categoryOriginalName = a.x + "";
                a.value = f ? f : 0;
                if (b == null || f == null) {
                    a.valueIsNull = true
                }
                a.seriesName = h.getOriginalItem(d);
                c.points.push(a)
            }
            this.dataSeries[d] = c
        }
    }, installSeriesWithOptionData: function (f, c) {
        this.dataSeries = [];
        if (f) {
            for (var g = 0; g < f.length; g++) {
                var e = f[g];
                var b = new FR.Chart[c.dataSeries]();
                b.points = [];
                b.seriesIndex = e.seriesIndex;
                b.seriesName = e.seriesName;
                var k = e.value;
                for (var j = 0, h = k.length; j < h; j++) {
                    var a = new FR.Chart[c.dataPoint]();
                    a.seriesIndex = e.seriesIndex;
                    a.seriesName = e.seriesName;
                    var d = k[j];
                    a.x = d[0];
                    a.value = d[1];
                    b.points[j] = a
                }
                this.dataSeries[g] = b
            }
        }
    }, getLegendMarkerIcon: function (b, a) {
        return this.getLegendMarkerIcon4Line(b, a)
    }, refreshAxisGlyph: function () {
        this.refreshAxisGlyph4XY()
    }, isSupportTwoStepDraw: function () {
        return true
    }, getDataPointByPara: function (a) {
        return this._getDataPointByXY(a)
    }, layoutDataSeriesGlyph: function () {
        for (var c = 0; c < this.dataSeries.length; c++) {
            var d = this.dataSeries[c];
            d.lastGlyph = d.glyph;
            if (d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var n = [];
            var g = [];
            var e = 0;
            var b = new FR.Chart.GeneralPath();
            var f = new FR.Chart.GeneralPath();
            b.yZero = this.yAxisGlyph.bounds.y + this.yAxisGlyph.bounds.height / 2;
            var k = true;
            for (var m = 0; m < d.getDataPointCount(); m++) {
                var a = d.points[m];
                a.lastGlyph = a.glyph;
                if (a.valueIsNull) {
                    if (this.isNullValueBreak) {
                        k = true
                    }
                    continue
                }
                var l = this.xAxisGlyph.getPoint2D(a.x).x;
                var j = this.getStartY(a);
                if (this.isDataPointXNotInPlotBounds(l)) {
                    continue
                }
                n[e] = l;
                g[e] = j;
                e++;
                if (this.isCurve) {
                    if (k) {
                        FR.Chart.FoldLine.curveTo(b, f);
                        f.clear();
                        f.moveTo(l, j);
                        b.moveTo(l, j);
                        k = false
                    } else {
                        f.lineTo(l, j)
                    }
                } else {
                    if (k) {
                        b.moveTo(l, j);
                        k = false
                    } else {
                        b.lineTo(l, j)
                    }
                }
                var i = new FR.Chart.MarkerGlyph();
                i.dealCondition4Line(this.conditionCollection, a, this.createColors4Series());
                i.setShape(new FR.Chart.Bounds(l - FR.Chart.Constants.MarkerDefaultSize / 2, j - FR.Chart.Constants.MarkerDefaultSize / 2, FR.Chart.Constants.MarkerDefaultSize, FR.Chart.Constants.MarkerDefaultSize));
                i.background = this.getBackground() !== null ? this.getBackground() : this.wholeChartBackground;
                a.glyph = i;
                i.toolTipBackground = i.background;
                this.dealDataPointLabel(a)
            }
            if (this.isCurve) {
                FR.Chart.FoldLine.curveTo(b, f)
            }
            var h = new FR.Chart.FoldLine();
            d.glyph = h;
            d.isPointAnimate = true;
            h.generalPath = b;
            h.generalPath.isXYScatter = true;
            h.lineStyleInfo.dealCondition(this.conditionCollection, d, this.createColors4Series());
            if (h.lineStyleInfo.attrLineColor.seriesColor) {
                var o = new FR.Chart.ColorBackground();
                o.color = h.lineStyleInfo.attrLineColor.seriesColor;
                h.toolTipBackground = o
            }
            if (h.lineStyleInfo.attrLineStyle.lineStyle === FR.Chart.Constants.LINE_NONE) {
                d.glyph = null
            }
            this.trendLineFitting(n, g, d, this.getSeriesAxisGlyph(c))
        }
        this.dealLabelBoundsInOrder()
    }, getDataPointLabelBoundsWithPosition: function (c, b, a) {
        return this.getDataPointLabelBoundsWithPosition4Line(c, b, a)
    }, getAnimateStepNumber: function () {
        var a = 0;
        while (this.dataSeries[a] && !(this.dataSeries[a].getAnimateStepNumber() > 0 && this.dataSeries[a].paintState != FR.Chart.ChartPaintConstants.STATE_UNENABLE)) {
            a++
        }
        if (this.dataSeries[a]) {
            return this.dataSeries[a].getAnimateStepNumber()
        } else {
            return -1
        }
    }
});
FR.Chart.BubblePlotGlyph = FR.extend(FR.Chart.RectanglePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.maxBubblePixel = FR.pick(a.maxBubblePixel, 30);
        this.seriesEqualsBubbleInWidthOrArea = FR.pick(a.compareRule, FR.Chart.Constants.BubbleType_Width);
        this.isShowNegativeBubble = FR.pick(a.isShowNegativeBubble, true);
        this.customizedMaxValue = FR.pick(a.customizedMaxValue, -1);
        FR.Chart.BubblePlotGlyph.superclass.initConstants.apply(this, [a])
    }, getSecondValueAxisGlyph: function () {
        return this.xAxisGlyph
    }, configSeries: function (a) {
        this.maxBubblePixel = FR.pick(a.maxBubblePixel, 30);
        this.seriesEqualsBubbleInWidthOrArea = FR.pick(a.compareRule, FR.Chart.Constants.BubbleType_Width);
        this.isShowNegativeBubble = FR.pick(a.isShowNegativeBubble, true)
    }, addSeries2PlotGlyph: function (d, b) {
        this.dataSeries = [];
        for (var e = 0; e < d.getItemCount(); e++) {
            var f = new FR.Chart[b.dataSeries];
            f.seriesName = d.getOriginalItem(e);
            f.points = [];
            for (var h = 0; h < d.getCategoryLabelCount(); h++) {
                var a = new FR.Chart[b.dataPoint];
                a.categoryIndex = h;
                a.seriesIndex = e;
                var g = d.getX(e, h);
                var c = d.getY(e, h);
                var j = d.getSize(e, h);
                a.x = g ? g : 0;
                a.value = c ? c : 0;
                a.sizeValue = j ? j : 0;
                if (g == null || c == null || j == null) {
                    a.valueIsNull = true
                }
                a.categoryName = a.value + "";
                a.seriesName = d.getOriginalItem(e);
                f.points[h] = a
            }
            f.seriesIndex = e;
            this.dataSeries[e] = f
        }
    }, installSeriesWithOptionData: function (f, c) {
        this.dataSeries = [];
        if (f) {
            for (var g = 0; g < f.length; g++) {
                var e = f[g];
                var b = new FR.Chart[c.dataSeries]();
                b.points = [];
                b.seriesIndex = e.seriesIndex;
                b.seriesName = e.seriesName;
                var k = e.value;
                for (var j = 0, h = k.length; j < h; j++) {
                    var a = new FR.Chart[c.dataPoint]();
                    a.seriesIndex = e.seriesIndex;
                    a.seriesName = e.seriesName;
                    var d = k[j];
                    a.x = d[0];
                    a.value = d[1];
                    a.sizeValue = d[2];
                    b.points[j] = a
                }
                this.dataSeries[g] = b
            }
        }
    }, getLegendMarkerIcon: function (c, b) {
        var e = new FR.Chart.LineMarkerIcon();
        var a = new FR.Chart.CircleFilledMarker();
        var d = this.conditionCollection.getConditionAttr(new FR.Chart.AttrColor(), c, b);
        a.background = FR.Chart.ColorBackground.getInstance(d.seriesColor);
        e.marker = a;
        this.dealCondition(e, c, b);
        return e
    }, getDataPointByPara: function (a) {
        return this._getDataPointByXY(a)
    }, refreshAxisGlyph: function () {
        this.refreshAxisGlyph4XY()
    }, isSupportTwoStepDraw: function () {
        return true
    }, getMarkerSize: function () {
        return this.maxBubblePixel
    }, layoutDataSeriesGlyph: function () {
        var l = this.getBounds();
        for (var f = 0; f < this.dataSeries.length; f += 1) {
            var g = this.dataSeries[f];
            if (g.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var n = 0; n < g.getDataPointCount(); n++) {
                var b = g.points[n];
                b.lastGlyph = b.glyph;
                if (b.valueIsNull) {
                    continue
                }
                var m = b.sizeValue;
                if (m < 0) {
                    if (!this.isShowNegativeBubble) {
                        continue
                    }
                }
                var j = this.xAxisGlyph.getPoint2D(b.x).x;
                var i = this.getSeriesAxisGlyph(f).getPoint2D(b.value).y;
                var h = this.getRadius(m, this.getMaxSize());
                var e = l.x;
                var c = l.x + l.width;
                var d = l.y;
                var a = l.y + l.height;
                if ((j + h / 2) < e || (j - h / 2) > c || (i + h / 2) < d || (i - h / 2) > a) {
                    b.glyph = null;
                    continue
                }
                var k = new FR.Chart.Bubble(j, i, h / 2);
                b.glyph = k;
                k.colorInfo.dealCondition(this.conditionCollection, b, this.createColors4Series());
                k.toolTipBackground = new FR.Chart.ColorBackground({"color": k.colorInfo.getSeriesColor()});
                if (this.isShowNegativeBubble && m < 0) {
                    k.colorInfo.seriesAttrColor.seriesColor = "gray"
                }
                this.dealDataPointLabel(b)
            }
        }
        this.dealLabelBoundsInOrder()
    }, getMaxSize: function () {
        if (this.customizedMaxValue > 0) {
            return this.customizedMaxValue
        }
        var f = 0;
        for (var b = 0; b < this.dataSeries.length; b += 1) {
            var d = this.dataSeries[b];
            for (var c = 0; d && c < d.getDataPointCount(); c++) {
                var a = d.points[c];
                var e = a.sizeValue;
                if (this.isShowNegativeBubble) {
                    f = Math.max(f, Math.abs(e))
                } else {
                    f = Math.max(f, e)
                }
            }
        }
        return f
    }, getRadius: function (b, c) {
        if (c <= 0) {
            return 0
        }
        var a = 0;
        if (this.seriesEqualsBubbleInWidthOrArea == FR.Chart.Constants.BubbleType_Width) {
            a = this.maxBubblePixel * Math.abs(b) / c
        } else {
            a = Math.sqrt(this.maxBubblePixel * this.maxBubblePixel * Math.abs(b) / c)
        }
        return a
    }, getDataPointLabelBoundsWithPosition: function (f, e, b) {
        var d = e.x + (e.width - f.width) / 2;
        var c;
        var a = 3;
        if (b == FR.Chart.Constants.OUTSIDE) {
            c = e.y - f.height - a
        } else {
            c = e.y + (e.height - f.height) / 2
        }
        return new FR.Chart.Bounds(d, c, f.width, f.height)
    }, getAnimateStepNumber: function () {
        var a = 0;
        while (this.dataSeries[a] && !(this.dataSeries[a].getAnimateStepNumber() > 0 && this.dataSeries[a].paintState != FR.Chart.ChartPaintConstants.STATE_UNENABLE)) {
            a++
        }
        if (this.dataSeries[a]) {
            return this.dataSeries[a].getAnimateStepNumber()
        } else {
            return -1
        }
    }, redoListDrawDataPoint: function () {
        var f = [];
        for (var b = 0; b < this.dataSeries.length;
             b++) {
            var d = this.dataSeries[b];
            if (d.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var c = 0; c < d.getDataPointCount(); c++) {
                var a = d.points[c];
                if (a && a.glyph) {
                    f[f.length] = a
                }
            }
        }
        f.sort(function e(g, h) {
            return g.sizeValue - h.sizeValue
        });
        return f
    }, findOnMoveGlyph: function (a, h, c) {
        var g = this.getBounds();
        if (this.xAxisGlyph) {
            this.xAxisGlyph.findOnMoveGlyph(a, h, c)
        }
        if (this.yAxisGlyph) {
            this.yAxisGlyph.findOnMoveGlyph(a, h, c)
        }
        if (this.secondAxisGlyph) {
            this.secondAxisGlyph.findOnMoveGlyph(a, h, c)
        }
        if (h._hasfound) {
            return
        }
        if (a.y < g.y || a.x < g.x || a.x > g.x + g.width || a.y > g.y + g.height) {
            return
        }
        var f = this.redoListDrawDataPoint();
        for (var e = 0; e < f.length; e++) {
            var b = f[e];
            if (b.containsMousePos(a)) {
                h._hasfound = true;
                h._lastHover = b;
                if (b.hyperlink) {
                    h.cursor = ChartHandler.POINTER
                }
                if (h._isMouseDown && !h._isMouseMoving) {
                    var d = this.dataSeries[b.seriesIndex];
                    if (d) {
                        h._draggingTarget = d;
                        d.paintState = FR.Chart.ChartPaintConstants.STATE_TRANSPARENT
                    }
                }
                break
            }
        }
    }
});
FR.Chart.RangePlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.rangeAxisGlyph = new FR.Chart.RangeAxisGlyph(a.rangeAxisGlyph);
        this.seriesWidth = FR.pick(a.seriesWidth, 2);
        FR.Chart.RangePlotGlyph.superclass.initConstants.apply(this, [a])
    }, layoutAxisGlyph: function () {
        this.rangeAxisGlyphList = [];
        var f = this.getCategoryCount();
        var i = this.getBounds();
        var h = i.height;
        var g = i.width;
        var b = h / (f * 2) > 50 ? 50 : h / (f * 2);
        var e = i.clone();
        for (var j = 0; j < f; j++) {
            var d = i.y + (j + 1) * h / (1 + f) - b / 2;
            var a = new FR.Chart.Bounds(i.x, d, g, b);
            var c = new FR.Chart.RangeAxisGlyph(this.rangeAxisGlyph);
            c.dealPlotBoundsWithAxisLabel(e);
            c.plotZeroBounds = e;
            c.init(a, h);
            c.calculateAxisLengthUnit();
            this.rangeAxisGlyphList.push(c)
        }
        this.dealPlotBounds4JSDraw(this.getBounds())
    }, refreshAxisGlyph: function () {
        this.rangeAxisGlyph.oldMin = this.rangeAxisGlyph.minValue;
        this.rangeAxisGlyph.oldMax = this.rangeAxisGlyph.maxValue;
        this.rangeAxisGlyph.oldTick = this.rangeAxisGlyph.tickLength;
        this.rangeAxisGlyph.initMinMaxValue(this.getMinValueFromData(this.rangeAxisGlyph.isLog), this.getMaxValueFromData())
    }, layoutDataSeriesGlyph: function () {
        for (var f = 0; f < this.getCategoryCount();
             f++) {
            for (var d = 0; d < this.dataSeries.length; d++) {
                var e = this.dataSeries[d];
                if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    continue
                }
                var a = e.points[f];
                a.lastGlyph = a.glyph;
                if (a.valueIsNull) {
                    a.glyph = null;
                    continue
                }
                var c = this.rangeAxisGlyphList[f];
                var i = c.getPoint2D(a.value);
                var h = c.bounds.height;
                var g = new FR.Chart.Bounds(i.x - this.seriesWidth * 0.5, i.y - h * 0.5, this.seriesWidth, h);
                g.is4RangePlot = true;
                var b = new FR.Chart.ShapeGlyph();
                b.shape = g;
                b.info.dealCondition(this.conditionCollection, a, this.createColors4Series());
                b.toolTipBackground = b.info.getBackground();
                a.glyph = b;
                this.dealDataPointLabel(a)
            }
        }
        this.dealLabelBoundsInOrder()
    }, drawAxisGrid: function (a) {
        if (this.rangeAxisGlyphList != null && this.rangeAxisGlyphList.length > 0) {
            for (var b = 0; b < this.rangeAxisGlyphList.length; b++) {
                this.rangeAxisGlyphList[b].drawAxisGrid(a)
            }
        }
    }, getDataPointLabelBoundsWithPosition: function (f, e, a) {
        var d = e.x + (e.width - f.width) / 2;
        var c = 0;
        var b = 2;
        switch (a) {
            case FR.Chart.Constants.TOP:
                c = e.y - f.height - b;
                break;
            case FR.Chart.Constants.BOTTOM:
                c = e.y + e.height + b;
                break;
            default:
                d = e.x + e.width + b;
                c = e.y + (e.height - f.height) / 2
        }
        return new FR.Chart.Bounds(d, c, f.width, f.height)
    }, draw: function (c, h, f) {
        this.drawInfo(c);
        this.drawAxisGrid(c[1]);
        if (this.rangeAxisGlyphList != null && this.rangeAxisGlyphList.length > 0) {
            for (var d = 0; d < this.rangeAxisGlyphList.length; d++) {
                this.rangeAxisGlyphList[d].draw(c[1])
            }
        }
        for (var e = 0, a = this.dataSeries.length; e < a; e++) {
            var b = 12;
            if (FR.Browser.isIE6()) {
                b = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[1];
                h = FR.Chart.ChartPaintConstants.ACTION_TIME[1]
            } else {
                if (f) {
                    b = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[f];
                    h = FR.Chart.ChartPaintConstants.ACTION_TIME[f]
                }
            }
            this.dataSeries[e].getAnimateGlyph(b, f)
        }
        var g = this.getAnimateStepNumber();
        if (g > 0) {
            this.animateGlyphDraw(c[2], h, g)
        } else {
            this.animateGlyphDraw(c[2], 1, 1)
        }
    }
});
FR.Chart.GanttPlotGlyph = FR.extend(FR.Chart.RectanglePlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.errorImageIESrc = a.iesrc;
        this.errorImageSrc = a.src;
        this.errorToopTip = a.errorToopTip;
        this.planAlphaFromtUI = 0.8;
        FR.Chart.GanttPlotGlyph.superclass.initConstants.apply(this, [a])
    }, refreshAxisGlyph: function () {
    }, configAxisLabels: function (c) {
        var b = this.xAxisGlyph;
        b.initMinMaxValue(this.getMinValueFromData(c), this.getMaxValueFromData(c));
        var a = this.yAxisGlyph;
        a.categoryLabelList = c.stepName;
        if (a.categoryLabelList) {
            a.maxValue = a.categoryLabelList.length;
            a.minValue = 0;
            a.tickLength = a.isCustomMainUnit ? a.tickLength : 1;
            a.smallTickLength = a.isCustomSecUnit ? a.smallTickLength : a.tickLength / 5
        }
    }, configAxisLabelsWithOptionData: function (d) {
        if (d && d.length) {
            var m = Number.MAX_VALUE;
            var h = Number.MIN_VALUE;
            var l = [];
            for (var e = 0; e < d.length; e++) {
                var n = d[e].value;
                if (n) {
                    for (var c = 0; c < n.length; c++) {
                        var f = n[c];
                        if (e === 0) {
                            l.push(f[0])
                        }
                        for (var b = 1; b < f.length - 1; b++) {
                            m = Math.min(m, f[b]);
                            h = Math.max(h, f[b])
                        }
                    }
                }
            }
            var g = this.xAxisGlyph;
            g.initMinMaxValue(m, h);
            var a = this.yAxisGlyph;
            a.categoryLabelList = l;
            if (a.categoryLabelList) {
                a.maxValue = a.categoryLabelList.length;
                a.minValue = 0;
                a.tickLength = a.isCustomMainUnit ? a.tickLength : 1;
                a.smallTickLength = a.isCustomSecUnit ? a.smallTickLength : a.tickLength / 5
            }
        }
    }, createLegendItems: function () {
        var e = [];
        var b = this.dataSeries.length;
        for (var c = 0; c < b; c++) {
            var d = this.dataSeries[c];
            if (d.getDataPointCount() > 0) {
                var a = this.createColors4Series();
                e.push(this.createPlanItem(d, b, a));
                e.push(this.createRealStartItem(d, b));
                e.push(this.createRealEndItem(d, b));
                e.push(this.createProgressItem(d, b, a))
            }
        }
        return e
    }, createPlanItem: function (e, h, c) {
        var j = h > 1 ? e.seriesName + "-" : "";
        var g = j + FR.i18nText("FR-Chart-Gantt_PlanTime");
        var i = new FR.Chart.LegendItem();
        var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrColor(), e, c);
        var a = this.conditionCollection.getConditionAttr(new FR.Chart.AttrAlpha(), e, c);
        var d = new FR.Chart.SquareFilledMarker();
        d.background = FR.Chart.ColorBackground.getInstance(b.seriesColor);
        var f = new FR.Chart.LineMarkerIcon();
        f.alpha = a.alpha;
        f.marker = d;
        i.label = g;
        i.lineMarkerIcon = f;
        return i
    }, createRealStartItem: function (e, b) {
        var c = b > 1 ? e.seriesName + "-" : "";
        var d = c + FR.i18nText("FR-Chart-Gantt_RealStart");
        var f = new FR.Chart.LegendItem();
        var a = new FR.Chart.TriangleFilledMarker();
        a.background = FR.Chart.ColorBackground.getInstance("black");
        var g = new FR.Chart.LineMarkerIcon();
        g.marker = a;
        f.label = d;
        f.lineMarkerIcon = g;
        return f
    }, createProgressItem: function (e, h, c) {
        var j = h > 1 ? e.seriesName + "-" : "";
        var g = j + FR.i18nText("FR-Chart-Gantt_Progress");
        var i = new FR.Chart.LegendItem();
        var b = this.conditionCollection.getConditionAttr(new FR.Chart.AttrColor(), e, c);
        var a = this.conditionCollection.getConditionAttr(new FR.Chart.AttrAlpha(), e, c);
        var d = new FR.Chart.SquareFilledMarker();
        d.background = FR.Chart.ColorBackground.getInstance(b.seriesColor);
        var f = new FR.Chart.LineMarkerIcon();
        f.alpha = a.alpha;
        f.marker = d;
        i.label = g;
        i.lineMarkerIcon = f;
        return i
    }, createRealEndItem: function (e, b) {
        var c = b > 1 ? e.seriesName + "-" : "";
        var d = c + FR.i18nText("FR-Chart-Gantt_RealEndTime");
        var f = new FR.Chart.LegendItem();
        var a = new FR.Chart.DiamondFilledMarker();
        a.background = FR.Chart.ColorBackground.getInstance("rgb(122, 225, 108)");
        var g = new FR.Chart.LineMarkerIcon();
        g.marker = a;
        f.label = d;
        f.lineMarkerIcon = g;
        return f
    }, getMaxValueFromData: function (d) {
        var b = Number.MIN_VALUE;
        for (var c = 0; c < d.getIDCount(); c++) {
            for (var a = 0;
                 a < d.getCategoryLabelCount(); a++) {
                b = Math.max(b, d.getPlanStart(c, a));
                b = Math.max(b, d.getPlanEnd(c, a));
                b = Math.max(b, d.getRealStart(c, a));
                b = Math.max(b, d.getRealEnd(c, a))
            }
        }
        if (b == this.getMinValueFromData(d)) {
            return b + 10
        }
        return b
    }, getMinValueFromData: function (d) {
        var b = Number.MAX_VALUE;
        for (var c = 0; c < d.getIDCount(); c++) {
            for (var a = 0; a < d.getCategoryLabelCount(); a++) {
                b = Math.min(b, d.getPlanStart(c, a));
                b = Math.min(b, d.getPlanEnd(c, a));
                b = Math.min(b, d.getRealStart(c, a));
                b = Math.min(b, d.getRealEnd(c, a))
            }
        }
        return b
    }, installSeriesWithOptionData: function (d, b) {
        if (d) {
            this.dataSeries = [];
            for (var h = 0; h < d.length; h++) {
                var j = d[h];
                var e = new FR.Chart[b.dataSeries];
                e.seriesIndex = h;
                e.points = [];
                e.seriesName = j.seriesName;
                var g = j.value;
                for (var f = 0; f < g.length; f++) {
                    var c = g[f];
                    if (c.length === 6) {
                        var a = new FR.Chart[b.dataPoint];
                        a.categoryIndex = f;
                        a.seriesIndex = h;
                        a.seriesName = e.seriesName;
                        e.points[f] = a;
                        a.categoryName = c[0];
                        a.planStart = c[1];
                        a.planEnd = c[2];
                        a.realStart = c[3];
                        a.realEnd = c[4];
                        a.value = c[5]
                    }
                }
                this.dataSeries[h] = e
            }
        }
    }, addSeries2PlotGlyph: function (e, d) {
        this.dataSeries = [];
        for (var f = 0; f < e.getIDCount();
             f++) {
            var c = new FR.Chart[d.dataSeries];
            c.seriesIndex = f;
            c.points = [];
            if (e.getIDCount() === 1) {
                c.seriesName = "1"
            } else {
                c.seriesName = e.getIDName(f)
            }
            for (var b = 0; b < e.getCategoryLabelCount(); b++) {
                var a = new FR.Chart[d.dataPoint];
                this.initDataPointValue(a, e, b, f);
                a.categoryIndex = b;
                a.categoryName = e.getCategoryLabel(b);
                a.seriesIndex = f;
                a.seriesName = c.seriesName;
                c.points[b] = a
            }
            this.dataSeries[f] = c
        }
    }, initDataPointValue: function (a, d, e, k) {
        var f = -1, j = -1, b = -1, g = -1, h = -1;
        var c = d.getPlanStart(k, e);
        if (c != null) {
            f = c
        }
        c = d.getPlanEnd(k, e);
        if (c != null) {
            j = c
        }
        c = d.getRealStart(k, e);
        if (c != null) {
            g = c
        }
        c = d.getRealEnd(k, e);
        if (c != null) {
            h = c
        }
        c = d.getProgress(k, e);
        if (c != null) {
            b = c
        }
        if (f == -1 || j == -1) {
            a.valueIsNull = true
        } else {
            a.planStart = f;
            a.planEnd = j;
            a.value = b;
            a.realStart = g;
            a.realEnd = h
        }
    }, layoutAxisGlyph: function () {
        this.layoutDoubleAxisGlyph(this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph);
        this.yAxisGlyph.originPoint = new FR.Chart.Point2D(this.yAxisGlyph.originPoint.x, this.yAxisGlyph.getBounds().y)
    }, layoutDataSeriesGlyph: function () {
        if (this.errorImageSrc || this.errorImageIESrc) {
            var v = "<br />";
            var o = "";
            o += FR.i18nText("Chart-Gantt_ErrorTip") + v;
            o += this.errorToopTip + FR.i18nText("Chart-Use_Data") + v;
            o += FR.i18nText("Chart-Gantt_Error_Check");
            this.errorDataTip = o;
            return
        }
        var x = new FR.Chart.Bar2DPlotGlyph();
        for (var r = 0; r < this.dataSeries.length; r++) {
            var m = this.dataSeries[r];
            for (var u = 0; u < m.getDataPointCount(); u++) {
                var h = m.points[u];
                if (h.valueIsNull) {
                    continue
                }
                var q = this.conditionCollection.getConditionAttr(new FR.Chart.AttrColor(), h, this.createColors4Series());
                var e = this.conditionCollection.getConditionAttr(new FR.Chart.AttrAlpha(), h, this.createColors4Series());
                var l = x.getBarShape4GanttPlot(h.planStart, h.planEnd, u, this.yAxisGlyph, this.xAxisGlyph, this.dataSeries.length, r);
                l.isHorizontal4Bounds = true;
                if (h.value > 0) {
                    l.isUnanimate = true
                }
                var f = new FR.Chart.ShapeGlyph();
                f.shape = l;
                f.setBackground(FR.Chart.ColorBackground.getInstance(FR.Chart.Color.saturationDown(q.seriesColor)));
                f.setAlpha(this.planAlphaFromtUI);
                f.toolTipBackground = f.info.getBackground();
                h.glyph = f;
                if (h.value >= 0) {
                    var d = x.getBarShape4GanttPlot(h.planStart, h.planStart + (h.planEnd - h.planStart) * h.value, u, this.yAxisGlyph, this.xAxisGlyph, this.dataSeries.length, r);
                    d.isHorizontal4Bounds = true;
                    var k = new FR.Chart.ShapeGlyph(d);
                    k.shape = d;
                    k.setBackground(FR.Chart.ColorBackground.getInstance(q.seriesColor));
                    k.setAlpha(e.alpha);
                    k.toolTipBackground = k.info.getBackground();
                    h.progressImpl = k
                }
                if (h.realStart >= 0) {
                    var b = FR.Chart.ChartUtils.int2Date(h.realStart, FR.Chart.Constants.Second);
                    var i = FR.Chart.ChartUtils.date2Int(b, this.xAxisGlyph.mainType);
                    var j = this.xAxisGlyph.getPoint2D(i).x;
                    var p = l.height;
                    var t = new FR.Chart.TriangleFilledMarker();
                    t.size = p / 4;
                    t.background = FR.Chart.ColorBackground.getInstance("rgb(0, 0, 0)");
                    var a = new FR.Chart.MarkerGlyph();
                    a.marker = t;
                    a.color = "rgb(0, 0, 0)";
                    a.setShape(new FR.Chart.Bounds(j - p / 4, l.y + p * 0.5, p * 0.5, p * 0.5));
                    a.toolTipBackground = a.background;
                    h.realStartImpl = a
                }
                if (h.realEnd >= 0) {
                    var s = FR.Chart.ChartUtils.int2Date(h.realEnd, FR.Chart.Constants.Second);
                    var w = FR.Chart.ChartUtils.date2Int(s, this.xAxisGlyph.mainType);
                    var c = this.xAxisGlyph.getPoint2D(w).x;
                    var p = l.height;
                    var g = new FR.Chart.DiamondFilledMarker();
                    g.size = p / 4;
                    g.background = FR.Chart.ColorBackground.getInstance("rgb(122, 225, 108)");
                    var n = new FR.Chart.MarkerGlyph();
                    n.marker = g;
                    n.color = "rgb(122, 225, 108)";
                    n.setShape(new FR.Chart.Bounds(c - p * 0.25, l.y + p * 0.5, p * 0.5, p * 0.5));
                    n.toolTipBackground = n.background;
                    h.realEndImpl = n
                }
            }
        }
    }, draw: function (b, g, d) {
        if (this.errorImageSrc || this.errorImageIESrc) {
            var a = b[2];
            if (!a) {
                return
            }
            a.save();
            var f = new Image();
            var e = this.getBounds().x + this.getBounds().width / 2;
            var c = this.getBounds().y + this.getBounds().height / 2;
            f.onload = function () {
                setTimeout(function () {
                    a.drawImage(f, e - f.width / 2, c - f.height / 2, f.width, f.height)
                }, 100)
            };
            if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
                f.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + this.errorImageIESrc
            } else {
                f.src = this.errorImageSrc
            }
            a.restore()
        }
        FR.Chart.GanttPlotGlyph.superclass.draw.apply(this, [b, g, d])
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (c, b) {
        for (var e = 0, a = this.dataSeries.length; e < a; e++) {
            if (this.dataSeries[e].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            for (var d = 0; d < this.dataSeries[e].points.length; d++) {
                this.dataSeries[e].points[d].drawReal(c, b)
            }
        }
    }
});
FR.Chart.MeterStyle = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (c) {
        c = c || {};
        this.designType = FR.pick(c.designType, 0);
        this.order = FR.pick(c.order, 0);
        this.dialShape = FR.pick(c.dialShape, 360);
        this.meterAngle = FR.pick(c.meterAngle, 270);
        this.maxArrowAngle = FR.pick(c.maxArrowAngle, 180);
        this.startValue = FR.pick(c.startValue, 0);
        this.endValue = FR.pick(c.endValue, 400);
        this.tickSize = FR.pick(c.tickSize, 50);
        this.units = FR.pick(c.units, FR.i18nText("Chart-Use_Unit"));
        this.unitFormat = c.unitFormat;
        this.tickLabelsVisible = FR.pick(c.tickLabelsVisible, true);
        this.titleTextAttr = new FR.Chart.TextAttr(c.titleTextAttr);
        this.valueTextAttr = new FR.Chart.TextAttr(c.valueTextAttr);
        this.unitTextAttr = new FR.Chart.TextAttr(c.unitTextAttr);
        this.meterType = c.meterType;
        this.intervals = [];
        if (c.intervals && c.intervals.length > 0) {
            for (var b = 0; b < c.intervals.length; b++) {
                var a = new FR.Chart.MeterInterval(c.intervals[b]);
                this.intervals.push(a)
            }
        }
        this.isShowTitle = FR.pick(c.isShowTitle, true)
    }, configSeries: function (c) {
        this.maxArrowAngle = FR.pick(c.maxArrowAngle, 180);
        this.units = FR.pick(c.units, FR.i18nText("Chart-Use_Unit"));
        this.order = FR.pick(c.order, 0);
        this.meterType = FR.pick(c.meterType, 0);
        this.isShowTitle = FR.pick(c.isShowTitle);
        if (c.intervals) {
            this.designType = 1;
            for (var b = 0; b < c.intervals.length; b++) {
                var a = new FR.Chart.MeterInterval(c.intervals[b]);
                this.intervals.push(a)
            }
        } else {
            this.designType = 0
        }
        if (c.titleTextAttr) {
            this.titleTextAttr = new FR.Chart.TextAttr(c.titleTextAttr)
        } else {
            this.titleTextAttr = new FR.Chart.TextAttr();
            this.titleTextAttr.frFont = new FR.Chart.FRFont({size: 10, fontName: "Microsoft Yahei"})
        }
        if (c.valueTextAttr) {
            this.valueTextAttr = new FR.Chart.TextAttr(c.valueTextAttr)
        } else {
            this.valueTextAttr = new FR.Chart.TextAttr();
            this.valueTextAttr.frFont = new FR.Chart.FRFont({size: 18, fontName: "Century Gothic", style: 1})
        }
        if (c.unitTextAttr) {
            this.unitTextAttr = new FR.Chart.TextAttr(c.unitTextAttr)
        } else {
            this.unitTextAttr = new FR.Chart.TextAttr();
            this.unitTextAttr.frFont = new FR.Chart.FRFont({size: 12, fontName: "Microsoft Yahei"})
        }
    }, resetAutoDesignIntervals: function (c) {
        if (this.designType === 0 && c !== 0) {
            if (c < 0) {
                var b = c * 3;
                this.startValue = b;
                this.endValue = 0;
                var a = this.getInterval(0);
                a.resetInterval(this.startValue, this.startValue - c, "rgb(231, 71, 62)");
                a = this.getInterval(1);
                a.resetInterval(this.startValue - c, this.startValue - 2 * c, "rgb(252, 210, 9)");
                a = this.getInterval(2);
                a.resetInterval(this.startValue - 2 * c, this.endValue, "rgb(77, 184, 73)")
            } else {
                var d = ((c) * 3 / 2);
                this.startValue = 0;
                this.endValue = d;
                var a = this.getInterval(0);
                a.resetInterval(this.startValue, this.endValue / 3, "rgb(231, 71, 62)");
                a = this.getInterval(1);
                a.resetInterval(this.endValue / 3, this.endValue * 2 / 3, "rgb(252, 210, 9)");
                a = this.getInterval(2);
                a.resetInterval(this.endValue * 2 / 3, this.endValue, "rgb(77, 184, 73)")
            }
        } else {
            this.startValue = this.getInterval(0).beginValue;
            this.endValue = this.getInterval(this.intervals.length - 1).endValue
        }
    }, addInterval: function (a) {
        this.intervals.push(a)
    }, getInterval: function (a) {
        if (a < 0 || a >= this.intervals.length) {
            this.intervals.push(new FR.Chart.MeterInterval())
        }
        return this.intervals[a]
    }, clone: function () {
        var c = new FR.Chart.MeterStyle();
        c.designType = this.designType;
        c.order = this.order;
        c.dialShape = this.dialShape;
        c.meterAngle = this.meterAngle;
        c.maxArrowAngle = this.maxArrowAngle;
        c.startValue = this.startValue;
        c.endValue = this.endValue;
        c.tickSize = this.tickSize;
        c.units = this.units;
        c.unitFormat = this.unitFormat;
        c.tickLabelsVisible = this.tickLabelsVisible;
        c.titleTextAttr = this.titleTextAttr.clone();
        c.valueTextAttr = this.valueTextAttr.clone();
        c.unitTextAttr = this.unitTextAttr.clone();
        c.intervals = [];
        for (var b = 0; b < this.intervals.length; b++) {
            var a = this.intervals[b].clone();
            c.intervals.push(a)
        }
        c.isShowTitle = this.isShowTitle;
        return c
    }, clearAllInterval: function () {
        if (this.intervals == null) {
            return
        }
        this.intervals = []
    }
});
$.extend(FR.Chart.MeterStyle, {DEFAULT_BORDER_SIZE: 3, DEFAULT_CIRCLE_SIZE: 10, CIRCLE: 360, PIE: 180, PIE270: 270});
FR.Chart.MeterInterval = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.beginValue = FR.pick(a.beginValue, 0);
        this.endValue = FR.pick(a.endValue, 0);
        this.backgroundColor = a.backgroundColor
    }, clone: function () {
        var a = new FR.Chart.MeterInterval();
        a.beginValue = this.beginValue;
        a.endValue = this.endValue;
        a.backgroundColor = this.backgroundColor;
        return a
    }, resetInterval: function (c, a, b) {
        this.beginValue = c;
        this.endValue = a;
        this.backgroundColor = b
    }
});
FR.Chart.MeterPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.meterStyle = a.meterStyle == undefined ? null : new FR.Chart.MeterStyle(a.meterStyle);
        FR.Chart.MeterPlotGlyph.superclass.initConstants.apply(this, [a])
    }, configSeries: function (a) {
        this.meterStyle = new FR.Chart.MeterStyle();
        this.meterStyle.configSeries(a)
    }, installSeriesWithOptionData: function (f, c) {
        this.dataSeries = [];
        var e = new FR.Chart[c.dataSeries]();
        e.points = [];
        this.dataSeries.push(e);
        for (var b = 0; b < f.length; b++) {
            var d = f[b];
            var a = new FR.Chart[c.dataPoint]();
            a.categoryIndex = b;
            a.seriesIndex = 0;
            a.categoryName = d[0];
            a.value = d[1];
            e.points.push(a)
        }
    }, isSupportLegend: function () {
        return false
    }, addSeries2PlotGlyph: function (g, d) {
        var b = g.getCategoryLabelCount();
        this.dataSeries = [];
        var c = new FR.Chart[d.dataSeries];
        c.seriesIndex = 0;
        c.seriesName = "1";
        c.points = [];
        this.dataSeries.push(c);
        for (var f = 0; f < b; f++) {
            var a = new FR.Chart[d.dataPoint];
            a.categoryInedex = f;
            a.seriesIndex = 0;
            var e = g.getValue(f);
            a.value = e ? e : 0;
            if (e == null) {
                a.valueIsNull = true
            }
            a.categoryName = g.getCategoryLabel(f);
            a.seriesName = "1";
            c.points[f] = a
        }
    }, layoutAxisGlyph: function () {
    }, layoutDataSeriesGlyph: function () {
        var l = this.getBounds();
        var f = this.dataSeries.length;
        var n = this.getCategoryCount();
        var j = 0;
        var p = 0;
        var b = (l.height - ((f + 1) * p)) / f;
        var o = (l.width - ((n + 1) * j)) / n;
        for (var g = 0; g < f; g++) {
            var h = this.dataSeries[g];
            for (var m = 0; m < n; m++) {
                var a = h.points[m];
                if (a.valueIsNull) {
                    a.glyph = null;
                    continue
                }
                var k = a.categoryName;
                var i = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(k, this.meterStyle.titleTextAttr);
                i = this.meterStyle.isShowTitle ? i : new FR.Chart.Dimension2D();
                var e = new FR.Chart.TextGlyph({text: k, textAttr: this.meterStyle.titleTextAttr});
                e.textAttr.frFont = this.meterStyle.titleTextAttr.frFont;
                var d = this.meterStyle;
                if (this.meterStyle.designType === 0) {
                    d = this.meterStyle.clone()
                }
                var c;
                if (this.meterStyle.meterType === 0) {
                    c = new FR.Chart.Meter(e, a.value, this.meterStyle.clone())
                } else {
                    if (this.meterStyle.meterType === 1) {
                        c = new FR.Chart.BlueMeter(e, a.value, this.meterStyle.clone())
                    } else {
                        if (this.meterStyle.meterType === 2) {
                            c = new FR.Chart.SimpleMeter(e, a.value, this.meterStyle.clone())
                        }
                    }
                }
                a.glyph = c;
                c.bounds = new FR.Chart.Bounds(m * o + l.x, g * b + i.height + l.y, o, b - i.height);
                c.plotX = l.x;
                c.plotY = l.y;
                a.dataLabel = null
            }
        }
    }, doOnMove: function () {
    }, draw: function (m, f, n) {
        this.drawInfo(m);
        for (var g = 0; g < this.dataSeries.length; g++) {
            var j = this.dataSeries[g];
            for (var p = 0, o = j.getDataPointCount(); p < o; p++) {
                var a = j.points[p];
                var e = true;
                if (this.lastPlotGlyph && this.lastPlotGlyph.dataPointDoExit(g, p) && this.meterStyle.designType === 0) {
                    var d = this.getLastDataPointGlyph(a);
                    var b = d.meterStyle.startValue <= a.value && d.meterStyle.endValue >= a.value;
                    if (b) {
                        a.glyph.meterStyle = d.meterStyle;
                        a.lastGlyph = d;
                        e = false
                    }
                }
                if (a.glyph) {
                    a.glyph.drawMeterBottom(m[1], e)
                }
            }
        }
        for (var h = 0, k = this.dataSeries.length; h < k; h++) {
            var l = 12;
            if (FR.Browser.isIE6()) {
                l = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[1];
                f = FR.Chart.ChartPaintConstants.ACTION_TIME[1]
            } else {
                if (n) {
                    l = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[n];
                    f = FR.Chart.ChartPaintConstants.ACTION_TIME[n]
                }
            }
            this.dataSeries[h].getAnimateGlyph(l, n)
        }
        var c = this.getAnimateStepNumber();
        if (c > 0) {
            this.animateGlyphDraw(m[2], f, c)
        } else {
            this.animateGlyphDraw(m[2], 1, 1)
        }
    }
});
FR.Chart.CustomPlotGlyph = FR.extend(FR.Chart.CategoryPlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.bar2DPlotGlyph = new FR.Chart.Bar2DPlotGlyph(a.bar2DPlotGlyph);
        this.bar2DPlotGlyphStack = new FR.Chart.Bar2DPlotGlyph(a.bar2DPlotGlyphStack);
        this.linePlotGlyph = new FR.Chart.LinePlotGlyph(a.linePlotGlyph);
        this.areaPlotGlyphStack = new FR.Chart.AreaPlotGlyph(a.areaPlotGlyphStack);
        this.bar3DPlotGlyph = new FR.Chart.Bar3DPlotGlyph(a.bar3DPlotGlyph);
        this.bar3DPlotGlyphStack = new FR.Chart.Bar3DPlotGlyph(a.bar3DPlotGlyphStack);
        this.customTypeCondition = new FR.Chart.ConditionCollection(a.customTypeCondition);
        this.has3DShape = FR.pick(a.has3DShape, false);
        this.seriesOverlapPercent = FR.pick(a.seriesOverlapPercent, -0.25);
        this.categoryIntervalPercent = FR.pick(a.categoryIntervalPercent, 1);
        this.projection = new FR.Chart.Projection(a.projection);
        this.projection.calculateSINCOS();
        this.stackedList = [];
        FR.Chart.CustomPlotGlyph.superclass.initConstants.apply(this, [a])
    }, isSupportLabelWrap: function () {
        return true
    }, getSecondValueAxisGlyph: function () {
        return this.secondAxisGlyph
    }, configCondition: function (b) {
        if (!b || !b.typeConfig) {
            return
        }
        var c = FR.pick(b.conditionConfig, {});
        var a = FR.pick(b.typeConfig, {});
        this.conditionCollection.addAll(c, this.dataSeries);
        this.customTypeCondition.addAllWithDefault(a, this.dataSeries);
        this._syncConditionCollection();
        this._syncPlotFillStyle();
        this._syncDataSeries();
        this._syncPlotStyle()
    }, _syncConditionCollection: function () {
        this.bar2DPlotGlyph.conditionCollection = this.conditionCollection;
        this.bar2DPlotGlyphStack.conditionCollection = this.conditionCollection;
        this.linePlotGlyph.conditionCollection = this.conditionCollection;
        this.areaPlotGlyphStack.conditionCollection = this.conditionCollection;
        this.bar3DPlotGlyph.conditionCollection = this.conditionCollection;
        this.bar3DPlotGlyphStack.conditionCollection = this.conditionCollection
    }, _syncPlotFillStyle: function () {
        this.bar2DPlotGlyph.plotFillStyle = this.plotFillStyle;
        this.bar2DPlotGlyphStack.plotFillStyle = this.plotFillStyle;
        this.linePlotGlyph.plotFillStyle = this.plotFillStyle;
        this.areaPlotGlyphStack.plotFillStyle = this.plotFillStyle;
        this.bar3DPlotGlyph.plotFillStyle = this.plotFillStyle;
        this.bar3DPlotGlyphStack.plotFillStyle = this.plotFillStyle
    }, _synStockChart: function () {
        this.bar2DPlotGlyph.isStockChart = this.isStockChart;
        this.bar2DPlotGlyphStack.isStockChart = this.isStockChart;
        this.linePlotGlyph.isStockChart = this.isStockChart;
        this.areaPlotGlyphStack.isStockChart = this.isStockChart;
        this.bar3DPlotGlyph.isStockChart = this.isStockChart;
        this.bar3DPlotGlyphStack.isStockChart = this.isStockChart
    }, _syncDataSeries: function () {
        this.bar2DPlotGlyph.dataSeries = this.dataSeries;
        this.bar2DPlotGlyphStack.dataSeries = this.dataSeries;
        this.linePlotGlyph.dataSeries = this.dataSeries;
        this.areaPlotGlyphStack.dataSeries = this.dataSeries;
        this.bar3DPlotGlyph.dataSeries = this.dataSeries;
        this.bar3DPlotGlyphStack.dataSeries = this.dataSeries
    }, _syncPlotStyle: function () {
        this.bar2DPlotGlyph.plotStyle = this.plotStyle;
        this.bar2DPlotGlyphStack.plotStyle = this.plotStyle;
        this.linePlotGlyph.plotStyle = this.plotStyle;
        this.areaPlotGlyphStack.plotStyle = this.plotStyle;
        this.bar3DPlotGlyph.plotStyle = this.plotStyle;
        this.bar3DPlotGlyphStack.plotStyle = this.plotStyle
    }, layoutAxisGlyph: function () {
        if (this.has3DShape) {
            this.layoutAxisGlyph4ThreeD(this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph)
        } else {
            this.layoutDoubleAxisGlyph(this.xAxisGlyph, this.yAxisGlyph, this.secondAxisGlyph)
        }
    }, get3DDeep: function () {
        return 70
    }, isNeedDefaultDeep: function () {
        return true
    }, draw: function (a, c, b) {
        if (this.has3DShape) {
            this.draw3DInfo(a);
            if (this.xAxisGlyph) {
                this.xAxisGlyph.draw4ThreeD(a[1])
            }
            if (this.yAxisGlyph) {
                this.yAxisGlyph.draw4ThreeD(a[1])
            }
            if (this.secondAxisGlyph) {
                this.secondAxisGlyph.draw4ThreeD(a[1])
            }
        }
        FR.Chart.CustomPlotGlyph.superclass.draw.apply(this, [a, c, b])
    }, layoutDataSeriesGlyph: function () {
        this._synStockChart();
        this.normalBarCount = 0;
        this.stackedList = [];
        for (var g = 0; g < this.dataSeries.length; g++) {
            if (this.dataSeries[g].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var d = this.customTypeCondition.getAttr(this.dataSeries[g]);
            var b = d.useRenderer;
            if (b == FR.Chart.CustomAttr.BAR_RENDERER || b == FR.Chart.CustomAttr.BAR3D) {
                this.normalBarCount++
            }
        }
        var c = 0;
        for (var g = 0; g < this.customTypeCondition.getAttrSize();
             g++) {
            var j = this.customTypeCondition.getAttrByIndex(g);
            if (j.isStackedBarShape()) {
                var h = j.getStackedSeriesList(this.dataSeries);
                this.stackedList.push(h);
                var e = false;
                for (var l = 0; l < h.length; l++) {
                    var a = this.dataSeries[h[l]];
                    if (a && a.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        e = true
                    }
                }
                if (e) {
                    c++
                }
            }
        }
        var f = this.customTypeCondition.defaultAttr;
        if (f.isStackedBarShape()) {
            var k = this.customTypeCondition.getUnUsedSeriesIndex(this.dataSeries);
            this.stackedList.push(k);
            var e = false;
            for (var l = 0; l < k.length;
                 l++) {
                var a = this.dataSeries[k[l]];
                if (a && a.paintState > FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    e = true
                }
            }
            if (e) {
                c++
            }
        }
        this._dealSeriesSingle(this.normalBarCount + c);
        if (this.bar2DPlotGlyphStack.bounds) {
            this.bar2DPlotGlyphStack.setTotalRectForStackedBar(this)
        }
        this.dealLabelBoundsInOrder()
    }, getBarPercent: function (a) {
        return 1 / (a - ((a - 1) * this.seriesOverlapPercent) + this.categoryIntervalPercent)
    }, getBarStartPercent: function (a, b, c, d) {
        return a * (1 - this.seriesOverlapPercent) * b + c.getTickIndex4Value(d) + 0.5 * this.categoryIntervalPercent * a
    }, _getAxisPosition: function (a) {
        var b = this.customTypeCondition.getAttr(this.dataSeries[a]);
        return b.getAxisPosition()
    }, _getRenderer: function (a) {
        var b = this.customTypeCondition.getAttr(this.dataSeries[a]);
        if (b) {
            return b.useRenderer
        }
    }, getSeriesAxisGlyph: function (b) {
        var a = this._getAxisPosition(b);
        return a == FR.Chart.CustomAttr.Axis_RIGHT ? this.secondAxisGlyph : this.yAxisGlyph
    }, _getStackedBarIndex: function (d) {
        for (var b = 0; b < this.stackedList.length; b++) {
            var c = this.stackedList[b];
            for (var a = 0; a < c.length; a++) {
                if (c[a] == d) {
                    return this.normalBarCount + b
                }
            }
        }
        return -1
    }, _getStackedSeriesList: function (a) {
        for (var c = 0; c < this.stackedList.length; c++) {
            var d = this.stackedList[c];
            for (var b = 0; b < d.length; b++) {
                if (a == d[b]) {
                    return d
                }
            }
        }
        return []
    }, _dealSeriesSingle: function (i) {
        var c = 0;
        for (var d = 0; d < this.dataSeries.length; d++) {
            var e = this.dataSeries[d];
            var g = this.customTypeCondition.getAttr(e);
            if (e.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var b = g.useRenderer;
            var h = this.getSeriesAxisGlyph(d);
            var a = this._getStackedBarIndex(d);
            if (b == FR.Chart.CustomAttr.BAR_RENDERER) {
                this.bar2DPlotGlyph.bounds = this.getBounds();
                var f = this.bar2DPlotGlyph.dealShape4Bar(e, this, this.xAxisGlyph, h, i, c);
                if (f !== -1) {
                    this.bar2DPlotGlyph.dealBarShape4LargeDataStockChart(e, this, this.xAxisGlyph, h, i, c, f)
                }
                if (this.isStockChart) {
                    this.bar2DPlotGlyph.refreshDataPointLabel()
                }
                c++
            } else {
                if (b == FR.Chart.CustomAttr.BAR_STACK) {
                    this.bar2DPlotGlyphStack.bounds = this.getBounds();
                    var f = this.bar2DPlotGlyphStack.dealShape4Bar(e, this, this.xAxisGlyph, h, i, a);
                    if (f !== -1) {
                        this.bar2DPlotGlyphStack.dealBarShape4LargeDataStockChart(e, this, this.xAxisGlyph, h, i, a, f)
                    }
                    if (this.isStockChart) {
                        this.bar2DPlotGlyphStack.refreshDataPointLabel()
                    }
                } else {
                    if (b == FR.Chart.CustomAttr.AREA_STACK) {
                        this.areaPlotGlyphStack.bounds = this.getBounds();
                        var f = this.areaPlotGlyphStack.dealAreaShape4PlotGlyph(e, this, this.xAxisGlyph, h);
                        if (f !== -1) {
                            this.areaPlotGlyphStack.dealAreaLargeData4StockChart(e, this, this.xAxisGlyph, h, f)
                        }
                        if (this.isStockChart) {
                            this.areaPlotGlyphStack.refreshDataPointLabel()
                        }
                    } else {
                        if (b == FR.Chart.CustomAttr.LINE_RENDERER) {
                            this.linePlotGlyph.bounds = this.getBounds();
                            var f = this.linePlotGlyph.dealLine4PlotGlyph(e, this, this.xAxisGlyph, h);
                            if (f !== -1) {
                                this.linePlotGlyph.dealLine4StockChartLargeData(e, this, this.xAxisGlyph, h)
                            }
                            if (this.isStockChart) {
                                this.linePlotGlyph.refreshDataPointLabel()
                            }
                        } else {
                            if (b == FR.Chart.CustomAttr.BAR3D) {
                                this.bar3DPlotGlyph.dealShape4CubicBar(e, this, this.xAxisGlyph, h, i, c);
                                c++
                            } else {
                                if (b == FR.Chart.CustomAttr.BAR3D_STACK) {
                                    this.bar3DPlotGlyphStack.dealShape4CubicBar(e, this, this.xAxisGlyph, h, i, a)
                                }
                            }
                        }
                    }
                }
            }
        }
    }, getPreSum4Bar: function (c, j, b) {
        var e = this._getStackedSeriesList(c);
        var h = 0;
        var f = 0;
        for (var d = 0; d < e.length; d++) {
            var a = e[d];
            if (c == a) {
                break
            }
            if (this.dataSeries[a].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                continue
            }
            var g = this.getDataPointPercentValue(a, j);
            if (g > 0) {
                h += g
            } else {
                f += g
            }
        }
        if (b) {
            return f
        } else {
            return h
        }
    }, getPreSum4Area: function (c, g) {
        var e = this._getAxisPosition(c);
        var b = 0;
        for (var d = c - 1; d >= 0; d--) {
            if (this.dataSeries[d].paintState < FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                continue
            }
            var a = this._getAxisPosition(d);
            var f = this._getRenderer(d);
            if (FR.equals(a, e) && FR.equals(f, FR.Chart.CustomAttr.AREA_STACK)) {
                b += this.getDataPointPercentValue(d, g)
            }
        }
        return b
    }, getPreSum4AreaDataRange: function (e, b, h, l) {
        var m = this._getAxisPosition(e);
        var o = 0;
        for (var j = e - 1; j >= 0; j--) {
            var g = this.dataSeries[j];
            var f = 0;
            var d = 0;
            if (g.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var k = this._getAxisPosition(j);
            var n = this._getRenderer(j);
            if (!FR.equals(k, m) || !FR.equals(n, FR.Chart.CustomAttr.AREA_STACK)) {
                continue
            }
            for (var p = 0; p < g.getDataPointCount(); p++) {
                var a = g.points[p];
                if (a.valueIsNull) {
                    continue
                }
                var c = l.getDate4Value(p);
                if (FR.Chart.ChartUtils.isBelongToSameUnit(b, c, h)) {
                    f += this.getDataPointPercentValue(j, p);
                    d++
                }
            }
            if (d > 0) {
                o += f / d
            }
        }
        return o
    }, resetValue: function (a) {
        this.pointMaxMinValue = 0;
        this.barStackMaxMinValue = 0;
        this.areaStackMaxMinValue = 0;
        if (a) {
            this.pointMaxMinValue = 1
        }
    }, addValueInRender: function (b, c, a) {
        if (b == FR.Chart.CustomAttr.BAR_STACK || b == FR.Chart.CustomAttr.BAR3D_STACK) {
            this.barStackMaxMinValue += a
        } else {
            if (b == FR.Chart.CustomAttr.AREA_STACK || b == FR.Chart.CustomAttr.LINE_STACK) {
                this.areaStackMaxMinValue += a
            } else {
                if (c) {
                    this.pointMaxMinValue = Math.max(this.pointMaxMinValue, a)
                } else {
                    this.pointMaxMinValue = Math.min(this.pointMaxMinValue, a)
                }
            }
        }
    }, getMinValueFromData: function (d, j) {
        var i = 0;
        var f = 0;
        if (d) {
            i = Number.MAX_VALUE;
            f = 1
        }
        for (var h = 0; h < this.getCategoryCount(); h++) {
            this.resetValue(d);
            for (var e = 0; e < this.dataSeries.length; e++) {
                var b = this.dataSeries[e].points[h];
                if (b.valueIsNull || this.dataSeries[e].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || !this.isInCategoryField(this.xAxisGlyph, b.categoryName)) {
                    continue
                }
                var a = b.value;
                var c = this.customTypeCondition.getAttr(e);
                var g = this._getAxisPosition(e);
                if (a < f && g == j) {
                    this.addValueInRender(c.renderer, false, a);
                    i = (d && a < f && i > a) ? a : i
                }
            }
            if (!d) {
                i = Math.min(i, Math.min(this.barStackMaxMinValue, Math.min(this.areaStackMaxMinValue, this.pointMaxMinValue)))
            }
        }
        if (i == Number.MAX_VALUE) {
            return 1
        }
        return i
    }, getMaxValueFromData: function (h) {
        var g = 0;
        for (var b = 0; b < this.getCategoryCount(); b++) {
            this.resetValue(false);
            for (var c = 0; c < this.dataSeries.length; c++) {
                var a = this.dataSeries[c].points[b];
                if (a.valueIsNull || this.dataSeries[c].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE || !this.isInCategoryField(this.xAxisGlyph, a.categoryName)) {
                    continue
                }
                var d = a.value;
                var f = this.customTypeCondition.getAttr(c);
                var e = this._getAxisPosition(c);
                if (d >= 0 && e == h) {
                    this.addValueInRender(f.renderer, true, d)
                }
            }
            g = Math.max(g, Math.max(this.barStackMaxMinValue, Math.max(this.areaStackMaxMinValue, this.pointMaxMinValue)))
        }
        if (g == this.getMinValueFromData(false, h)) {
            return g + 10
        }
        return g
    }, getDrawSequence: function () {
        var b = [];
        for (var e = 0, k = this.dataSeries.length; e < k; e++) {
            b.push(e)
        }
        var l = [];
        var g = [];
        var c = [];
        var d = [];
        for (var e = 0, k = this.dataSeries.length; e < k; e++) {
            var f = this.dataSeries[e];
            var j = this.customTypeCondition.getAttr(f);
            var m = j.useRenderer;
            if (m == FR.Chart.CustomAttr.BAR_RENDERER) {
                g.push(e)
            } else {
                if (m == FR.Chart.CustomAttr.BAR3D) {
                    l.push(e)
                } else {
                    if (m == FR.Chart.CustomAttr.AREA_STACK) {
                        c.push(e)
                    } else {
                        if (m == FR.Chart.CustomAttr.LINE_RENDERER) {
                            d.push(e)
                        }
                    }
                }
            }
        }
        var h = 0;
        this._addIndexToOrder(g, b, h);
        h += g.length;
        if (!this._is3DStackedBar()) {
            for (var e = 0; e < this.stackedList.length; e++) {
                var a = this.stackedList[e];
                this._addIndexToOrder(a, b, h);
                h += a.length
            }
        }
        this._addIndexToOrder(c, b, h);
        h += c.length;
        this._addIndexToOrder(d, b, h);
        h += d.length;
        this._addIndexToOrder(l, b, h);
        h += l.length;
        if (this._is3DStackedBar()) {
            for (var e = 0; e < this.stackedList.length; e++) {
                var a = this.stackedList[e];
                this._addIndexToOrder(a, b, h);
                h += a.length
            }
        }
        return b
    }, _is3DStackedBar: function () {
        if (this.stackedList != null) {
            for (var c = 0; c < this.stackedList.length; c++) {
                var d = this.stackedList[c];
                for (var b = 0; b < d.length; b++) {
                    var a = d[b];
                    var e = this.customTypeCondition.getAttr(this.dataSeries[a]);
                    if (e.useRenderer == FR.Chart.CustomAttr.BAR3D_STACK) {
                        return true
                    }
                }
            }
        }
        return false
    }, _addIndexToOrder: function (b, a, d) {
        for (var c = 0; c < b.length; c++) {
            a[c + d] = b[c]
        }
    }, getAnimateStepNumber: function () {
        var b = 0;
        for (var a = 0; a < this.dataSeries.length; a++) {
            if (this.dataSeries[a].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            b = Math.max(b, this.dataSeries[a].getAnimateStepNumber())
        }
        return b
    }, doAnimate4SeriesDraw: function (a, f, e) {
        var b = f.getDrawSequence();
        var d = [];
        for (var c = 0; c < f.dataSeries.length; c++) {
            if (f.dataSeries[b[c]].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var g = this.customTypeCondition.getAttr(f.dataSeries[b[c]]);
            if (g.useRenderer == FR.Chart.CustomAttr.BAR3D_STACK) {
                d[d.length] = f.dataSeries[b[c]];
                continue
            }
            f.dataSeries[b[c]].drawAnimateGlyph(a, e);
            if (f.dataSeries[b[c]].drawAnimateGlyph4TopFoldLine) {
                f.dataSeries[b[c]].drawAnimateGlyph4TopFoldLine(a, e)
            }
        }
        this.drawBar3DStackSeries(a, f, e, d);
        for (var c = f.dataSeries.length - 1; c >= 0; c--) {
            if (f.dataSeries[b[c]].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            f.dataSeries[c].drawAnimateGlyph4TrendLine(a, e)
        }
    }, drawMarkersLabelAfterSeriesAnimateDraw: function (c, b) {
        for (var e = 0, a = this.dataSeries.length; e < a; e++) {
            if (this.dataSeries[e].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            this.dataSeries[e].drawLabel(c, b);
            if (this.customTypeCondition) {
                var f = this.customTypeCondition.getAttr(e).renderer;
                if (f == FR.Chart.CustomAttr.LINE_RENDERER || f == FR.Chart.CustomAttr.AREA_STACK) {
                    var g = this.dataSeries[e].points;
                    for (var d = 0; d < g.length; d++) {
                        g[d].draw(c, b)
                    }
                }
            }
        }
        this.drawAlertLinesAfterSeriesAnimateDraw(c)
    }, findOnMoveGlyph: function (a, c, b) {
        var d = this.dataSeries[this.currentChosenSeriesIndex];
        if (d && this._isLineSeries(d)) {
            this._findOnMoveGlyph4Line(a, c, b)
        } else {
            FR.Chart.CustomPlotGlyph.superclass.findOnMoveGlyph.apply(this, [a, c, b])
        }
    }, findClickOnGlyph: function (a, b) {
        if (this.bounds && this.bounds.containsPoint(a.x, a.y)) {
            var c = this.dataSeries[this.currentChosenSeriesIndex];
            if (c && this._isLineSeries(c)) {
                this._findSeriesGlyphPoint(c, a, b)
            }
            if (!b._hasfound) {
                this._findNearByDataPoint(a, b)
            }
        }
    }, categoryInBounds: function (a, b) {
        return this.bar2DPlotGlyph.categoryInBounds(a, b) || this.bar2DPlotGlyphStack.categoryInBounds(a, b) || this.linePlotGlyph.categoryInBounds(a, b) || this.areaPlotGlyphStack.categoryInBounds(a, b)
    }
});
FR.Chart.ThreeDCustomPlotGlyph = FR.extend(FR.Chart.CustomPlotGlyph, {
    doAnimate4SeriesDraw: function (a, f, e) {
        var b = f.getDrawSequence();
        var d = [];
        for (var c = 0; c < f.dataSeries.length; c++) {
            if (f.dataSeries[b[c]].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var g = this.customTypeCondition.getAttr(f.dataSeries[b[c]]);
            if (g.useRenderer == FR.Chart.CustomAttr.BAR3D_STACK) {
                d[d.length] = f.dataSeries[b[c]];
                continue
            }
        }
        this.drawBar3DStackSeries(a, f, e, d);
        for (var c = 0; c < f.dataSeries.length; c++) {
            if (f.dataSeries[b[c]].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            var g = this.customTypeCondition.getAttr(f.dataSeries[b[c]]);
            if (g.useRenderer == FR.Chart.CustomAttr.BAR3D_STACK) {
                continue
            }
            f.dataSeries[b[c]].drawAnimateGlyph(a, e);
            if (f.dataSeries[b[c]].drawAnimateGlyph4TopFoldLine) {
                f.dataSeries[b[c]].drawAnimateGlyph4TopFoldLine(a, e)
            }
        }
        for (var c = f.dataSeries.length - 1; c >= 0; c--) {
            if (f.dataSeries[b[c]].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                continue
            }
            f.dataSeries[c].drawAnimateGlyph4TrendLine(a, e)
        }
    }, getDrawSequence: function () {
        var b = [];
        for (var e = 0, k = this.dataSeries.length;
             e < k; e++) {
            b.push(e)
        }
        var l = [];
        var g = [];
        var c = [];
        var d = [];
        for (var e = 0, k = this.dataSeries.length; e < k; e++) {
            var f = this.dataSeries[e];
            var j = this.customTypeCondition.getAttr(f);
            var m = j.useRenderer;
            if (m == FR.Chart.CustomAttr.BAR_RENDERER) {
                g.push(e)
            } else {
                if (m == FR.Chart.CustomAttr.BAR3D) {
                    l.push(e)
                } else {
                    if (m == FR.Chart.CustomAttr.AREA_STACK) {
                        c.push(e)
                    } else {
                        if (m == FR.Chart.CustomAttr.LINE_RENDERER) {
                            d.push(e)
                        }
                    }
                }
            }
        }
        var h = 0;
        this._addIndexToOrder(g, b, h);
        h += g.length;
        if (!this._is3DStackedBar()) {
            for (var e = 0; e < this.stackedList.length;
                 e++) {
                var a = this.stackedList[e];
                this._addIndexToOrder(a, b, h);
                h += a.length
            }
        }
        this._addIndexToOrder(c, b, h);
        h += c.length;
        this._addIndexToOrder(l, b, h);
        h += l.length;
        if (this._is3DStackedBar()) {
            for (var e = 0; e < this.stackedList.length; e++) {
                var a = this.stackedList[e];
                this._addIndexToOrder(a, b, h);
                h += a.length
            }
        }
        this._addIndexToOrder(d, b, h);
        return b
    }
});
FR.Chart.GisMapPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.gisType = a.gisType;
        this.addressType = a.addressType;
        this.key = a.key;
        FR.Chart.GisMapPlotGlyph.superclass.initConstants.apply(this, [a]);
        this.pointPosition = []
    }, installSeriesWithOptionData: function (e, b) {
        this.dataSeries = [];
        var f = new FR.Chart.DataSeries();
        this.dataSeries.push(f);
        if (e) {
            for (var g = 0; g < e.length; g++) {
                var l = e[g];
                var h = l.seriesName;
                var k = l.value;
                for (var d = 0; d < k.length; d++) {
                    var c = k[d];
                    var a;
                    if (g === 0) {
                        a = new FR.Chart[b.dataPoint]();
                        f.points.push(a);
                        a.categoryName = c[0];
                        a.value = c[c.length - 1];
                        if (c.length > 2) {
                            a.addressName = c[1]
                        }
                    } else {
                        a = f.points[d]
                    }
                    a.mapAreaValue.addTitleValue(new FR.Chart.MapTitleValue({title: h, value: c[c.length - 1]}))
                }
            }
        }
    }, isSupportLegend: function () {
        return false
    }, addSeries2PlotGlyph: function (l, b) {
        this.key = "OkCharts";
        this.dataSeries = [];
        var h = new FR.Chart.DataSeries();
        this.dataSeries.push(h);
        var k = l.addressTitleValue;
        var a = l.addressName;
        var d = l.isAddress;
        var o = l.isLngFirst;
        var f = l.addresses;
        for (var g = 0; g < f.length; g++) {
            var n = f[g];
            var m = new FR.Chart[b.dataPoint]();
            if (d) {
                m.categoryName = n
            } else {
                var p = n;
                var j = n.split(",");
                if (j.length !== 2) {
                    continue
                }
                if (this.isDegreeFormat(p)) {
                    p = this.degree2number(j[0]) + "," + this.degree2number(j[1])
                }
                if (this.gisType != o) {
                    p = j[1] + "," + j[0]
                }
                m.categoryName = p
            }
            var c = k[n];
            if (c.isTitleValueNull()) {
                m.value = 0;
                m.valueIsNull = true
            } else {
                var e = c.getFirstTitleValue();
                m.value = e;
                m.mapAreaValue = c
            }
            if (a && !FR.isEmpty(a[n])) {
                m.addressName = a[n]
            }
            h.points.push(m)
        }
    }, degree2number: function (b) {
        var g = null;
        var e = null;
        var d = null;
        var c = 0;
        var f = 0;
        for (; f < b.length; f++) {
            if (b.charAt(f) == "°") {
                g = b.substring(c, f);
                c = f + 1
            } else {
                if (b.charAt(f) == "′") {
                    e = b.substring(c, f);
                    c = f + 1
                } else {
                    if (b.charAt(f) == "″") {
                        d = b.substring(c, f);
                        break
                    }
                }
            }
        }
        var a = 0;
        if (d != null) {
            a += parseFloat(d) / (60 * 60)
        }
        if (e != null) {
            a += parseFloat(e) / 60
        }
        if (g != null) {
            a += parseFloat(g)
        }
        return a
    }, isDegreeFormat: function (a) {
        if (a) {
            return a.indexOf("°") != -1 || a.contains("′") != -1 || a.contains("″") != -1
        }
        return false
    }, getDataPointByPara: function (a) {
        var c = a[0];
        for (var g = 0; g < this.dataSeries.length; g++) {
            var f = this.dataSeries[g];
            var h = f.points;
            for (var d = 0, e = h.length; d < e; d++) {
                var b = f.points[d];
                if (FR.equals(c, b.categoryName)) {
                    return b
                }
            }
        }
    }, setDivID: function (a) {
        this.parentDiv = a
    }, draw: function () {
        var c = this.parentDiv.getAttribute("id") + "GisMap";
        var a = document.getElementById(c);
        if (!a) {
            var b = $("<div>").attr("id", c).css("width", this.bounds.width).css("height", this.bounds.height).css("position", "absolute").css("left", this.bounds.x).css("top", this.bounds.y + "px").css("z-index", 10);
            a = b[0];
            this.parentDiv.appendChild(a)
        }
        if (!this.dataSeries[0] || !this.dataSeries[0].points.length) {
            return
        }
        if (this.gisType) {
            if (FR.isEmpty(this.key)) {
                this.dealWithNoKey(a)
            } else {
                this.drawBaiduMap(c)
            }
        } else {
            if (FR.isEmpty(this.key)) {
                this.dealWithNoKey(a)
            } else {
                this.drawGoogleMap(c)
            }
        }
    }, dealWithNoKey: function (b) {
        var a = document.createElement("img");
        a.src = FR.servletURL + "?op=resource&resource=com/fr/chart/base/GisError.jpg";
        a.style.width = b.style.width;
        a.style.height = b.style.height;
        b.appendChild(a)
    }, _getDataPointByCategoryName: function (c) {
        var d = this.dataSeries[0].points.length;
        for (var b = 0; b < d; b++) {
            var a = this.dataSeries[0].points[b];
            if (FR.equals(a.categoryName, c)) {
                return a
            }
        }
    }, setTooltipValue: function (b) {
        if (b.length !== 2) {
            return
        }
        var c = b[0];
        var d = b[1];
        var a = this._getDataPointByCategoryName(c);
        if (a && a.marker) {
            a.isCustomTooltip = true;
            a.tooltip = d
        }
    }, triggerTooltip: function (d) {
        if (d.length !== 1) {
            return
        }
        var e = d[0];
        var b = this._getDataPointByCategoryName(e);
        if (b && b.marker) {
            var a = b.marker;
            var h = a.getMap();
            var g = this.getToolTipString(b, this.hotTooltipStyle);
            var f = new BMap.InfoWindow("<p>" + g + "</p>");
            var c = h.pointToPixel(a.getPosition());
            c.y -= 20;
            h.openInfoWindow(f, h.pixelToPoint(c))
        }
    }, drawBaiduMap: function (f) {
        var b = new BMap.Map(f);
        this.map = b;
        if (this.addressType) {
            var d = new BMap.Geocoder();
            d.getPoint(this.dataSeries[0].points[0].categoryName, function (i) {
                b.centerAndZoom(i, 8)
            })
        } else {
            var j = this.dataSeries[0].points[0].categoryName.split(",");
            var h = new BMap.Point(j[0], j[1]);
            b.centerAndZoom(h, 8)
        }
        b.enableScrollWheelZoom();

        function g(i, l, m) {
            this._point = i;
            this._dataPoint = l;
            this._attrContents = m
        }

        var k = this;
        g.prototype = new BMap.Overlay();
        g.prototype.initialize = function (p) {
            this._labelContent = k.getLabelString(this._dataPoint, this._attrContents);
            var i = this._attrContents.textAttr.frFont;
            var o = i.size;
            this._map = p;
            var q = this._div = document.createElement("div");
            q.style.position = "absolute";
            q.style.whiteSpace = "nowrap";
            q.style.MozUserSelect = "none";
            q.style.zIndex = BMap.Overlay.getZIndex(this._point.lat);
            q.style.backgroundColor = "rgb(85,148,255)";
            q.style.border = "1px solid rgb(85,148,255)";
            q.style.color = i.color;
            q.style.font = i.style + " " + i.size + "px " + i.fontName;
            q.style.borderRadius = "4px";
            q.style.lineHeight = o + "px";
            q.style.padding = "8px 4px";
            q.style.textAlign = "center";
            var m = this._span = document.createElement("span");
            q.appendChild(m);
            m.innerHTML = this._labelContent.label;
            var n = this._arrow = document.createElement("div");
            var l = FR.servletURL + "?op=resource&resource=/com/fr/chart/base/tri.png";
            n.style.background = "url(" + l + ") no-repeat";
            n.style.position = "absolute";
            n.style.width = "9px";
            n.style.height = "7px";
            n.style.top = o * this._labelContent.lineCount + 14 + "px";
            n.style.left = this._labelContent.maxLineWidth / 2 + 4 + "px";
            n.style.overflow = "hidden";
            q.appendChild(n);
            this._map.getPanes().labelPane.appendChild(q);
            return q
        };
        g.prototype.draw = function () {
            var l = this._attrContents.textAttr.frFont.size;
            var m = this._map;
            var i = m.pointToOverlayPixel(this._point);
            this._div.style.left = i.x - this._labelContent.maxLineWidth / 2 - 10 + "px";
            this._div.style.top = i.y - l * this._labelContent.lineCount - 51 + "px"
        };
        var e = this.dataSeries[0].points.length;
        for (var c = 0; c < e; c++) {
            var a = this.dataSeries[0].points[c];
            this.resolveBaidu(a, b, g)
        }
    }, resolveBaidu: function (a, b, i) {
        var k = a.categoryName;
        var f = new BMap.Geocoder();
        var d = this.bounds.x;
        var c = this.bounds.y;
        var g = {"clientX": d, "clientY": c};
        var e = this.pointPosition;
        var m = this;
        var h = function (n, p, r) {
            var o = new BMap.Marker(new BMap.Point(n.lng, n.lat));
            p.marker = o;
            r.addOverlay(o);
            r.centerAndZoom(n, 15);
            var t = p.hyperlink;
            if (m.conditionCollection.defaultAttr.isContains(new FR.Chart.AttrContents())) {
                var q = m.conditionCollection.getConditionAttr(new FR.Chart.AttrContents(), p);
                var s = new i(n, p, q);
                r.addOverlay(s);
                p.location = n;
                p.lastOverlay = s;
                p.ComplexCustomOverlay = i;
                p.map = r;
                p.attrContents = q
            }
            o.addEventListener("click", function () {
                if (!FR.isEmpty(t)) {
                    var u = r.pointToPixel(n);
                    g.clientX = u.x + d;
                    g.clientY = u.y + c;
                    FR.doHyperlink(g, (new Function("return " + t))(), true)
                }
            });
            o.addEventListener("mouseover", function () {
                var v = m.getToolTipString(p, m.hotTooltipStyle);
                if (!FR.isEmpty(v)) {
                    var u = new BMap.InfoWindow("<p>" + v + "</p>");
                    this.openInfoWindow(u)
                }
            });
            o.addEventListener("mouseout", function () {
                this.closeInfoWindow()
            });
            e.push(n);
            r.setViewport(e)
        };
        if (this.addressType) {
            f.getPoint(k, function (n) {
                if (n) {
                    h(n, a, b)
                }
            })
        } else {
            if (k && k.split(",").length === 2) {
                var l = k.split(",");
                var j = new BMap.Point(l[0], l[1]);
                h(j, a, b)
            }
        }
    }, drawGoogleMap: function (g) {
        var d = new google.maps.Geocoder();
        var b;
        if (this.addressType) {
            d.geocode({"address": this.dataSeries[0].points[0].categoryName}, function (m, i) {
                if (i == google.maps.GeocoderStatus.OK) {
                    b = m[0].geometry.location
                }
            })
        } else {
            var k = this.dataSeries[0].points[0].categoryName.split(",");
            b = new google.maps.LatLng(k[0], k[1])
        }
        var c = {center: b, zoom: 8, mapTypeId: google.maps.MapTypeId.ROADMAP};
        var a = new google.maps.Map(document.getElementById(g), c);
        var e = this.dataSeries[0].points.length;
        for (var f = 0; f < e; f++) {
            var j = this.dataSeries[0].points[f];
            var l = this.getToolTipString(j, this.hotTooltipStyle);
            var h = j.categoryName;
            this.resolveGoogle(h, l, a, j.hyperlink)
        }
    }, resolveGoogle: function (i, l, a, j) {
        var d = new google.maps.Geocoder();
        var c = this.bounds.x;
        var b = this.bounds.y;
        var f = {"clientX": c, "clientY": b};
        var e = this.pointPosition;
        var g = function (s, u, n, t) {
            var q = new google.maps.Marker({position: s});
            q.setMap(n);
            var o = new google.maps.InfoWindow({content: u});
            if (t != null) {
                google.maps.event.addListener(q, "click", function () {
                    var v = n.getProjection().fromLatLngToPoint(lntLng);
                    f.clientX = v.x + c;
                    f.clientY = v.y + b;
                    FR.doHyperlink(f, (new Function("return " + t))(), true)
                })
            } else {
                google.maps.event.addListener(q, "click", function () {
                    o.open(n, q)
                })
            }
            google.maps.event.addListener(q, "mouseover", function () {
                o.open(n, q)
            });
            google.maps.event.addListener(q, "mouseout", function () {
                o.close()
            });
            e.push(s);
            var m = new google.maps.LatLngBounds();
            for (var p = 0, r = e.length; p < r; p++) {
                m.extend(e[p])
            }
            n.fitBounds(m)
        };
        if (this.addressType) {
            d.geocode({"address": i}, function (o, n) {
                if (n == google.maps.GeocoderStatus.OK) {
                    var m = o[0].geometry.location;
                    g(m, l, a, j)
                }
            })
        } else {
            if (i && i.split(",").length === 2) {
                var k = i.split(",");
                var h = new google.maps.LatLng(k[0], k[1]);
                g(h, l, a, j)
            }
        }
    }, _getValueString: function (a, b) {
        if (isNaN(parseFloat(a))) {
            return a
        }
        return FR.contentFormat(a, b)
    }, _getSeprator: function (a) {
        var d = ",";
        var c = FR.Chart.Separator;
        for (var b = 0; b < c.length; b++) {
            if (a.indexOf(c[b]) != -1) {
                d = c[b];
                break
            }
        }
        if (FR.equals(d, "${BR}")) {
            d = "<br />"
        }
        return d
    }, getLabelString: function (j, c) {
        var f = c.seriesLabel;
        if (FR.isEmpty(f)) {
            return ""
        }
        var d = this._getSeprator(f);
        var a = this.getToolTipString(j, c, d);
        if (FR.isEmpty(a)) {
            return {label: "", lineCount: 0, maxLineWidth: 0}
        }
        a = a.substr(0, a.length - 1);
        var e = [a];
        if (j.isCustomLabel && j.dataLabel) {
            e = [j.dataLabel.text]
        } else {
            if (a.indexOf("<br />") !== -1) {
                e = a.split(d)
            }
        }
        var k = 0;
        var g = c.textAttr;
        for (var b = 0; b < e.length; b++) {
            var h = e[b];
            k = Math.max(k, FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(h, g).width)
        }
        return {label: a, lineCount: e.length, maxLineWidth: k}
    }, getToolTipString: function (l, d, e) {
        if (l.isCustomTooltip) {
            return l.tooltip
        }
        if (e == null || e == undefined) {
            e = "<br />"
        }
        var m = "";
        var b = d.seriesLabel;
        var j = d.format ? d.format : "#.##";
        if (FR.isEmpty(b)) {
            return m
        }
        if (b.indexOf("${ADDRESS}") != -1) {
            var k = l.categoryName;
            m += k + e
        }
        if (b.indexOf("${ADDRESS_NAME}") != -1) {
            var a = l.addressName;
            m += a + e
        }
        if (b.indexOf("${AREA_TITTLE}") != -1 && b.indexOf("${VALUE}") != -1) {
            var f = l.mapAreaValue.titleValues;
            for (var c = 0; c < f.length; c++) {
                var g = f[c].title;
                var h = this._getValueString(f[c].value, j);
                m += g + ":" + h + e
            }
        } else {
            if (b.indexOf("${AREA_TITTLE}") == -1 && b.indexOf("${VALUE}") != -1) {
                var f = l.mapAreaValue.titleValues;
                for (var c = 0; c < f.length; c++) {
                    var h = this._getValueString(f[c].value, j);
                    m += h + e
                }
            } else {
                if (b.indexOf("${AREA_TITTLE}") != -1 && b.indexOf("${VALUE}") == -1) {
                    var f = l.mapAreaValue.titleValues;
                    for (var c = 0; c < f.length;
                         c++) {
                        var g = f[c].title;
                        m += g + e
                    }
                }
            }
        }
        return m
    }, layoutAxisGlyph: function (a) {
    }, layoutDataSeriesGlyph: function () {
    }
});
FR.Chart.MapPlotGlyph = FR.extend(FR.Chart.PlotGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.isSvgMap = FR.pick(a.isSvgMap, true);
        this.mapName = a.mapName;
        this.currentAttr = "";
        this.mapAreaColor = new FR.Chart.MapHotAreaColor(a.mapAreaColor);
        this.isHeatMap = FR.pick(a.isHeatMap, true);
        this.heatIndex = FR.pick(a.heatIndex, 0);
        this.mapType = FR.pick(a.mapType, FR.Chart.MapType.Map_Normal);
        this.showLayerIndex = 0;
        this.fromName = [];
        this.zoom = [1, 1];
        this.offsetX = [0, 0];
        this.offsetY = [0, 0];
        this.totalOffsetX = [0, 0];
        this.totalOffsetY = [0, 0];
        if (a.mapFilePath) {
            this.mapFilePath = FR.pick(a.mapFilePath, "./map");
            this.isSvgMap = true
        }
        if (FR.Browser.isIE() || FR.Chart.ChartUtils.isIE11()) {
            this.returnIE = new Image();
            this.returnIE.src = FR.servletURL + "?op=fr_attach&cmd=ah_image&id=" + a.normalIEsrc
        } else {
            this.returnNormal = new Image();
            this.returnNormal.src = a.normalsrc
        }
        FR.Chart.MapPlotGlyph.superclass.initConstants.apply(this, [a]);
        if (this.isSvgMap) {
            this.initSvgMap(this.mapName, true);
            this.currentAttr = FR.Chart.MapHelper.getMapAttr(this.mapName, this.isSvgMap)
        } else {
            this.initBitMap(a)
        }
        this._createHotTooltip4CombineGlyph();
        this.initZoomOffset()
    }, initSvgMap: function (e, f) {
        var d = f ? "svginit" : "chartrelate";
        if (FR.Chart.MapHelper.containsSvgMap(e)) {
            this.fromName[this.showLayerIndex] = this.mapName;
            return
        }
        var a = FR.servletURL;
        if (!FR.isEmpty(this.mapFilePath)) {
            a = this.mapFilePath + "/" + e + ".svg"
        }
        var c = this;
        var b = FR.cjkEncode(e);
        FR.ajax({
            type: "GET",
            url: a,
            data: {op: d, cmd: "map_getsvg", mapName: b, __time: new Date().getTime()},
            dataType: "xml",
            async: false,
            success: function (g) {
                c.fromName[c.showLayerIndex] = c.mapName;
                FR.Chart.MapHelper.addSvgMapAttr(e, new FR.Chart.MapSvgAttr(g))
            }
        })
    }, initBitMap: function (d) {
        if (d.imageBounds && d.pathMap) {
            var a = d.imageBounds[0];
            var b = a.mapName;
            if (FR.Chart.MapHelper.containsBitMap(b)) {
                this.currentAttr = FR.Chart.MapHelper.getBitMapAttr(b);
                return
            }
            var c = new FR.Chart.Bounds(0, 0, a.mapWidth, a.mapHeight);
            var e = {};
            e.onie = a.onie;
            e.onsrc = a.onsrc;
            this.currentAttr = new FR.Chart.MapAttr(d.pathMap, c, e);
            FR.Chart.MapHelper.addBitMapAttr(b, this.currentAttr)
        }
    }, installSeriesWithOptionData: function (g, b) {
        if (g) {
            var e = new FR.Chart.MapChartData();
            var f = [];
            var k = [];
            var l = g.length;
            for (var h = 0; h < l; h++) {
                var n = g[h];
                var m = n.seriesName;
                for (var d = 0; d < n.value.length; d++) {
                    var c = n.value[d];
                    f[d] = c[0];
                    k.push(new FR.Chart.MapTitleValue({title: m, value: c[1]}))
                }
            }
            for (var h = 0; h < f.length; h++) {
                var a = new FR.Chart.MapAreaValue();
                for (var d = 0; d < l; d++) {
                    a.addTitleValue(k[d * f.length + h])
                }
                e.addMapData(f[h], a)
            }
            this.addSeries2PlotGlyph(e, b)
        }
    }, addSeries2PlotGlyph: function (f, d) {
        this.fromMapNames = {};
        var g = this.mapAreaColor.getAreaNumber();
        var e = 1;
        for (var c = 0; c < g + e; c++) {
            var b = new FR.Chart[d.dataSeries]();
            b.seriesIndex = c;
            this.dataSeries[c] = b
        }
        var a = 0;
        this.add4NextSeries4Svg(this.mapName, this.mapName, a, f)
    }, calculatePercentValue: function () {
    }, getDataPointByPara: function (a) {
        var h = a[0];
        for (var f = 0; f < this.dataSeries.length; f++) {
            var e = this.dataSeries[f];
            var g = e.points || [];
            for (var c = 0, d = g.length; c < d; c++) {
                var b = e.points[c];
                if (b && FR.equals(h, b.categoryName) && FR.equals(b.seriesName, this.mapName)) {
                    return b
                }
            }
        }
    }, add4NextSeries4Svg: function (e, m, h, i) {
        var d = FR.Chart.MapHelper.getSvgMapAttr(m);
        if (!d) {
            return new FR.Chart.MapAreaValue()
        }
        var l = FR.Chart.MapHelper.getSvgMapAttr(this.mapName);
        var j = new FR.Chart.MapAreaValue();
        var c = d.names;
        for (var g = 0; g < c.length; g++) {
            var b = c[g];
            var k = new FR.Chart.DataPoint4Map();
            k.nameFrom = e;
            k.layerIndex = h;
            k.seriesName = m;
            if (!FR.equals(m, e)) {
                this.fromMapNames[m] = e
            }
            var a = l.getLayerTo(b);
            var f = this.getDataUseName4Svg(l, b, m);
            if (i.hasLayerTo) {
                k.hasNextTo = !FR.isEmpty(a);
                k.nameLayerTo = a
            } else {
                k.hasNextTo = false;
                k.nameLayerTo = ""
            }
            k.categoryName = f;
            k.categoryOriginalName = b;
            this.initDataPoint4Map(a, m, f, h, i, k, j)
        }
        return j
    }, initDataPoint4Map: function (b, k, f, g, h, j, i) {
        var d = 0;
        var a = h.getMapData(f);
        if (this.isPointComNext(j, h, k, b)) {
            var e = this.add4NextSeries4Svg(k, b, g + 1, h);
            if (e.isTitleValueNull()) {
                if (!a.isTitleValueNull()) {
                    var c = a.getFirstTitleValue();
                    j.value = c;
                    j.areaValue = a;
                    this.checkMapAreaTitle(i, a);
                    d = this.mapAreaColor.getColorIndexWithValue(c)
                } else {
                    j.value = 0;
                    j.valueIsNull = true;
                    d = this.dataSeries.length - 1
                }
            } else {
                var c = e.getFirstTitleValue();
                j.value = c;
                j.areaValue = e;
                d = this.mapAreaColor.getColorIndexWithValue(c)
            }
        } else {
            if (a.isTitleValueNull()) {
                j.value = 0;
                j.valueIsNull = true;
                d = this.dataSeries.length - 1
            } else {
                var c = a.getFirstTitleValue();
                j.value = c;
                j.areaValue = a;
                this.checkMapAreaTitle(i, a);
                d = this.mapAreaColor.getColorIndexWithValue(c)
            }
        }
        j.seriesIndex = d;
        this.dataSeries[d].points.push(j)
    }, checkMapAreaTitle: function (c, b) {
        if (c.isTitleValueNull()) {
            var e = b.titleValues.length;
            for (var d = 0; d < e; d++) {
                var a = b.titleValues[d];
                c.titleValues.push(new FR.Chart.MapTitleValue(a.title, a.value))
            }
        } else {
            var e = b.titleValues.length;
            for (var d = 0; d < e; d++) {
                var a = b.titleValues[d];
                var f = c.titleValues[d];
                f.value += a.value
            }
        }
    }, isPointComNext: function (a, b, d, c) {
        return a.hasNextTo && b.hasLayerTo && !FR.equals(d, c) && !FR.isEmpty(c)
    }, getDataUseName4Svg: function (d, c, b) {
        var e = d.getNameToValue(c);
        if (!FR.equals(b, this.mapName)) {
            var a = FR.Chart.MapHelper.getSvgMapAttr(b);
            if (a) {
                e = a.getNameToValue(c)
            }
        }
        return e
    }, createLegendItems: function () {
        return []
    }, returnBackToLayer: function () {
        this.mapName = this.getBackNameFrom();
        this.showLayerIndex = this.showLayerIndex - 1;
        this.currentAttr = FR.Chart.MapHelper.getMapAttr(this.mapName, this.isSvgMap);
        this.checkShowIndex()
    }, getBackNameFrom: function () {
        if (this.showLayerIndex <= 0) {
            return this.mapName
        }
        return this.fromName[this.showLayerIndex - 1]
    }, hasNextLayer: function () {
        for (var c = 0, b = this.dataSeries.length; c < b; c++) {
            var f = this.dataSeries[c];
            for (var e = 0, d = f.getDataPointCount(); e < d; e++) {
                var a = f.points[e];
                if (a.seriesName != this.mapName) {
                    continue
                }
                if (a.hasNextTo && a.nameLayerTo) {
                    return true
                }
            }
        }
        return false
    }, layerToDataPointNext: function (a, d) {
        if (!(a.hasNextTo && a.nameLayerTo)) {
            return
        }
        d.needRefresh = true;
        var b = a.nameLayerTo;
        if (this.isSvgMap) {
            this.initSvgMap(b);
            this._dealLayerIndexAndMapName(a);
            if (FR.Browser.isIE()) {
                d.doRefresh()
            }
            return
        }
        if (FR.Chart.MapHelper.containsBitMap(b)) {
            this.fromName[this.showLayerIndex] = this.mapName;
            this._dealLayerIndexAndMapName(a);
            if (FR.Browser.isIE()) {
                d.doRefresh()
            }
        } else {
            var c = this;
            b = FR.cjkEncode(b);
            FR.ajax({
                type: "GET",
                url: FR.servletURL,
                data: {op: "chartrelate", cmd: "map_layerto", mapName: b, __time: new Date().getTime()},
                dataType: "JSON",
                async: false,
                success: function (e) {
                    c.fromName[c.showLayerIndex] = c.mapName;
                    c.initBitMap(e);
                    c._dealLayerIndexAndMapName(a);
                    if (FR.Browser.isIE()) {
                        d.doRefresh()
                    }
                },
                error: function () {
                    alert("error in Map drill!")
                }
            })
        }
    }, _dealLayerIndexAndMapName: function (a) {
        this.mapName = a.nameLayerTo;
        this.showLayerIndex = this.showLayerIndex + 1;
        this.currentAttr = FR.Chart.MapHelper.getMapAttr(this.mapName, this.isSvgMap);
        this.checkShowIndex();
        this.initZoomOffset()
    }, checkShowIndex: function () {
        if (this.showLayerIndex >= this.dataSeries.length) {
            this.showLayerIndex = this.dataSeries.length - 1
        }
        if (this.showLayerIndex < 0) {
            this.showLayerIndex = 0
        }
    }, layoutAxisGlyph: function () {
    }, isSupportTwoStepDraw: function () {
        return true && this.lastPlotGlyph && this.lastPlotGlyph.mapName == this.mapName
    }, relayoutDataSeriesWithIndex: function (a, c) {
        for (var b = 0; b < a; b++) {
            var d = this.dataSeries[b];
            d.paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE
        }
        for (var b = c + 1; b < this.dataSeries.length; b++) {
            var d = this.dataSeries[b];
            d.paintState = FR.Chart.ChartPaintConstants.STATE_UNENABLE
        }
        for (var b = a; b <= c; b++) {
            var d = this.dataSeries[b];
            d.paintState = FR.Chart.ChartPaintConstants.STATE_ENABLE
        }
        this.layoutDataSeriesGlyph()
    }, getSeriesPointsOfCurrentMap: function (b) {
        var e = [];
        var c = this.dataSeries[b];
        for (var d = 0; d < c.points.length; d++) {
            var a = c.points[d];
            if (a && a.glyph && a.seriesName == this.mapName) {
                e.push(a)
            }
        }
        return e
    }, _createHotTooltip4CombineGlyph: function () {
        for (var f = 0, h = this.dataSeries.length; f < h; f++) {
            var c = this.dataSeries[f];
            for (var l = 0, m = c.getDataPointCount(); l < m; l++) {
                var a = c.points[l];
                if (a.seriesName == this.mapName && a.combineGlyph) {
                    var d = a.combineGlyph.plotGlyph;
                    if (d && d.dataSeries) {
                        for (var k = 0;
                             k < d.dataSeries.length; k++) {
                            var g = d.dataSeries[k];
                            for (var e = 0; e < g.points.length; e++) {
                                var b = g.points[e];
                                b.createHotTooltip4Map(a, this.isHeatMap, this.heatIndex, this.hotTooltipStyle)
                            }
                        }
                    }
                }
            }
        }
    }, layoutDataSeriesGlyph: function () {
        var j = this.getTransform();
        var u = new FR.Chart.BoundsManager();
        var r = [];
        for (var p = 0, t = this.dataSeries.length; p < t; p++) {
            var l = this.dataSeries[p];
            for (var n = 0, e = l.getDataPointCount(); n < e; n++) {
                var h = l.points[n];
                h.leadLine = null;
                if (h.seriesName == this.mapName) {
                    if (h.valueIsNull || l.paintState == FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                        h.glyph = null;
                        h.animateGlyph = null;
                        if (h.dataLabel) {
                            h.dataLabel.bounds = null
                        }
                        continue
                    }
                    if (this.isSvgMap && !this.isHeatMap) {
                        continue
                    }
                    h.lastGlyph = h.glyph;
                    var g = new FR.Chart.ShapeGlyph();
                    var k = this.currentAttr.getPathByName(h.categoryOriginalName);
                    var b = k.transform(j);
                    b = this._getZoomShape(b);
                    g.setShape(b);
                    g.isFade = true;
                    var a = this.conditionCollection.getAttr(h).isContains(new FR.Chart.AttrBackground());
                    if (a != null) {
                        g.info.dealCondition(this.conditionCollection, h, this.createColors4Series())
                    } else {
                        if (this.mapAreaColor) {
                            var m = this.mapAreaColor.getColorWithValue(h.value);
                            if (h.valueIsNull) {
                                g.info.setBackground(null);
                                g.info.setBorderStyle(FR.Chart.Constants.LINE_NONE)
                            } else {
                                var q = FR.Chart.ColorBackground.getInstance(m);
                                g.info.setBackground(q);
                                g.info.setBorderStyle(FR.Chart.Constants.LINE_NONE)
                            }
                        }
                    }
                    h.glyph = g;
                    g.toolTipBackground = g.info.getBackground();
                    this._layoutDataPointLabelBounds(h, u, r)
                } else {
                    h.glyph = null;
                    h.animateGlyph = null;
                    if (h.dataLabel) {
                        h.dataLabel.bounds = null
                    }
                }
            }
        }
        var s = [];
        var v = [];
        for (var o = 0; o < r.length; o++) {
            var h = r[o];
            var b = h.glyph.shape;
            var f = b.getBounds2D();
            var d = f.getMiddleX();
            var c = this.bounds.getMiddleX();
            d < c ? s.push(h) : v.push(h)
        }
        this._dealLeadLineDataPointLabel(s, true);
        this._dealLeadLineDataPointLabel(v, false);
        if (this.isSvgMap) {
            this.layoutShapeForEachDataPoint()
        }
    }, layoutShapeForEachDataPoint: function () {
        var e = this.getTransform();
        for (var f = 0, d = this.dataSeries.length; f < d; f++) {
            var g = this.dataSeries[f];
            for (var h = 0, i = g.getDataPointCount(); h < i; h++) {
                var b = g.points[h];
                if (b.seriesName == this.mapName && b.combineGlyph) {
                    var o = this.currentAttr.getPathByName(b.categoryOriginalName);
                    var j = o.transform(e);
                    j = this._getZoomShape(j);
                    var a = j.getBounds2D();
                    var c = b.combineGlyph.plotGlyph;
                    var n = c.combinedSize;
                    var l = a.getMiddleX() - n / 2;
                    var k = a.getMiddleY() - n / 2;
                    if (this.mapType == FR.Chart.MapType.Map_Column) {
                        k = a.y + a.height - n
                    }
                    var m = new FR.Chart.Bounds(l, k, n, n);
                    b.combineGlyph.bounds = m;
                    b.combineGlyph.doLayout()
                }
            }
        }
    }, _getZoomShape: function (b) {
        if (b) {
            var d = this.zoom[this.showLayerIndex];
            var c = (d - 1) / 2;
            var a = this.totalOffsetX[this.showLayerIndex] + this.offsetX[this.showLayerIndex];
            var e = this.totalOffsetY[this.showLayerIndex] + this.offsetY[this.showLayerIndex];
            return b.transform(new FR.Chart.AffineTransform(d, 0, 0, d, -this.bounds.width * c + a, -this.bounds.height * c + e))
        }
        return new FR.Chart.GeneralPath()
    }, drawCombineGlyph: function (d) {
        if (this.mapType == FR.Chart.MapType.Map_Normal) {
            return
        }
        var r = [];
        for (var g = 0, e = this.dataSeries.length; g < e; g++) {
            var l = this.dataSeries[g];
            for (var o = 0, p = l.getDataPointCount(); o < p; o++) {
                var b = l.points[o];
                if (b.seriesName == this.mapName && b.combineGlyph) {
                    var m = b.combineGlyph;
                    var c = m.plotGlyph;
                    for (var k = 0; k < c.dataSeries.length; k++) {
                        var a = c.dataSeries[k];
                        if (a.paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                            continue
                        }
                        for (var f = 0; f < a.points.length; f++) {
                            var n = a.points[f];
                            n.lastGlyph = null;
                            n.dataPoint4Map = b;
                            r.push(n)
                        }
                    }
                }
            }
        }
        var q = 36;
        if (this.actionModel) {
            q = FR.Chart.ChartPaintConstants.ACTION_STEP_Number[this.actionModel]
        }
        var h = new FR.Chart.DataSeries();
        h.points = r;
        h.getAnimateGlyph(q, FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE);
        var c = new FR.Chart.PlotGlyph();
        c.dataSeries = [h];
        c.bounds = this.bounds;
        c.animateGlyphDraw(this.combineGlyphCtx, d, q)
    }, _layoutDataPointLabelBounds: function (b, a, c) {
        var e = b.dataLabel;
        if (this.notDealDataPointLabel(b, e)) {
            if (e) {
                e.bounds = null
            }
            return
        }
        var d = this._getCenterBoundsForText(b);
        if (!this.bounds.contains(d.x, d.y, d.width, d.height)) {
            e.bounds = null;
            return
        }
        if (a.isInteract(d)) {
            c.push(b)
        } else {
            e.bounds = d;
            a.addBounds(d)
        }
    }, _dealLeadLineDataPointLabel: function (o, e) {
        if (o.length === 0) {
            return
        }
        var b = o[0].dataLabel.preferredDimension().height + 3;
        var j = this;
        var q = this.bounds.y;
        var r = this.bounds.y + this.bounds.height;

        function k(t, i) {
            var v = j._getCenterBoundsForText(t);
            var u = j._getCenterBoundsForText(i);
            return v.getMiddleY() - u.getMiddleY()
        }

        o.sort(k);
        var h = o[0];
        var d = o[o.length - 1];
        r = Math.min(this._getCenterBoundsForText(h).y, r);
        q = Math.max(this._getCenterBoundsForText(d).y + b, q);
        if (o.length * b > q - r) {
            var p = o.length * b - (q - r);
            r -= p / 2
        }
        for (var m = 0; m < o.length; m++) {
            var f = o[m];
            var g = f.dataLabel;
            var n = this._getCenterBoundsForText(f);
            var l = new FR.Chart.GeneralPath();
            l.moveTo(n.getMiddleX(), n.getMiddleY());
            n.x = e ? this.bounds.x : this.bounds.x + this.bounds.width - n.width;
            n.y = r + m * b;
            g.bounds = n;
            if (e) {
                l.lineTo(n.x + n.width, n.y + n.height / 2)
            } else {
                l.lineTo(n.x, n.y + n.height / 2)
            }
            var s = new FR.Chart.FoldLine(l);
            var c = new FR.Chart.AttrLineStyle();
            c.lineStyle = FR.Chart.Constants.LINE_THIN;
            s.lineStyleInfo.attrLineStyle = c;
            var a = new FR.Chart.AttrColor();
            a.seriesColor = a.seriesColor = "rgb(73, 79, 51)";
            s.lineStyleInfo.attrLineColor = a;
            f.leadLine = s
        }
    }, _getCenterBoundsForText: function (a) {
        var c = a.dataLabel;
        var e = a.glyph.shape;
        var d = c.preferredDimension();
        var i = null;
        if (!e.getLargeShapeBounds4Map) {
            i = e.getBounds2D()
        } else {
            i = e.getLargeShapeBounds4Map()
        }
        var b = d.width;
        var h = d.height;
        var g = i.getMiddleX() - b / 2;
        var f = i.getMiddleY() - h / 2;
        return new FR.Chart.Bounds(g, f, b, h)
    }, getMenuItemsInBounds: function (i) {
        var j = [];
        var d = 5;
        var c = new FR.Chart.Bounds(i.x - d, i.y - d, d * 2, d * 2);
        for (var e = 0; e < this.dataSeries.length; e++) {
            var f = this.dataSeries[e];
            var b = [];
            for (var g = 0; g < f.getDataPointCount(); g++) {
                var a = f.points[g];
                if (a && (a.hyperlink || (a.nameLayerTo && a.hasNextTo)) && a.glyph && a.glyph.shape) {
                    var h = a.glyph.shape;
                    if (h && (h.intersects(c.x, c.y, c.width, c.height) || h.contains(c.x, c.y, c.width, c.height) || h.contains(i.x, i.y, 1, 1) || this._dealEveryPointInBounds(h, c))) {
                        b[b.length] = a
                    }
                }
            }
            if (b.length > 0) {
                j[j.length] = b
            }
        }
        return j
    }, _dealEveryPointInBounds: function (f, b) {
        if (f && b) {
            var e = b.width || 0;
            var a = b.height || 0;
            for (var c = b.x; c < b.x + e; c++) {
                for (var d = b.y; d < b.y + a; d++) {
                    if (f.contains(c, d, 1, 1)) {
                        return true
                    }
                }
            }
        }
        return false
    }, drawReturnButton: function (c) {
        if (this.showLayerIndex === 0) {
            this.returnButton = null;
            return
        }
        var b = this.getBounds().width;
        var a = this.bounds.y;
        var d = new FR.Chart.MapReturnSmallIcon(new FR.Chart.Bounds(b - 22, a, 22, 22), FR.Chart.ChartIconState.STATE_SELECT);
        d.draw(c)
    }, drawUseImage: function (a) {
        this.currentAttr.drawBackgroundImage(a, this.getTransform(), this.bounds)
    }, redoListDrawDataPoint: function (a) {
        var g = [];
        var h = [];
        for (var c = 0; c < this.dataSeries.length; c++) {
            var e = this.dataSeries[c];
            for (var d = 0; d < e.getDataPointCount(); d++) {
                var b = e.points[d];
                if (b && b.glyph && b.glyph.shape) {
                    g[g.length] = b
                } else {
                    if (b && b.combineGlyph && b.seriesName == this.mapName) {
                        h.push(b)
                    }
                }
            }
        }
        g.sort(function f(i, l) {
            var j = 0;
            var k = 0;
            if (i && i.glyph && i.glyph.shape && i.glyph.shape.x && i.glyph.shape.x.length) {
                j = i.glyph.shape.x.length
            }
            if (l && l.glyph && l.glyph.shape && l.glyph.shape.x && l.glyph.shape.x.length) {
                k = l.glyph.shape.x.length
            }
            if (a) {
                return k - j
            } else {
                return j - k
            }
        });
        return h.concat(g)
    }, doAnimate4SeriesDraw: function (b, e, d) {
        var g = this.redoListDrawDataPoint(true);
        if (g && g.length > 0) {
            for (var c = 0; c < g.length; c++) {
                var a = g[c];
                if (a && a.glyph && a.glyph.shape) {
                    a.drawAnimateGlyph(b, d)
                }
            }
        }
        if (!b) {
            return
        }
        b.save();
        if (this.isSvgMap) {
            if (g && g.length > 0) {
                for (var c = 0; c < g.length; c++) {
                    var a = g[c];
                    if (a && a.glyph && a.glyph.shape) {
                        var f = a.glyph.shape;
                        this.currentAttr.drawBorder(b, a.categoryOriginalName, f)
                    }
                }
            }
        }
        b.restore()
    }, draw: function (b, g, e) {
        if (this.isSvgMap) {
            for (var d = 0;
                 d < b.length; d++) {
                b[d].save();
                b[d].rect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
                b[d].clip()
            }
            var f = this.zoom[this.showLayerIndex];
            var c = (f - 1) / 2;
            var a = this.totalOffsetX[this.showLayerIndex] + this.offsetX[this.showLayerIndex];
            var h = this.totalOffsetY[this.showLayerIndex] + this.offsetY[this.showLayerIndex];
            b[0].transform(f, 0, 0, f, -this.bounds.width * c + a, -this.bounds.height * c + h)
        }
        this.drawInfo(b);
        FR.Chart.MapPlotGlyph.superclass.draw.apply(this, [b, g, e]);
        if (this.isSvgMap) {
            for (var d = 0;
                 d < b.length; d++) {
                b[d].restore()
            }
        }
    }, drawInfo: function (a) {
        this.drawUseImage(a[0]);
        this.drawReturnButton(a[1])
    }, getAnimateStepNumber: function () {
        var a = 0;
        while (this.dataSeries[a] && !(this.dataSeries[a].getAnimateStepNumber() > 0)) {
            a++
        }
        if (this.dataSeries[a]) {
            return this.dataSeries[a].getAnimateStepNumber()
        } else {
            return -1
        }
    }, findOnMoveGlyph: function (a, f) {
        if (this.showLayerIndex > 0) {
            if (!this.returnButton) {
                this.returnButton = new FR.Chart.MapReturnButton(new FR.Chart.Bounds(this.getBounds().width - 30, this.getBounds().y, 30, 30))
            }
            if (this.returnButton.containsPoint(a.x, a.y)) {
                f.cursor = ChartHandler.POINTER;
                f._lastHover = this.returnButton;
                f._hasfound = true;
                return
            }
        }
        var e = a;
        var d = this.getBounds();
        if (e.y < d.y || e.x > d.x + d.width) {
            return
        }
        var g = this.redoListDrawDataPoint(false);
        if (g && g.length > 0) {
            for (var c = 0, b = g.length; c < b; c++) {
                g[c].findOnMoveGlyph(e, f);
                if (f._hasfound) {
                    return
                }
            }
        }
    }, getTransform: function () {
        var d = this.currentAttr.imageBounds;
        if (!d) {
            return new FR.Chart.AffineTransform(0, 0, 0, 0, 0, 0)
        }
        var f = new FR.Chart.Bounds(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height);
        var e = f.width / d.width;
        var c = f.height / d.height;
        e = c = Math.min(e, c);
        var b = f.x - e * d.x;
        var a = f.y - c * d.y;
        if (e * d.width < f.width) {
            b += (f.width - e * d.width) / 2
        }
        if (c * d.height < f.height) {
            a += (f.height - c * d.height) / 2
        }
        return new FR.Chart.AffineTransform(c, 0, 0, c, b, a)
    }, isSupportZoom: function () {
        return this.isSvgMap
    }, setZoom: function (d) {
        this.zoom[this.showLayerIndex] += d;
        if (this.zoom[this.showLayerIndex] < 1) {
            this.zoom[this.showLayerIndex] = 1;
            return false
        }
        if (this.zoom[this.showLayerIndex] === 1) {
            this.totalOffsetX[this.showLayerIndex] = 0;
            this.totalOffsetY[this.showLayerIndex] = 0
        } else {
            var c = this.bounds;
            if (c) {
                var b = (this.zoom[this.showLayerIndex] - 1) / 2;
                var a = this.totalOffsetX[this.showLayerIndex];
                var e = this.totalOffsetY[this.showLayerIndex];
                if (a > c.width * b) {
                    this.totalOffsetX[this.showLayerIndex] = c.width * b
                }
                if (a < -c.width * b) {
                    this.totalOffsetX[this.showLayerIndex] = -c.width * b
                }
                if (e > c.height * b) {
                    this.totalOffsetY[this.showLayerIndex] = c.height * b
                }
                if (e < -c.height * b) {
                    this.totalOffsetY[this.showLayerIndex] = -c.height * b
                }
            }
        }
        return true
    }, setCurrentOffset: function (b, f) {
        if (Math.abs(b) < 2 && Math.abs(f) < 2) {
            return false
        }
        var a = this.totalOffsetX[this.showLayerIndex];
        var e = this.totalOffsetY[this.showLayerIndex];
        var d = this.bounds;
        if (d == undefined) {
            this.offsetX[this.showLayerIndex] = b;
            this.offsetY[this.showLayerIndex] = f;
            return true
        }
        var c = (this.zoom[this.showLayerIndex] - 1) / 2;
        if (a + b > d.width * c) {
            b = d.width * c - a
        }
        if (a + b < -d.width * c) {
            b = -d.width * c - a
        }
        if (e + f > d.height * c) {
            f = d.height * c - e
        }
        if (e + f < -d.height * c) {
            f = -d.height * c - e
        }
        this.offsetX[this.showLayerIndex] = b;
        this.offsetY[this.showLayerIndex] = f;
        return true
    }, setTotalOffset: function () {
        this.totalOffsetX[this.showLayerIndex] += this.offsetX[this.showLayerIndex];
        this.totalOffsetY[this.showLayerIndex] += this.offsetY[this.showLayerIndex];
        this.offsetX[this.showLayerIndex] = 0;
        this.offsetY[this.showLayerIndex] = 0
    }, initZoomOffset: function () {
        this.offsetX[this.showLayerIndex] = 0;
        this.offsetY[this.showLayerIndex] = 0;
        this.totalOffsetX[this.showLayerIndex] = 0;
        this.totalOffsetY[this.showLayerIndex] = 0;
        this.zoom[this.showLayerIndex] = 1
    }
});
FR.Chart.PreChartGlyph = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function () {
        this.leftMoveButton = null;
        this.rightMoveButton = null;
        this.moveBar = null;
        this.demoPlot = null;
        this.bounds = null;
        this.xAxisGlyph = null;
        this.yAxisGlyph = null;
        this.barBackground = null;
        this.isScroll = true;
        this.dragStyle = false
    }, doLayout: function () {
        if (this.bounds) {
            this.initMoveBar(this.xAxisGlyph);
            this.initMoveButton();
            this.barBackground = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + this.bounds.height, this.bounds.width, FR.Chart.PreChartGlyph.MOVE_BACKGROUND_HEIGHT - 3)
        }
    }, initMoveBar: function (d) {
        if (this.demoPlot.xAxisGlyph && d) {
            var f = Math.max(1, this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getOriginalCrossValue());
            var c = this.bounds.width / f;
            var b = (f + d.zoomForward + d.zoomBackward) * this.bounds.width / f;
            b = b < c ? c : b;
            var a = Math.abs(d.zoomBackward) * this.bounds.width / f + this.bounds.x;
            a = Math.min(a, this.bounds.x + this.bounds.width - b);
            var e = this.bounds.y + this.bounds.height;
            this.moveBar = new FR.Chart.RoundBounds(a, e + (FR.Chart.PreChartGlyph.MOVE_BACKGROUND_HEIGHT - FR.Chart.PreChartGlyph.MOVE_BAR_HEIGHT) / 2, b, FR.Chart.PreChartGlyph.MOVE_BAR_HEIGHT - 3, 4, 4)
        }
    }, initMoveButton: function () {
        if (this.moveBar && this.bounds) {
            var a = this.moveBar.x;
            var c = this.bounds.y;
            var b = c + this.bounds.height / 2 - FR.Chart.MoveButton.HEIGHT / 2;
            this.leftMoveButton = new FR.Chart.MoveButton(a - FR.Chart.MoveButton.WIDTH / 2, b);
            this.leftMoveButton.isScroll = true;
            this.rightMoveButton = new FR.Chart.MoveButton(a + this.moveBar.width - FR.Chart.MoveButton.WIDTH / 2, b);
            this.rightMoveButton.isScroll = true
        }
    }, draw: function (a) {
        if (!a) {
            return
        }
        a.save();
        this.drawBackgroundDemoPath(a);
        this.drawBackgroundLine(a);
        if (this.barBackground) {
            a.fillStyle = "rgb(243,243,243)";
            this.barBackground.paint(a);
            a.strokeStyle = "rgb(172,180,177)";
            this.barBackground.draw(a)
        }
        if (this.leftMoveButton) {
            this.leftMoveButton.draw(a)
        }
        if (this.rightMoveButton) {
            this.rightMoveButton.draw(a)
        }
        this.drawMoveBar(a);
        a.restore()
    }, save4CtxBounds: function (a, b) {
        a.beginPath();
        a.moveTo(b.x, b.y);
        a.lineTo(b.x + b.width, b.y);
        a.lineTo(b.x + b.width, b.y + b.height);
        a.lineTo(b.x, b.y + b.height);
        a.closePath();
        a.clip()
    }, drawBackgroundDemoPath: function (b) {
        if (this.demoPlot) {
            var f = this.moveBar.x;
            var e = this.moveBar.x + this.moveBar.width;
            if (!b) {
                return
            }
            b.save();
            b.fillStyle = "rgb(59,195,236)";
            b.strokeStyle = "rgba(25,79,151, 0.8)";
            this.demoPlot.draw4Demo(b);
            b.fillStyle = "rgba(255,255,255, 0.5)";
            b.fillRect(this.bounds.x, this.bounds.y, f - this.bounds.x, this.bounds.height);
            b.fillRect(e, this.bounds.y, this.bounds.x + this.bounds.width - e, this.bounds.height);
            if (this.xAxisGlyph && this.yAxisGlyph) {
                var a = new FR.Chart.TextAttr();
                var d = new FR.Chart.FRFont();
                d.fontName = FR.i18nText("Chart-Use_MSBold");
                d.color = "rgb(0, 0, 0)";
                a.frFont = d;
                b.strokeStyle = "rgb(218,218,218)";
                b.lineWidth = 1;
                var c = this.xAxisGlyph.originPoint.y;
                if (this.yAxisGlyph.axisReversed) {
                    this.xAxisGlyph.originPoint.y = this.bounds.y + this.xAxisGlyph.bounds.height
                } else {
                    this.xAxisGlyph.originPoint.y = this.xAxisGlyph.originPoint.y + this.bounds.height
                }
                this.xAxisGlyph.demoGridLength = this.bounds.height;
                this.xAxisGlyph.draw4Demo(b, a);
                this.xAxisGlyph.originPoint.y = c
            }
            b.restore()
        }
    }, drawMoveBar: function (d) {
        if (this.moveBar) {
            if (!d) {
                return
            }
            d.save();
            d.strokeStyle = "rgb(101,96,72)";
            this.moveBar.draw(d);
            var b = this.moveBar.x;
            var g = this.moveBar.y;
            var e = this.moveBar.width;
            var a = this.moveBar.height;
            var c = d.createLinearGradient(b, g, b, g + a);
            if (this.dragStyle) {
                c.addColorStop(0, "rgb(210,210,210)");
                c.addColorStop(1, "rgb(250,250,250)")
            } else {
                c.addColorStop(0, "rgb(250,250,250)");
                c.addColorStop(1, "rgb(210,210,210)")
            }
            d.fillStyle = c;
            this.moveBar.paint(d);
            d.lineWidth = 1;
            d.strokeStyle = "rgb(102,102,102)";
            var f = new FR.Chart.GeneralPath();
            f.moveTo(b + e / 2 - 2, g + a / 2 - 2);
            f.lineTo(b + e / 2 - 2, g + a / 2 + 2);
            f.moveTo(b + e / 2, g + a / 2 - 2);
            f.lineTo(b + e / 2, g + a / 2 + 2);
            f.moveTo(b + e / 2 + 2, g + a / 2 - 2);
            f.lineTo(b + e / 2 + 2, g + a / 2 + 2);
            f.draw(d);
            d.restore()
        }
    }, drawBackgroundLine: function (c) {
        if (!c) {
            return
        }
        c.save();
        var g = new FR.Chart.GeneralPath();
        var b = this.bounds.x;
        var h = this.bounds.y;
        var f = this.bounds.width;
        var a = this.bounds.height;
        g.moveTo(b, h);
        var e = this.leftMoveButton.bounds.x + this.leftMoveButton.bounds.width / 2;
        g.lineTo(e, h);
        g.lineTo(e, h + a);
        g.moveTo(b + f, h);
        var d = this.rightMoveButton.bounds.x + this.rightMoveButton.bounds.width / 2;
        g.lineTo(d, h);
        g.lineTo(d, h + a);
        c.strokeStyle = "rgb(0, 0, 0)";
        g.draw(c);
        c.restore()
    }, findOnMoveGlyph: function (a, b) {
        if (this.xAxisGlyph) {
            var c = this.xAxisGlyph;
            if (c && c.isZoom) {
                if ((this.leftMoveButton && this.leftMoveButton.containsPoint(a.x, a.y)) || (this.rightMoveButton && this.rightMoveButton.containsPoint(a.x, a.y))) {
                    b._lastHover = this;
                    b._hasfound = true;
                    b._draggingTarget = b._isMouseDown ? this : null
                } else {
                    if (this.moveBar.getBounds2D().containsPoint(a.x, a.y)) {
                        b._lastHover = this;
                        b._hasfound = true;
                        if (b._isMouseDown) {
                            b._mouseStyle = "drag";
                            b._draggingTarget = this;
                            b.needRefresh = !this.dragStyle;
                            this.dragStyle = true
                        } else {
                            b._mouseStyle = "hand";
                            b.needRefresh = this.dragStyle;
                            this.dragStyle = false
                        }
                    }
                }
            }
        }
    }, move4Mobile: function (k, j, l, b) {
        b.zoomRefresh = false;
        var c = k;
        var i = j;
        var g = false;
        if (this.xAxisGlyph && (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP)) {
            var f = Math.abs(i.x - j.x);
            var d = this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getOriginalCrossValue();
            var h = this.xAxisGlyph.axisLength / d;
            var e = (parseInt(f / h));
            if (e !== 0) {
                if (i.x < j.x) {
                    if (this.leftMoveButton && this.leftMoveButton.containsPoint(c.x, c.y)) {
                        g = this.xAxisGlyph.onZoomBarLeftDown(e)
                    } else {
                        if (this.rightMoveButton && this.rightMoveButton.containsPoint(c.x, c.y)) {
                            g = this.xAxisGlyph.onZoomBarRightUp(e)
                        } else {
                            g = this.xAxisGlyph.onZoomBarIncrease(e)
                        }
                    }
                } else {
                    if (i.x > j.x) {
                        if (this.leftMoveButton && this.leftMoveButton.containsPoint(c.x, c.y)) {
                            g = this.xAxisGlyph.onZoomBarLeftUp(e)
                        } else {
                            if (this.rightMoveButton && this.rightMoveButton.containsPoint(c.x, c.y)) {
                                g = this.xAxisGlyph.onZoomBarRightDown(e)
                            } else {
                                g = this.xAxisGlyph.onZoomBarDecrease(e)
                            }
                        }
                    }
                }
            }
        }
        if (!l) {
            return
        }
        l.save();
        l.fillStyle = "rgb(51, 51, 51)";
        l.strokeStyle = "rgb(51, 51, 51)";
        var a = j.x - 4.5;
        var m = this.bounds.y - 2;
        l.beginPath();
        l.moveTo(a + 4.5, m + 2);
        l.lineTo(a + 4.5, m + 2 + this.bounds.height);
        l.stroke();
        l.beginPath();
        l.moveTo(a, m);
        l.lineTo(a - 3, m - 2.5);
        l.lineTo(a, m - 5);
        l.closePath();
        l.fill();
        l.beginPath();
        l.moveTo(a + 9, m);
        l.lineTo(a + 9, m - 5);
        l.lineTo(a + 12, m - 2.5);
        l.closePath();
        l.fill();
        l.fillRect(a, m - 3.5, 9, 2);
        if (g) {
            b.zoomRefresh = true
        }
    }, onDragEnd: function (e, c) {
        var b = false;
        if (this.xAxisGlyph && (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP)) {
            var a = Math.abs(e.x - c.x);
            var d = this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getOriginalCrossValue();
            var g = this.xAxisGlyph.axisLength / d;
            var f = (Math.round(a / g));
            if (e.x < c.x) {
                if (this.leftMoveButton && this.leftMoveButton.containsPoint(e.x, e.y)) {
                    b = this.xAxisGlyph.onZoomBarLeftDown(f)
                } else {
                    if (this.rightMoveButton && this.rightMoveButton.containsPoint(e.x, e.y)) {
                        b = this.xAxisGlyph.onZoomBarRightUp(f)
                    } else {
                        b = this.xAxisGlyph.onZoomBarIncrease(f)
                    }
                }
            } else {
                if (e.x > c.x) {
                    if (this.leftMoveButton && this.leftMoveButton.containsPoint(e.x, e.y)) {
                        b = this.xAxisGlyph.onZoomBarLeftUp(f)
                    } else {
                        if (this.rightMoveButton && this.rightMoveButton.containsPoint(e.x, e.y)) {
                            b = this.xAxisGlyph.onZoomBarRightDown(f)
                        } else {
                            b = this.xAxisGlyph.onZoomBarDecrease(f)
                        }
                    }
                }
            }
        }
    }, onDrag: function (b, j, i, a, e) {
        if (e) {
            return
        }
        var g = false;
        if (this.xAxisGlyph && (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP)) {
            var f = Math.abs(b.x - j.x);
            var c = this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getOriginalCrossValue();
            var h = this.xAxisGlyph.axisLength / c;
            var d = parseInt(f / h);
            if (d < 1) {
                a.zoomRefresh = false;
                return
            }
            if (b.x < j.x) {
                if (this.leftMoveButton && this.leftMoveButton.containsPoint(b.x, b.y)) {
                    g = this.xAxisGlyph.onZoomBarLeftDown(d)
                } else {
                    if (this.rightMoveButton && this.rightMoveButton.containsPoint(b.x, b.y)) {
                        g = this.xAxisGlyph.onZoomBarRightUp(d)
                    } else {
                        g = this.xAxisGlyph.onZoomBarIncrease(d)
                    }
                }
            } else {
                if (b.x > j.x) {
                    if (this.leftMoveButton && this.leftMoveButton.containsPoint(b.x, b.y)) {
                        g = this.xAxisGlyph.onZoomBarLeftUp(d)
                    } else {
                        if (this.rightMoveButton && this.rightMoveButton.containsPoint(b.x, b.y)) {
                            g = this.xAxisGlyph.onZoomBarRightDown(d)
                        } else {
                            g = this.xAxisGlyph.onZoomBarDecrease(d)
                        }
                    }
                }
            }
            if (g) {
                a.zoomRefresh = g;
                b.x = b.x + d * (b.x - j.x < 0 ? h : -h);
                this.initMoveBar(this.xAxisGlyph);
                this.initMoveButton()
            }
        }
    }, onPress: function (a, b) {
        if (this.xAxisGlyph) {
            var c = this.xAxisGlyph;
            if (c && c.isZoom) {
                if (this.moveBar.getBounds2D().containsPoint(a.x, a.y)) {
                    b.cursor = ChartHandler.DRAG
                }
            }
        }
    }
});
$.extend(FR.Chart.PreChartGlyph, {
    PLOT_HEIGHT_SCALE: 0.09,
    MOVE_BACKGROUND_HEIGHT: 12,
    MOVE_BAR_HEIGHT: 12,
    MIN_DEMO_HEIGHT: 20,
    MAX_DEMO_HEIGHT: 42,
    PRE_CATE_GAP: 8
});
FR.Chart.ChartGlyph = FR.extend(FR.Chart.RectangleGlyph, {
    initConstants: function (a) {
        a = a || {};
        if (a.currentStyle) {
            FR.Chart.CurrentPreStyle = new FR.Chart.AttrFillStyle(a.currentStyle)
        } else {
            FR.Chart.CurrentPreStyle = null
        }
        this.legendGlyph = a.legendGlyph == undefined ? null : new FR.Chart.LegendGlyph(a.legendGlyph);
        this.titleGlyph = a.titleGlyph == undefined ? null : new FR.Chart.TitleGlyph(a.titleGlyph);
        if (a.plotGlyph == undefined || a.plotType == undefined) {
            this.plotGlyph = null
        } else {
            this.plotGlyph = new FR.Chart[a.plotType](a.plotGlyph);
            this.initDemoPlotGlyphIfNeed(a)
        }
        if (!this.plotGlyph || !this.plotGlyph.isSupportLegend()) {
            this.legendGlyph = null
        }
        if (a.dataSheetGlyph != undefined) {
            this.dataSheetGlyph = new FR.Chart.DataSheetGlyph(a.dataSheetGlyph)
        } else {
            this.dataSheetGlyph = null
        }
        this.isUseChangeChart = a.isUseChangeChart;
        this.isUseDragRefresh = a.isUseDragRefresh;
        this.canvasInfo = FR.pick(a.canvasInfo, "");
        FR.Chart.ChartGlyph.superclass.initConstants.apply(this, [a]);
        if (this.legendGlyph && this.plotGlyph) {
            this.legendGlyph.seriesList = this.plotGlyph.dataSeries
        }
        if (this.dataSheetGlyph && this.plotGlyph) {
            this.dataSheetGlyph.seriesList = this.plotGlyph.dataSeries
        }
        this.timeSwitchGlyph = null;
        this.mapControlBar = null
    }, setOption: function (b) {
        this.isUseChangeChart = FR.pick(b.isUseChangeChart, false);
        this.isUseDragRefresh = FR.pick(b.isUseDragRefresh, true);
        this.info = new FR.Chart.GeneralInfo(b.background);
        this.initTitleConfig(b.title);
        this.initPlotConfigWithTableData(b);
        this.initLegendConfig(b.legend);
        this.initDataSheetConfig(b);
        this.initInteractionInfo(b);
        var a = [];
        if ((this.legendGlyph || this.dataSheetGlyph) && this.plotGlyph) {
            a = this.plotGlyph.createLegendItems()
        }
        if (this.legendGlyph && this.plotGlyph) {
            this.legendGlyph.seriesList = this.plotGlyph.dataSeries;
            this.legendGlyph.items = a;
            this.legendGlyph.endItemIndex = a.length
        }
        if (this.dataSheetGlyph && this.plotGlyph) {
            this.dataSheetGlyph.seriesList = this.plotGlyph.dataSeries;
            this.dataSheetGlyph.items = a
        }
    }, initTitleConfig: function (a) {
        if (a) {
            this.titleGlyph = new FR.Chart.TitleGlyph(a)
        }
    }, initLegendConfig: function (a) {
        if (a) {
            this.legendGlyph = new FR.Chart.LegendGlyph(a)
        }
    }, initPlotConfigWithTableData: function (a) {
        if (!a.chartType || !FR.Chart.Type[a.chartType]) {
            return
        }
        var b = FR.Chart.Type[a.chartType];
        this.plotGlyph = new FR.Chart[b.plotType](a.plot);
        this.initPlotGlyphAttrs(this.plotGlyph, a)
    }, initPlotGlyphAttrs: function (c, a) {
        var b = FR.Chart.Type[a.chartType];
        c.configSeries(a.series || {});
        c.configTooltipAndLabels(a || {});
        c.installSeriesWithOptionData(a.data, b);
        c.calculatePercentValue();
        c.configCondition(a.plot);
        c.configAxisLabelsWithOptionData(a.data);
        c.refreshAxisGlyph();
        c.createHotTooltip();
        c.createDataLabel4EverySeries();
        if (a.plot && a.plot.hyperlink) {
            c.createHyperlink(a.plot.hyperlink)
        }
    }, initDataSheetConfig: function (a) {
        if (a && a.dataSheet) {
            this.dataSheetGlyph = new FR.Chart.DataSheetGlyph(a.dataSheet);
            if (this.plotGlyph) {
                this.dataSheetGlyph.seriesList = this.plotGlyph.dataSeries
            }
        }
    }, initInteractionInfo: function (b) {
        var a = FR.pick(b.interaction, {});
        if (a.zoom) {
            this.plotGlyph.xAxisGlyph.isZoom = true;
            var e = FR.Chart.Type[b.chartType];
            this.smallDemoPlotGlyph = new FR.Chart[e.plotType](b.plot);
            this.initPlotGlyphAttrs(this.smallDemoPlotGlyph, b);
            this._initDemoPlotGlyph()
        }
        if (a.draggable) {
            var d = this.plotGlyph.dataSeries;
            for (var c = 0; c < d.length; c++) {
                d[c].seriesDragEnable = true
            }
        }
    }, initDemoPlotGlyphIfNeed: function (a) {
        if (this.plotGlyph && this.plotGlyph.xAxisGlyph && this.plotGlyph.xAxisGlyph.isZoom) {
            this.smallDemoPlotGlyph = new FR.Chart[a.plotType](a.plotGlyph);
            if (this.smallDemoPlotGlyph.isStacked) {
                this.smallDemoPlotGlyph.isStacked = false;
                if (this.smallDemoPlotGlyph.yAxisGlyph) {
                    this.smallDemoPlotGlyph.yAxisGlyph.minValue = this.smallDemoPlotGlyph.getMinValueFromData();
                    this.smallDemoPlotGlyph.yAxisGlyph.maxValue = this.smallDemoPlotGlyph.getMaxValueFromData()
                }
            }
            this._initDemoPlotGlyph()
        }
    }, _initDemoPlotGlyph: function () {
        if (this.smallDemoPlotGlyph.xAxisGlyph) {
            this.smallDemoPlotGlyph.xAxisGlyph.isShowAxisLabel = false;
            this.smallDemoPlotGlyph.xAxisGlyph.titleGlyph = null;
            this.smallDemoPlotGlyph.xAxisGlyph.tickMarkType = FR.Chart.Constants.TICK_MARK_NONE
        }
        if (this.smallDemoPlotGlyph.yAxisGlyph) {
            this.smallDemoPlotGlyph.yAxisGlyph.isShowAxisLabel = false;
            this.smallDemoPlotGlyph.yAxisGlyph.titleGlyph = false;
            this.smallDemoPlotGlyph.yAxisGlyph.tickMarkType = FR.Chart.Constants.TICK_MARK_NONE
        }
        if (this.smallDemoPlotGlyph.secondAxisGlyph) {
            this.smallDemoPlotGlyph.secondAxisGlyph.isShowAxisLabel = false;
            this.smallDemoPlotGlyph.secondAxisGlyph.titleGlyph = false;
            this.smallDemoPlotGlyph.secondAxisGlyph.tickMarkType = FR.Chart.Constants.TICK_MARK_NONE
        }
    }, getChartBackgroundCtx: function () {
        return this.ctxs[0]
    }, getPlotBackgroundCtx: function () {
        return this.canvasInfo.indexOf("chart") != -1 ? this.ctxs[1] : this.ctxs[0]
    }, getNormalAllCtx: function () {
        var a = this.canvasInfo.indexOf("chart") != -1;
        var b = this.canvasInfo.indexOf("plot") != -1;
        if (a) {
            return b ? this.ctxs[2] : this.ctxs[1]
        } else {
            return b ? this.ctxs[1] : this.ctxs[0]
        }
    }, getAnimateCtx: function () {
        var a = this.canvasInfo.indexOf("chart") != -1;
        var b = this.canvasInfo.indexOf("plot") != -1;
        if (a) {
            return b ? this.ctxs[3] : this.ctxs[2]
        } else {
            return b ? this.ctxs[2] : this.ctxs[1]
        }
    }, getAnimateCtxIndex: function () {
        var a = this.canvasInfo.indexOf("chart") != -1;
        var b = this.canvasInfo.indexOf("plot") != -1;
        if (a) {
            return b ? 3 : 2
        } else {
            return b ? 2 : 1
        }
    }, getOnMoveCtx: function () {
        return this.ctxs[this.ctxs.length - 1]
    }, getCombineGlyphCtx: function () {
        return this.ctxs[this.ctxs.length - 2]
    }, getMapOnMoveCtx: function () {
        if (this.hasMapInnerCtx4OnMove()) {
            return this.ctxs[this.getAnimateCtxIndex() + 1]
        } else {
            return this.getOnMoveCtx()
        }
    }, hasCombineGlyph: function () {
        return this.plotGlyph && this.plotGlyph.mapType && this.plotGlyph.mapType != FR.Chart.MapType.Map_Normal
    }, hasMapInnerCtx4OnMove: function () {
        return this.hasCombineGlyph() && this.plotGlyph.isHeatMap
    }, draw: function (a, b) {
        this.bounds = FR.Chart.ChartUtils.rectangle2RoundRectangle(this.bounds, this.isRoundBorder());
        this.drawBackground();
        FR.Chart.DivCon.clearDiv(this.parentDiv);
        FR.Chart.GraphHelper.ctx = this.ctxs[0];
        FR.Chart.GraphHelper.isDrawingEnd = false;
        this.doLayout();
        this.drawWhenLayoutEnd(a, b)
    }, drawBackground: function () {
        var g = this.bounds;
        var l = this.getChartBackgroundCtx();
        var b = this.info;
        if (g && b) {
            if (!l) {
                return
            }
            l.save();
            l.globalAlpha = b.seriesAttrAlpha.alpha;
            var a = parseFloat(l.canvas.style.width);
            var k = parseFloat(l.canvas.style.height);
            var h = b.seriesAttrBorder.borderStyle != FR.Chart.Constants.LINE_NONE && b.seriesAttrBorder.borderColor != null;
            var i = h ? 5 : 0;
            if (b.seriesAttrBackground.seriesBackground) {
                var d = new FR.Chart.Bounds(0, 0, Math.max(0, a - i), Math.max(0, k - i));
                var f = FR.Chart.ChartUtils.rectangle2RoundRectangle(d, this.isRoundBorder());
                b.seriesAttrBackground.seriesBackground.paint(l, f)
            }
            if (h) {
                var e = FR.Chart.GraphHelper.getLineStyleSize(b.seriesAttrBorder.borderStyle);
                var c = new FR.Chart.Bounds(e / 2, e / 2, Math.max(0, a - i - e), Math.max(0, k - i - e));
                l.strokeStyle = b.seriesAttrBorder.borderColor;
                l.lineWidth = e;
                var j = FR.Chart.ChartUtils.rectangle2RoundRectangle(c, this.isRoundBorder());
                j.draw(l)
            }
            l.restore()
        }
    }, drawWhenLayoutEnd: function (c, d) {
        var f = this.getPlotBackgroundCtx();
        var b = this.getNormalAllCtx();
        var e = this.getAnimateCtx();
        if (this.plotGlyph && this.legendGlyph) {
            this.plotGlyph.dealAttr4LegendGlyph(this.legendGlyph)
        }
        if (this.legendGlyph) {
            this.legendGlyph.draw(b)
        }
        if (this.titleGlyph) {
            this.titleGlyph.draw(b)
        }
        if (this.timeSwitchGlyph) {
            this.timeSwitchGlyph.draw(b)
        }
        if (this.mapControlBar) {
            this.mapControlBar.draw(b)
        }
        if (this.dataSheetGlyph) {
            this.dataSheetGlyph.draw(b)
        }
        if (this.plotGlyph) {
            if (this.plotGlyph.setDivID) {
                this.plotGlyph.setDivID(this.parentDiv)
            }
            this.plotGlyph.setCombieGlyphCtx(this.getCombineGlyphCtx());
            if (this.preChartGlyph) {
                this.preChartGlyph.draw(b)
            }
            var a = [f, b, e];
            this.plotGlyph.chartBounds = this.bounds;
            this.plotGlyph.draw(a, d || 1000, c);
            this.plotGlyph.lastPlotGlyph = null
        }
    }, clearLegendAndDraw: function () {
        var a = this.getNormalAllCtx();
        if (this.legendGlyph && this.legendGlyph.bounds) {
            var b = this.legendGlyph.bounds;
            a.clearRect(b.x, b.y, b.width, b.height);
            this.legendGlyph.draw(a)
        }
    }, reDrawPlotGlyphNoAnimate: function () {
        if (this.plotGlyph != null) {
            var a = this.getAnimateCtx();
            this.clear(a);
            this.plotGlyph.doAnimate4SeriesDraw(a, this.plotGlyph, this.plotGlyph.getAnimateStepNumber() - 1)
        }
    }, draw4OnMove: function (a) {
        if (this.legendGlyph) {
            this.legendGlyph.draw4OnMove(a)
        }
    }, clearOnMoveCtx: function () {
        this.clear(this.getOnMoveCtx());
        if (this.hasMapInnerCtx4OnMove()) {
            this.clear(this.getMapOnMoveCtx())
        }
    }, clearCombineGlyphCtx: function () {
        this.clear(this.getCombineGlyphCtx())
    }, clear: function (b) {
        var c = parseFloat(b.canvas.style.width);
        var a = parseFloat(b.canvas.style.height);
        b.clearRect(0, 0, c, a)
    }, clearAll: function () {
        var c = this.getAnimateCtxIndex();
        var b = this.ctxs.length;
        for (var a = 0; a < b; a++) {
            if (a != c) {
                this.clear(this.ctxs[a])
            }
        }
        FR.Chart.GraphHelper.isDrawingEnd = false
    }, returnBackToLayer: function () {
        if (this.plotGlyph != null) {
            this.plotGlyph.returnBackToLayer()
        }
    }, layerToDataPointNext: function (a, b) {
        if (this.plotGlyph != null) {
            this.plotGlyph.layerToDataPointNext(a, b)
        }
    }, drawOnPress: function (a) {
        if (this.legendGlyph) {
            this.legendGlyph.drawOnPress(a)
        }
    }, onPress: function (a, c) {
        var b = this.getBounds();
        if (a.y < b.y || a.x > b.x + b.width) {
            return
        }
        if (this.preChartGlyph) {
            this.preChartGlyph.onPress(a, c)
        }
        if (this.legendGlyph) {
            this.legendGlyph.onPress(a, c)
        }
    }, findOnMoveGlyph: function (a, b) {
        if (this.legendGlyph) {
            if (this.plotGlyph) {
                if (this.plotGlyph.isLegendInteractive()) {
                    this.legendGlyph.findOnMoveGlyph(a, b)
                } else {
                    this.legendGlyph.findOnMoveLegendButtonGlyph(a, b)
                }
            } else {
                this.legendGlyph.findOnMoveGlyph(a, b)
            }
        }
        if (this.dataSheetGlyph && this.plotGlyph && !b._hasfound) {
            this.dataSheetGlyph.findOnMoveGlyph(a, b)
        }
        if (this.plotGlyph && !b._hasfound) {
            this.plotGlyph.findOnMoveGlyph(a, b)
        }
        if (this.timeSwitchGlyph && !b._hasfound) {
            this.timeSwitchGlyph.findOnMoveGlyph(a, b)
        }
        if (this.preChartGlyph && !b._hasfound) {
            this.preChartGlyph.findOnMoveGlyph(a, b)
        }
        if (this.mapControlBar && !b._hasfound) {
            this.mapControlBar.findOnMoveGlyph(a, b)
        }
    }, findClickOnGlyph: function (a, b) {
        if (this.legendGlyph) {
            if (this.plotGlyph && this.plotGlyph.isLegendInteractive()) {
                this.legendGlyph.findOnMoveGlyph(a, b)
            }
        }
        if (this.plotGlyph && !b._hasfound) {
            this.plotGlyph.findClickOnGlyph(a, b)
        }
        if (this.timeSwitchGlyph && !b._hasfound) {
            this.timeSwitchGlyph.findOnMoveGlyph(a, b)
        }
        if (this.mapControlBar && !b._hasfound) {
            this.mapControlBar.findOnMoveGlyph(a, b)
        }
    }, doOnMove: function (a) {
        if (this.plotGlyph) {
            this.plotGlyph.doOnMove(this.getOnMoveCtx(), a)
        }
    }, setLastGlyph: function (a) {
        if (this.plotGlyph && a.plotGlyph) {
            this.plotGlyph.setLastGlyph(a.plotGlyph)
        }
    }, doLayout: function () {
        var b = new FR.Chart.ChartGlyphLayout();
        b.bounds = this.getBounds();
        if (this.plotGlyph != null) {
            var a = this.getBackground();
            if (a && a.backgroundType == "ColorBackground") {
                this.plotGlyph.wholeChartBackground = FR.Chart.ColorBackground.getInstance(a.color)
            }
        }
        b.doLayout(this)
    }, refreshLegendLabel: function () {
        if (this.legendGlyph && this.plotGlyph) {
            var a = this.legendGlyph.items;
            var e = this.plotGlyph.dataSeries;
            if (a.length == e.length) {
                for (var c = 0; c < a.length; c++) {
                    if (e[c].lastState && e[c].lastState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
                        e.splice(c, 1);
                        a.splice(c, 1)
                    }
                }
                for (var c = 0; c < a.length;
                     c++) {
                    e[c].seriesIndex = c;
                    var d = e[c].points;
                    for (var b = 0; b < d.length; b++) {
                        d[b].seriesIndex = c
                    }
                }
                for (var c = 0; c < a.length; c++) {
                    a[c].label = e[c].seriesName
                }
            }
            this.legendGlyph.synchronizeLegendColorWithSeries(this.plotGlyph.plotFillStyle, e)
        }
        if (this.plotGlyph) {
            var e = this.plotGlyph.dataSeries;
            for (var c = 0; c < e.length; c++) {
                if (e[c].lastState && e[c].lastState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
                    e.splice(c, 1)
                }
            }
            for (var c = 0; c < e.length; c++) {
                e[c].seriesIndex = c;
                var d = e[c].points;
                for (var b = 0; b < d.length; b++) {
                    d[b].seriesIndex = c
                }
            }
        }
    }
});
FR.Chart.BackgroundGlyph = function (d, b, a, e, c) {
    this.ctx = null;
    this.iconDeoms = [];
    this.domWidth = 0;
    this.domHeight = 0;
    this.selectedIndex = a;
    this.isNeedRefreshButton = e;
    this.canvas = null;
    this.items = b;
    this.initBackgroundCtx(d, a, c)
};
$.extend(FR.Chart.BackgroundGlyph.prototype, {
    initBackgroundCtx: function (c, a, b) {
        this.domWidth = b ? b.width : c.width();
        this.domHeight = b ? b.height : c.height();
        this.canvas = $("<canvas>").css("position", "absolute").css("left", 0).css("top", 0).css("width", this.domWidth + "px").css("height", this.domHeight + "px");
        this.canvas.appendTo(c);
        if (window.G_vmlCanvasManager) {
            window.G_vmlCanvasManager.initElement(this.canvas[0])
        }
        this.ctx = this.canvas[0].getContext("2d");
        this.resize(this.domWidth, this.domHeight)
    }, _fixedPosition: function (c) {
        if (!c) {
            c = window.event
        }
        var b = c;
        if (c.targetTouches && c.targetTouches.length > 0) {
            b = c.targetTouches[0]
        } else {
            if (c && c.touches) {
                if (c.touches.length > 0) {
                    b = c.touches[0]
                } else {
                    if (c.changedTouches && c.changedTouches.length > 0) {
                        b = c.changedTouches[0]
                    }
                }
            }
        }
        var i = {x: 0, y: 0};
        var h = 1;
        i.x += b.clientX;
        i.y += b.clientY;
        var g = this.canvas.offset();
        i.x -= g.left;
        i.y -= g.top;
        var a = a;
        var d = undefined;
        if (!FR.BIDezi) {
            if (a) {
                d = a
            } else {
                if (b.view && b.view.contentPane) {
                    d = b.view.contentPane
                } else {
                    if (FR.Browser.isIE()) {
                        try {
                            d = window.parent.contentPane
                        } catch (f) {
                            d = null
                        }
                    }
                }
            }
            if (d && d.zoom) {
                h = d.zoom
            }
        }
        i.x = i.x / h;
        i.y = i.y / h;
        return i
    }, init4MouseHandler: function () {
        var b = this.canvas[0];
        var a = this;
        b.onmousemove = function (d) {
            var c = a._fixedPosition(d);
            a.doOnMove(c)
        };
        b.onclick = function (d) {
            var c = a._fixedPosition(d);
            a.doOnClick(c)
        }
    }, refresh: function () {
        var b = parseFloat(this.ctx.canvas.style.width);
        var a = parseFloat(this.ctx.canvas.style.height);
        this.ctx.clearRect(0, 0, b, a);
        if (this.isNeedRefreshButton) {
            this.iconDeoms[this.iconDeoms.length - 1].draw(this.ctx)
        }
        for (var c = 0; c < (this.isNeedRefreshButton ? (this.iconDeoms.length - 1) : this.iconDeoms.length); c++) {
            this.iconDeoms[c].draw(this.ctx)
        }
    }, findSelectedIndex: function (b) {
        if (b.x < this.domWidth - this.iconDeoms.length * 26) {
            return -1
        }
        var e = b.x - (this.domWidth - this.iconDeoms.length * 26);
        var c = parseInt(e / 26);
        var a = parseInt(b.y / 26);
        var d = parseInt(this.domWidth / 26) * a + c;
        return this.iconDeoms.length > d ? d : -1
    }, doOnMove: function (a) {
        var c = this.findSelectedIndex(a);
        var b = false;
        if (this.isNeedRefreshButton) {
            b = c === this.iconDeoms.length - 1
        }
        for (var d = 0; d < this.iconDeoms.length; d++) {
            if (d !== this.selectedIndex) {
                this.iconDeoms[d].state = FR.Chart.ChartIconState.STATE_NORMAL
            } else {
                this.iconDeoms[d].state = FR.Chart.ChartIconState.STATE_SELECT
            }
        }
        if (!b && (c < 0 || c >= this.iconDeoms.length)) {
            this.refresh();
            return
        }
        if (c !== -1 && !b && c !== this.selectedIndex) {
            if (this.iconDeoms[c].state !== undefined) {
                this.iconDeoms[c].state = FR.Chart.ChartIconState.STATE_OVER
            }
        }
        this.refresh();
        return this.items[c] && !b ? this.items[c].name : null
    }, doOnClick: function (a) {
        var b = this.findSelectedIndex(a);
        if (b != -1 && this.isNeedRefreshButton && b === this.iconDeoms.length - 1) {
            var d = this.chartWidget.chartArray;
            var c = d[this.selectedIndex].fineChart;
            if (c.chartAttr) {
                c.changeData(c.chartAttr, c.actionModel)
            } else {
                c.changeTableData()
            }
        } else {
            if (b === -1 || b === this.selectedIndex || !this.chartWidget) {
                return
            }
            this.chartWidget.changeChartImage(b)
        }
    }, resize: function (c, o) {
        this.domWidth = c;
        this.domHeight = o;
        FR.Chart.ChartUtils.retinaOptimization(this.canvas[0], this.ctx, this.domWidth, this.domHeight);
        if (this.isNeedRefreshButton && this.items.length === 1) {
            this.items = []
        }
        var k = this.items;
        var d = this.selectedIndex;
        this.iconDeoms = [];
        var n = 22;
        var g = 22;
        var f = this.domWidth - 26 * k.length - (this.isNeedRefreshButton ? 26 : 0);
        var e = 0;
        for (var h = 0; h < k.length && (parseInt(26 * (h + 1)) / this.domWidth) < 2; h++) {
            var a = new FR.Chart.Bounds(f, e, n, g);
            var b = h == d ? FR.Chart.ChartIconState.STATE_SELECT : FR.Chart.ChartIconState.STATE_NORMAL;
            var m = k[h];
            var j = m.simpleIconType;
            if (!j) {
                j = FR.Chart.Type.getSimpleIconType(m)
            }
            var l = new FR.Chart[j + "SmallIcon"](a, b);
            this.iconDeoms.push(l);
            f += 26;
            e = parseInt(f / this.domWidth) * 26
        }
        if (this.isNeedRefreshButton) {
            var a = new FR.Chart.Bounds(this.domWidth - 26, e, n, g);
            var i = new FR.Chart.RefreshSmallIcon(a, FR.Chart.ChartIconState.STATE_NORMAL);
            this.iconDeoms.push(i)
        }
        this.refresh()
    }
});
FR.Chart.TimeSwitchGlyph = FR.extend(FR.Chart.RectangleGlyph, {
    initConstants: function (a) {
        a = a || {};
        this.visible = FR.pick(a.visible, true);
        this.bounds = null;
        this.switchButtonWidth = 0;
        this.switchButtons = [];
        this.xAxisGlyph = null;
        this.timeSwitchArray = null;
        this.lastClickButton = null;
        this.lastOverButton = null;
        FR.Chart.RectangleGlyph.superclass.initConstants.apply(this, [a])
    }, doLayout: function () {
        if (!this.timeSwitchArray || this.timeSwitchArray.length < 1 || !this.bounds) {
            return
        }
        var a = this.bounds.x;
        if (this.switchButtons.length > 0) {
            for (var b = 0; b < this.timeSwitchArray.length; b++) {
                var c = this.switchButtons[b];
                c.bounds = new FR.Chart.Bounds(a, this.bounds.y, this.switchButtonWidth, this.bounds.height);
                a += this.switchButtonWidth + 2
            }
            this.globalTimeButton.bounds = new FR.Chart.Bounds(a, this.bounds.y, this.switchButtonWidth, this.bounds.height);
            this.globalTimeButton.isGlobal = true;
            return
        }
        for (var b = 0; b < this.timeSwitchArray.length; b++) {
            var c = new FR.Chart.TimeSwitchButton();
            this.switchButtons[b] = c;
            c.bounds = new FR.Chart.Bounds(a, this.bounds.y, this.switchButtonWidth, this.bounds.height);
            c.time = this.timeSwitchArray[b].timeUnit;
            c.unit = this.timeSwitchArray[b].timeType;
            a += this.switchButtonWidth + 2
        }
        this.globalTimeButton = new FR.Chart.TimeSwitchButton();
        this.globalTimeButton.bounds = new FR.Chart.Bounds(a, this.bounds.y, this.switchButtonWidth, this.bounds.height);
        this.globalTimeButton.isGlobal = true;
        this.globalTimeButton.isPress = true
    }, findButton: function (a) {
        if (!this.timeSwitchArray || this.timeSwitchArray.length < 1 || !this.bounds) {
            return null
        }
        var c = null;
        for (var b = 0; b < this.switchButtons.length; b++) {
            if (this.switchButtons[b].containsPoint(a.x, a.y)) {
                c = this.switchButtons[b];
                break
            }
        }
        if (!c && this.globalTimeButton.containsPoint(a.x, a.y)) {
            c = this.globalTimeButton
        }
        return c
    }, clearButtonOver: function () {
        if (this.lastOverButton) {
            this.lastOverButton.isOver = false
        }
    }, clearButtonPress: function () {
        if (this.lastClickButton) {
            this.lastClickButton.isPress = false;
            this.lastClickButton.isOver = false
        }
        this.globalTimeButton.isPress = false;
        this.globalTimeButton.isOver = false
    }, clearButtonsChoosen: function () {
        for (var a = 0; a < this.switchButtons.length; a++) {
            this.switchButtons[a].isPress = false
        }
        this.globalTimeButton.isPress = false
    }, findOnMoveGlyph: function (a, b) {
        this.clearButtonOver();
        this.lastOverButton = this.findButton(a);
        if (this.lastOverButton) {
            this.lastOverButton.isOver = true;
            b._lastHover = this;
            b._hasfound = true
        }
    }, doOnMove: function (b, a) {
        if (this.lastOverButton) {
            this.lastOverButton.draw(b)
        }
    }, onClick: function (a, b) {
        this.clearButtonPress();
        this.lastClickButton = this.findButton(a);
        if (this.lastClickButton) {
            this.lastClickButton.isPress = true;
            this.timeChange()
        }
        b.needRefresh = true
    }, timeChange: function () {
        if (!this.lastClickButton || !this.lastClickButton.isPress) {
            return
        }
        if (this.lastClickButton.isGlobal) {
            this.xAxisGlyph.zoomBackward = 0;
            this.xAxisGlyph.zoomForward = 0;
            return
        }
        var a = this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getEndValue4UnitBasedMinDate(this.lastClickButton.unit, parseInt(this.lastClickButton.time));
        this.xAxisGlyph.zoomForward = 0;
        if (a >= 0) {
            this.xAxisGlyph.onZoomBarRightDown(a, true)
        } else {
            this.xAxisGlyph.zoomBackward = 0;
            var b = this.xAxisGlyph.getStartValue4UnitBasedOriginalMaxDate(this.lastClickButton.unit, parseInt(this.lastClickButton.time)) - this.xAxisGlyph.getOriginalCrossValue();
            this.xAxisGlyph.onZoomBarLeftDown(b)
        }
    }, draw: function (a) {
        if (!this.timeSwitchArray || this.timeSwitchArray.length < 1 || !this.bounds) {
            return
        }
        for (var b = 0; b < this.switchButtons.length; b++) {
            this.switchButtons[b].draw(a)
        }
        this.globalTimeButton.draw(a)
    }
});
$.extend(FR.Chart.TimeSwitchGlyph, {
    WIDGET_HEIGHT_SCALE: 0.06,
    MIN_WIDGET_HEIGHT: 20,
    MAX_WIDGET_HEIGHT: 30,
    BUTTOM_MIN_WIDTH: 50,
    BUTTON_MAX_WIDTH: 80,
    BUTTON_WIDTH_SCALE: 0.12
});
FR.Chart.GlobalDemoGlyph = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function () {
        this.dragBar = null;
        this.demoPlot = null;
        this.bounds = null;
        this.xAxisGlyph = null;
        this.yAxisGlyph = null;
        this.barBackground = null;
        this.timeSwitchGlyph = null;
        this.isScroll = true;
        this.dragStyle = false;
        this.focusOnLeftButton = false;
        this.focusOnRightButton = false
    }, makeSureDragFocus: function (a) {
        if (!this.dragBar || !a) {
            return
        }
        this.focusOnLeftButton = this.dragBar.isMoveOnLeftDragButton(a.x, a.y) && this.isScroll;
        this.focusOnRightButton = this.dragBar.isMoveOnRightDragButton(a.x, a.y) && this.isScroll
    }, doLayout: function () {
        if (this.bounds) {
            this.initDragBar(this.xAxisGlyph);
            this.barBackground = new FR.Chart.Bounds(this.bounds.x, this.bounds.y + this.bounds.height, this.bounds.width, FR.Chart.PreChartGlyph.MOVE_BACKGROUND_HEIGHT - 3)
        }
    }, initDragBar: function (d) {
        if (this.demoPlot.xAxisGlyph && d) {
            var e = Math.max(1, this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getOriginalCrossValue());
            var c = this.bounds.width / e;
            var b = (e + d.zoomForward + d.zoomBackward) * this.bounds.width / e;
            b = b < c ? c : b;
            var a = Math.abs(d.zoomBackward) * this.bounds.width / e + this.bounds.x;
            a = Math.min(a, this.bounds.x + this.bounds.width - b);
            this.dragBar = new FR.Chart.GlobalDragBar();
            this.dragBar.bounds = new FR.Chart.Bounds(a, this.bounds.y, b, this.bounds.height);
            this.dragBar.parentBounds = this.bounds
        }
    }, draw: function (a) {
        if (!a) {
            return
        }
        a.save();
        this.drawBackgroundDemoPath(a);
        this.dragBar.draw(a);
        a.restore()
    }, drawBackgroundDemoPath: function (a) {
        if (this.demoPlot) {
            this.demoPlot.draw4Demo(a)
        }
    }, findOnMoveGlyph: function (a, b) {
        if (this.xAxisGlyph) {
            var c = this.xAxisGlyph;
            if (c && c.isZoom) {
                if (!this.dragBar.bounds.containsPoint(a.x, a.y)) {
                    return
                }
                b._lastHover = this;
                b._hasfound = true;
                b._draggingTarget = b._isMouseDown ? this : null;
                if (this.dragBar.isMoveOnDragButton(a.x, a.y)) {
                    b._mouseStyle = "arrow";
                    if (b._isMouseDown) {
                        b._draggingTarget = this;
                        b.needRefresh = !this.dragStyle;
                        this.dragStyle = true
                    } else {
                        b.needRefresh = this.dragStyle;
                        this.dragStyle = false
                    }
                } else {
                    b._mouseStyle = "hand"
                }
            }
        }
    }, onDragEnd: function (b, a) {
        this.focusOnLeftButton = false;
        this.focusOnRightButton = false
    }, onDrag: function (b, j, i, a, e) {
        if (e) {
            return
        }
        if (!this.lastMousePos) {
            this.lastMousePos = b
        }
        var g = false;
        if (this.xAxisGlyph && (this.xAxisGlyph.position == FR.Chart.Constants.BOTTOM || this.xAxisGlyph.position == FR.Chart.Constants.TOP)) {
            var f = Math.abs(b.x - j.x);
            var c = this.xAxisGlyph.getOriginalArrowValue() - this.xAxisGlyph.getOriginalCrossValue();
            var h = this.xAxisGlyph.axisLength / c;
            var d = parseInt(f / h);
            if (d < 1) {
                a.zoomRefresh = false;
                return
            }
            if (a._mouseStyle === "hand") {
                if (b.x < j.x) {
                    g = this.xAxisGlyph.onZoomBarIncrease(d)
                } else {
                    if (b.x > j.x) {
                        g = this.xAxisGlyph.onZoomBarDecrease(d)
                    }
                }
            } else {
                if (this.dragBar && this.dragBar.isDragButtonCross()) {
                    if (this.lastMousePos.x < j.x) {
                        g = this.xAxisGlyph.onZoomBarRightUp(d);
                        this.focusOnLeftButton = false;
                        this.focusOnRightButton = true;
                        if (this.timeSwitchGlyph) {
                            this.timeSwitchGlyph.clearButtonsChoosen()
                        }
                    } else {
                        if (this.lastMousePos.x > j.x) {
                            g = this.xAxisGlyph.onZoomBarLeftUp(d);
                            this.focusOnLeftButton = true;
                            this.focusOnRightButton = false;
                            if (this.timeSwitchGlyph) {
                                this.timeSwitchGlyph.clearButtonsChoosen()
                            }
                        }
                    }
                } else {
                    if (this.dragBar && this.focusOnLeftButton) {
                        if (this.lastMousePos.x < j.x) {
                            g = this.xAxisGlyph.onZoomBarLeftDown(d);
                            if (!g || this.dragBar.isMoveOnRightDragButton(j.x, j.y)) {
                                g = this.xAxisGlyph.onZoomBarRightUp(d);
                                this.focusOnLeftButton = false;
                                this.focusOnRightButton = true
                            }
                            if (this.timeSwitchGlyph) {
                                this.timeSwitchGlyph.clearButtonsChoosen()
                            }
                        } else {
                            if (this.lastMousePos.x > j.x) {
                                g = this.xAxisGlyph.onZoomBarLeftUp(d);
                                if (this.timeSwitchGlyph) {
                                    this.timeSwitchGlyph.clearButtonsChoosen()
                                }
                            }
                        }
                    } else {
                        if (this.dragBar && this.focusOnRightButton) {
                            if (this.lastMousePos.x < j.x) {
                                g = this.xAxisGlyph.onZoomBarRightUp(d);
                                if (this.timeSwitchGlyph) {
                                    this.timeSwitchGlyph.clearButtonsChoosen()
                                }
                            } else {
                                if (this.lastMousePos.x > j.x) {
                                    g = this.xAxisGlyph.onZoomBarRightDown(d);
                                    if (!g || this.dragBar.isMoveOnLeftDragButton(j.x, j.y)) {
                                        g = this.xAxisGlyph.onZoomBarLeftUp(d);
                                        this.focusOnLeftButton = true;
                                        this.focusOnRightButton = false
                                    }
                                    if (this.timeSwitchGlyph) {
                                        this.timeSwitchGlyph.clearButtonsChoosen()
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (g) {
                a.zoomRefresh = g;
                b.x = b.x + d * (b.x - j.x < 0 ? h : -h);
                this.initDragBar(this.xAxisGlyph)
            }
        }
        this.lastMousePos = j
    }, onPress: function (a, b) {
        if (this.xAxisGlyph) {
            var c = this.xAxisGlyph;
            if (c && c.isZoom) {
                if (this.dragBar.bounds.containsPoint(a.x, a.y)) {
                    b.cursor = ChartHandler.DRAG
                }
            }
        }
    }
});
$.extend(FR.Chart.GlobalDemoGlyph, {
    DEMO_HEIGHT_SCALE: 0.09,
    MIN_DEMO_HEIGHT: 20,
    MAX_DEMO_HEIGHT: 42,
    PRE_CATE_GAP: 8
});
FR.Chart.GlobalDragBar = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function () {
        this.bounds = null;
        this.parentBounds = null
    }, draw: function (a) {
        if (!a) {
            return
        }
        a.save();
        this.drawLeftAreaGray(a);
        this.drawRightAreaGray(a);
        this.drawLeftButton(a);
        this.drawRightButton(a);
        this.drawUpDownLine(a);
        a.restore()
    }, drawUpDownLine: function (d) {
        var b = Math.round(this.bounds.x), g = Math.round(this.bounds.y), a = Math.round(this.bounds.height),
            f = Math.round(this.bounds.width);
        d.strokeStyle = FR.Chart.GlobalDragBar.DARK_BLUE;
        d.lineWidth = 1;
        d.lineCap = "round";
        var e = 3;
        var c = new FR.Chart.Line2D(new FR.Chart.Point2D(b + e, g), new FR.Chart.Point2D(b + f - e, g));
        c.draw(d);
        c = new FR.Chart.Line2D(new FR.Chart.Point2D(b + e, g + a), new FR.Chart.Point2D(b + f - e, g + a));
        c.draw(d)
    }, drawLeftAreaGray: function (k) {
        k.fillStyle = FR.Chart.GlobalDragBar.GRAY;
        var e = 3;
        var b = 3;
        var f = Math.round(this.bounds.x), d = Math.round(this.bounds.y), i = Math.round(this.bounds.height),
            a = Math.round(this.bounds.width);
        var j = Math.round(this.parentBounds.x), h = Math.round(this.parentBounds.y),
            c = Math.round(this.parentBounds.height), g = Math.round(this.parentBounds.width);
        k.beginPath();
        k.moveTo(j, h + b);
        k.lineTo(j, h + c - b);
        k.quadraticCurveTo(j, h + c, j + e, h + c);
        k.lineTo(f + e, d + i);
        k.lineTo(f + e, d);
        k.lineTo(j + e, h);
        k.quadraticCurveTo(j, h, j, h + b);
        k.closePath();
        k.fill()
    }, drawRightAreaGray: function (k) {
        k.fillStyle = FR.Chart.GlobalDragBar.GRAY;
        var e = 3;
        var b = 3;
        var f = Math.round(this.bounds.x), d = Math.round(this.bounds.y), i = Math.round(this.bounds.height),
            a = Math.round(this.bounds.width);
        var j = Math.round(this.parentBounds.x), h = Math.round(this.parentBounds.y),
            c = Math.round(this.parentBounds.height), g = Math.round(this.parentBounds.width);
        k.beginPath();
        k.moveTo(j + g, h + b);
        k.lineTo(j + g, h + c - b);
        k.quadraticCurveTo(j + g, h + c, j + g - e, h + c);
        k.lineTo(f + a - e, d + i);
        k.lineTo(f + a - e, d);
        k.lineTo(j + g - e, h);
        k.quadraticCurveTo(j + g, h, j + g, h + b);
        k.closePath();
        k.fill()
    }, drawLeftButton: function (i) {
        i.fillStyle = FR.Chart.GlobalDragBar.DARK_BLUE;
        var e = 3;
        var b = 3;
        var f = Math.round(this.bounds.x), d = Math.round(this.bounds.y), h = Math.round(this.bounds.height),
            a = Math.round(this.bounds.width);
        i.beginPath();
        i.moveTo(f, d + b);
        i.lineTo(f, d + h - b);
        i.quadraticCurveTo(f, d + h, f + e, d + h);
        i.lineTo(f + FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH, d + h);
        i.lineTo(f + FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH, d);
        i.lineTo(f + e, d);
        i.quadraticCurveTo(f, d, f, d + b);
        i.closePath();
        i.fill();
        var g = h / 3;
        var c = h / 3;
        i.strokeStyle = FR.Chart.GlobalDragBar.LIGHT_BLUE;
        i.lineWidth = 2;
        i.lineCap = "round";
        var j = new FR.Chart.Line2D(new FR.Chart.Point2D(f + 3, this.bounds.y + g), new FR.Chart.Point2D(f + 3, this.bounds.y + c + g));
        j.draw(i);
        j = new FR.Chart.Line2D(new FR.Chart.Point2D(f + 7, this.bounds.y + g), new FR.Chart.Point2D(f + 7, this.bounds.y + c + g));
        j.draw(i)
    }, drawRightButton: function (i) {
        i.fillStyle = FR.Chart.GlobalDragBar.DARK_BLUE;
        var e = 3;
        var b = 3;
        var f = Math.round(this.bounds.x), d = Math.round(this.bounds.y), h = Math.round(this.bounds.height),
            a = Math.round(this.bounds.width);
        i.beginPath();
        i.moveTo(f + a - FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH, d);
        i.lineTo(f + a - e, d);
        i.quadraticCurveTo(f + a, d, f + a, d + b);
        i.lineTo(f + a, d + h - b);
        i.quadraticCurveTo(f + a, d + h, f + a - e, d + h);
        i.lineTo(f + a - FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH, d + h);
        i.lineTo(f + a - FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH, d);
        i.closePath();
        i.fill();
        var g = h / 3;
        var c = h / 3;
        i.strokeStyle = FR.Chart.GlobalDragBar.LIGHT_BLUE;
        i.lineWidth = 2;
        i.lineCap = "round";
        var j = new FR.Chart.Line2D(new FR.Chart.Point2D(f + a - 3, this.bounds.y + g), new FR.Chart.Point2D(f + a - 3, this.bounds.y + c + g));
        j.draw(i);
        j = new FR.Chart.Line2D(new FR.Chart.Point2D(f + a - 7, this.bounds.y + g), new FR.Chart.Point2D(f + a - 7, this.bounds.y + c + g));
        j.draw(i)
    }, isMoveOnDragButton: function (d, c) {
        var g = 2;
        var j = 10;
        var h = Math.round(this.bounds.x), e = Math.round(this.bounds.y), i = Math.round(this.bounds.height),
            a = Math.round(this.bounds.width);
        var f = new FR.Chart.Bounds(h - g, e - g, FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH + g * 2, i + g * 2);
        var b = new FR.Chart.Bounds(h + a - FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH - g - j, e - g, FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH + g * 2 + j, i + g * 2);
        return f.contains(d, c, 1, 1) || b.contains(d, c, 1, 1)
    }, isDragButtonCross: function () {
        return this.bounds.width <= FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH * 2
    }, isMoveOnLeftDragButton: function (e, c) {
        var h = 2;
        var b = Math.round(this.bounds.x), g = Math.round(this.bounds.y), a = Math.round(this.bounds.height),
            f = Math.round(this.bounds.width);
        var d = new FR.Chart.Bounds(b - h, g - h, FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH + h * 2, a + h * 2);
        return d.contains(e, c, 1, 1)
    }, isOnBarWhite: function (d, c) {
        if (this.isDragButtonCross()) {
            return false
        }
        var h = 2;
        var b = Math.round(this.bounds.x), g = Math.round(this.bounds.y), a = Math.round(this.bounds.height),
            e = Math.round(this.bounds.width);
        var f = new FR.Chart.Bounds(b + FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH + h, g - h, e - FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH * 2 - h * 2, a + h * 2);
        return f.contains(d, c, 1, 1)
    }, isMoveOnRightDragButton: function (d, c) {
        var f = 2;
        var i = 10;
        var g = Math.round(this.bounds.x), e = Math.round(this.bounds.y), h = Math.round(this.bounds.height),
            a = Math.round(this.bounds.width);
        var b = new FR.Chart.Bounds(g + a - FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH - f - i, e - f, FR.Chart.GlobalDragBar.DRAG_BAR_WIDTH + f * 2 + i, h + f * 2);
        return b.contains(d, c, 1, 1)
    }
});
$.extend(FR.Chart.GlobalDragBar, {
    DARK_BLUE: "rgb(41,171,226)",
    LIGHT_BLUE: "rgb(122,218,224)",
    GRAY: "rgba(220,221,221,0.6)",
    DRAG_BAR_WIDTH: 10
});
FR.Chart.LegendGlyph = FR.extend(FR.Chart.RectangleGlyph, {
    initConstants: function (c) {
        c = c || {};
        this.font = new FR.Chart.FRFont(c.font);
        this.position = FR.pick(FR.Chart.ChartUtils.getPosition(c.position), FR.Chart.Constants.RIGHT);
        this.items = [];
        if (c.items) {
            var b = c.items;
            for (var a = 0; a < b.length; a++) {
                this.items[a] = new FR.Chart.LegendItem(b[a])
            }
        }
        FR.Chart.LegendGlyph.superclass.initConstants.apply(this, [c]);
        this.seriesList = [];
        this.useButton = false;
        this.forwardButton = null;
        this.backButton = null;
        this.startItemIndex = 0;
        this.endItemIndex = this.items.length;
        this.startItemY4Mobile = 0;
        this.startItemX4Mobile = 0;
        this.moveBarLength = 0;
        this.legendPressing = false;
        this.maxLabelWidth = 0;
        this.drawInCutOrNot = false;
        this.isScroll = this.moveBarLength > 0;
        this.clickable = true
    }, resetLegendWhenResize: function () {
        this.useButton = false;
        this.forwardButton = null;
        this.backButton = null;
        this.startItemIndex = 0;
        this.endItemIndex = this.items.length;
        this.startItemY4Mobile = 0;
        this.startItemX4Mobile = 0;
        this.moveBarLength = 0;
        this.maxLabelWidth = 0;
        this.drawInCutOrNot = false
    }, draw: function (a) {
        if (this.visible) {
            FR.Chart.LegendGlyph.superclass.draw.apply(this, [a]);
            if (!a) {
                return
            }
            a.save();
            if (this.items) {
                for (var b = 0; b < this.items.length; b++) {
                    this.items[b].draw(a, this.font)
                }
            }
            if (this.useButton) {
                this._checkLegendButton();
                if (this.forwardButton) {
                    this.forwardButton.draw(a)
                }
                if (this.backButton) {
                    this.backButton.draw(a)
                }
            }
            a.restore()
        }
    }, layoutLegendAndRefreshChartBounds: function (e, a, b) {
        var d = this.layoutLegendBounds(e);
        this.refreshItemBoundsWithLegendBounds(d);
        this._refreshChartBoundsWithLegendBounds(e, d, a, b);
        var c = new FR.Chart.Bounds(parseInt(d.x) - 0.5, parseInt(d.y) - 0.5, d.width, d.height);
        this.bounds = FR.Chart.ChartUtils.rectangle2RoundRectangle(c, this.isRoundBorder())
    }, layoutLegendBounds: function (e) {
        var c = this._getLegendX(e);
        var b = this._getLegendY(e);
        var d = this._getLegendWidth(e);
        var a = this._getLegendHeight(e);
        return new FR.Chart.Bounds(c, b, d, a)
    }, changeLegendBounds: function (a) {
        this.refreshItemBoundsWithLegendBounds(a);
        this.bounds = FR.Chart.ChartUtils.rectangle2RoundRectangle(a, this.isRoundBorder())
    }, _refreshChartBoundsWithLegendBounds: function (d, c, a, b) {
        d.x = this.refreshChartBoundsXWithLegendBounds(d, c, a);
        d.y = this.refreshChartBoundsYWithLegendBounds(d, c, b);
        d.width = this.refreshChartBoundsWidthWithLegendBounds(d, c, a);
        d.height = this.refreshChartBoundsHeightWithLegendBounds(d, c, b)
    }, refreshChartBoundsXWithLegendBounds: function (c, b, a) {
        if (this.position == FR.Chart.Constants.LEFT) {
            return c.x + b.width + a
        } else {
            return c.x
        }
    }, refreshChartBoundsYWithLegendBounds: function (c, b, a) {
        if (this.position == FR.Chart.Constants.TOP) {
            return c.y + a + b.height
        } else {
            return c.y
        }
    }, refreshChartBoundsWidthWithLegendBounds: function (c, b, a) {
        if (this.position == FR.Chart.Constants.TOP || this.position == FR.Chart.Constants.BOTTOM) {
            return c.width
        } else {
            return c.width - a - b.width
        }
    }, refreshChartBoundsHeightWithLegendBounds: function (c, b, a) {
        if (this.position == FR.Chart.Constants.TOP || this.position == FR.Chart.Constants.BOTTOM) {
            return c.height - a - b.height
        } else {
            return c.height
        }
    }, _getLegendX: function (a) {
        if (this.position == FR.Chart.Constants.LEFT) {
            return a.x
        } else {
            if (this.position == FR.Chart.Constants.RIGHT || this.position == FR.Chart.Constants.RIGHT_TOP) {
                return a.x + a.width - this._getLegendWidth(a)
            } else {
                return a.x + (a.width - this._getLegendWidth(a)) / 2
            }
        }
    }, _getLegendY: function (a) {
        if (this.position == FR.Chart.Constants.TOP) {
            return a.y
        } else {
            if (this.position == FR.Chart.Constants.BOTTOM) {
                return a.y + a.height - this._getLegendHeight(a)
            } else {
                if (this.position == FR.Chart.Constants.RIGHT_TOP) {
                    return a.y
                } else {
                    return a.y + (a.height - this._getLegendHeight(a)) / 2
                }
            }
        }
    }, _getLegendWidth: function (a) {
        return this._preferredLegendSizeWithChartBounds(a).width
    }, _getLegendHeight: function (a) {
        return this._preferredLegendSizeWithChartBounds(a).height
    }, _preferredLegendSizeWithChartBounds: function (a) {
        if (this.items == null || this.items.length === 0) {
            return new FR.Chart.Dimension2D()
        }
        if (this._isInTopAndBottom()) {
            return this._preLegendDim4TopAndBottom(a)
        } else {
            return this._preLegendDimLeftAndRight(a)
        }
    }, refreshItemBoundsWithLegendBounds: function (a) {
        if (this.items == null || this.items.length <= 0) {
            return
        }
        if (this._isInTopAndBottom()) {
            this._refreshLegendItemTopAndBottom(a)
        } else {
            this._refreshLegendItemLeftAndRight(a)
        }
    }, _checkIsUseButton4Top: function (g) {
        var h = false;
        var e = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var a = e;
        var d = false;
        for (var c = 0; c < this.items.length;
             c++) {
            var b = this.items[c].prefferedSize(this.font);
            if (this._isNotEnough4ItemInTopAndBottom(e, b, g)) {
                if (d) {
                    h = true;
                    break
                } else {
                    d = true;
                    e = a + b.width + FR.Chart.LegendGlyph.ROW_COL_GAP
                }
            } else {
                e += b.width + FR.Chart.LegendGlyph.ROW_COL_GAP
            }
        }
        if (h) {
            var f = FR.Chart.GraphHelper.stringDimension(FR.Chart.LegendGlyph.TWO_FONT_AND_MORE, this.font, 0).width;
            e = FR.Chart.LegendGlyph.PADDING_GAP * 2 + this.font.size / 2 + FR.Chart.LegendGlyph.ROW_COL_GAP * 2 + f + FR.Chart.LegendButton.RIGHT_WIDTH * 2;
            h = e < g.width
        }
        return h
    }, _refreshLegendItemTopAndBottom4Mobile: function (f) {
        var b = this._getRealStartMoveBarFrom() + FR.Chart.LegendGlyph.PADDING_GAP + f.x;
        for (var d = 0; d < this.items.length; d++) {
            var c = this.items[d].prefferedSize(this.font);
            var a = b;
            var g = FR.Chart.LegendGlyph.PADDING_GAP + f.y;
            var e = 0;
            if (d == this.items.length - 1) {
                e = parseInt(b + c.width)
            } else {
                e = parseInt(b + c.width + FR.Chart.LegendGlyph.ROW_COL_GAP)
            }
            if (e > parseInt(f.x + f.width) || parseInt(b) < parseInt(f.x)) {
                this.items[d].bounds = null
            } else {
                this._refresItemBounds(d, a, g, c)
            }
            b += c.width + FR.Chart.LegendGlyph.ROW_COL_GAP
        }
    }, _getRealStartMoveBarFrom: function () {
        if (!this.moveBarLength || !this.moveAllLength) {
            return 0
        }
        var a = 0;
        if (this._isInTopAndBottom()) {
            a = this.moveAllLength * this.startItemX4Mobile / this.moveBarLength
        } else {
            a = this.moveAllLength * this.startItemY4Mobile / this.moveBarLength
        }
        return -a
    }, _refreshLegendItemTopAndBottom: function (t) {
        var p = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var f = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var c = 0;
        for (var o = 0; o < this.items.length; o++) {
            var l = this.items[o].prefferedSize(this.font);
            c = Math.max(c, l.height)
        }
        var d = this._checkIsUseButton4Top(t);
        this.useButton = d;
        if (this.useButton) {
            var m = FR.Chart.LegendButton.RIGHT_WIDTH;
            var g = t.y + FR.Chart.LegendGlyph.PADDING_GAP + c + (FR.Chart.LegendGlyph.ROW_COL_GAP - FR.Chart.LegendButton.TOP_HEIGHT) / 2;
            var a = t.x + t.width;
            var j = a - FR.Chart.LegendGlyph.PADDING_GAP - m * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
            var e = a - FR.Chart.LegendGlyph.PADDING_GAP - m;
            if (!this.forwardButton) {
                this.forwardButton = new FR.Chart.LegendButton(j, g, FR.Chart.Constants.LEFT);
                this.forwardButton.isDisable = false
            } else {
                this.forwardButton.initButtonBounds(j, g)
            }
            if (!this.backButton) {
                this.backButton = new FR.Chart.LegendButton(e, g, FR.Chart.Constants.RIGHT);
                this.backButton.isDisable = true
            } else {
                this.backButton.initButtonBounds(e, g)
            }
        }
        var s = false;
        var r = true;
        var b = false;
        var q = t.x;
        var k = t.x + p;
        for (var o = 0; o < this.items.length; o++) {
            var l = this.items[o].prefferedSize(this.font);
            if (this._isNotEnough4ItemInTopAndBottom(p + this._getPreButtonWidth(), l, t)) {
                if (s && b) {
                    if (this.useButton && this.startItemIndex === 0 && r) {
                        this.endItemIndex = o - 1;
                        r = false
                    }
                }
                if (k == p) {
                    if (o >= this.startItemIndex && o <= this.endItemIndex) {
                        var n = new FR.Chart.Dimension2D(t.width - k - 20 - 2 * FR.Chart.LegendGlyph.PADDING_GAP, l.height);
                        if (s) {
                            this._refresItemBounds(o, k + q, t.y + FR.Chart.LegendGlyph.PADDING_GAP + n.height + FR.Chart.LegendGlyph.ROW_COL_GAP, n);
                            b = true
                        } else {
                            this._refresItemBounds(o, k + q, t.y + FR.Chart.LegendGlyph.PADDING_GAP, n);
                            s = true
                        }
                        p = k;
                        f = FR.Chart.LegendGlyph.PADDING_GAP * 2 + c
                    } else {
                        this.items[o].bounds = null
                    }
                } else {
                    if (o >= this.startItemIndex && o <= this.endItemIndex) {
                        if (s) {
                            this.items[o].bounds = null
                        } else {
                            f = FR.Chart.LegendGlyph.PADDING_GAP * 2 + c;
                            if (o === this.startItemIndex) {
                                f = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP
                            }
                            s = o !== this.startItemIndex;
                            b = o !== this.startItemIndex;
                            p = k - q;
                            var h = p + q - FR.Chart.LegendGlyph.PADDING_GAP + FR.Chart.LegendGlyph.ROW_COL_GAP;
                            var g = t.y + f - FR.Chart.LegendGlyph.PADDING_GAP + FR.Chart.LegendGlyph.ROW_COL_GAP;
                            if (this._isNotEnough4ItemInTopAndBottom(p + this._getPreButtonWidth(), l, t)) {
                                var n = new FR.Chart.Dimension2D(t.width - k - 20 - 2 * FR.Chart.LegendGlyph.PADDING_GAP, l.height);
                                this._refresItemBounds(o, h, g, n);
                                this.items[o].drawInCutOrNot = true
                            } else {
                                this._refresItemBounds(o, h, g, l)
                            }
                            p += l.width + FR.Chart.LegendGlyph.ROW_COL_GAP
                        }
                    } else {
                        this.items[o].bounds = null
                    }
                }
            } else {
                if (o >= this.startItemIndex && o <= this.endItemIndex) {
                    var h = t.x + p - FR.Chart.LegendGlyph.PADDING_GAP + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    var g = t.y + f - FR.Chart.LegendGlyph.PADDING_GAP + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    this._refresItemBounds(o, h, g, l);
                    p += l.width + FR.Chart.LegendGlyph.ROW_COL_GAP
                } else {
                    this.items[o].bounds = null
                }
            }
        }
    }, _preLegendDim4TopAndBottom4Mobile: function (e) {
        this._initMaxLegendWidth4DrawisCut(e);
        var c = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var f = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var d = c;
        for (var b = 0; b < this.items.length; b++) {
            var a = this.items[b].prefferedSize(this.font);
            if (this._isNotEnough4ItemInTopAndBottom(c, a, e)) {
                c = e.width
            } else {
                c += a.width + FR.Chart.LegendGlyph.ROW_COL_GAP
            }
            f = FR.Chart.LegendGlyph.PADDING_GAP * 2 + a.height;
            d += a.width + FR.Chart.LegendGlyph.ROW_COL_GAP
        }
        this.moveAllLength = c;
        if (d > c) {
            this.moveBarLength = c * (c / d)
        }
        this._checkScroll4Mobile();
        return new FR.Chart.Dimension2D(Math.round(c), Math.round(f))
    }, _preLegendDim4TopAndBottom: function (k) {
        var c = this._checkIsUseButton4Top(k);
        this.useButton = c;
        this._initMaxLegendWidth4DrawisCut(k);
        var f = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var g = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var e = f;
        var j = 0;
        for (var d = 0; d < this.items.length; d++) {
            var h = this.items[d].prefferedSize(this.font);
            j = Math.max(j, h.height)
        }
        var b = false;
        var a = 0;
        for (var d = 0; d < this.items.length; d++) {
            var h = this.items[d].prefferedSize(this.font);
            if (this._isNotEnough4ItemInTopAndBottom(f + this._getPreButtonWidth(), h, k)) {
                if (b) {
                    g = FR.Chart.LegendGlyph.PADDING_GAP * 2 + j * 2 + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    f = k.width;
                    break
                } else {
                    b = true;
                    a = f;
                    f = e + h.width + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    g = FR.Chart.LegendGlyph.PADDING_GAP * 2 + j * 2 + FR.Chart.LegendGlyph.ROW_COL_GAP
                }
            } else {
                f += h.width + FR.Chart.LegendGlyph.ROW_COL_GAP;
                if (!b) {
                    g = FR.Chart.LegendGlyph.PADDING_GAP * 2 + j
                }
            }
        }
        return new FR.Chart.Dimension2D(Math.max(Math.round(f), a), Math.round(g))
    }, _checkButtonInRightOrCenter: function (a) {
        var b = FR.Chart.LegendButton.TOP_WIDTH * 2 + FR.Chart.LegendGlyph.PADDING_GAP * 2 + FR.Chart.LegendGlyph.ROW_COL_GAP;
        return a < b
    }, _refreshLegendItemLeftAndRight4Mobile: function (g) {
        var f = g.width - FR.Chart.LegendGlyph.PADDING_GAP * 2;
        var b = g.y + this._getRealStartMoveBarFrom() + FR.Chart.LegendGlyph.PADDING_GAP;
        for (var e = 0; e < this.items.length; e++) {
            var d = this.items[e].prefferedSize(this.font);
            var a = FR.Chart.LegendGlyph.PADDING_GAP + g.x;
            var h = b + e * d.height + e * FR.Chart.LegendGlyph.ROW_COL_GAP;
            if (parseInt(h) + d.height > g.y + g.height || parseInt(h) < g.y) {
                this.items[e].bounds = null
            } else {
                if (d.width <= f) {
                    this._refresItemBounds(e, a, h, d)
                } else {
                    var c = new FR.Chart.Dimension2D(f, d.height);
                    this._refresItemBounds(e, a, h, c);
                    this.items[e].drawInCutOrNot = true
                }
            }
        }
    }, _refreshLegendItemLeftAndRight: function (o) {
        var g = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var h = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var d = o.width - FR.Chart.LegendGlyph.PADDING_GAP * 2;
        if (this.useButton) {
            var l = FR.Chart.LegendButton.TOP_WIDTH;
            var c = 4;
            var p = this._checkButtonInRightOrCenter(o.width);
            var m = o.height - FR.Chart.LegendButton.TOP_HEIGHT - c;
            var a = p ? o.width * 0.5 - l : o.width - FR.Chart.LegendGlyph.PADDING_GAP - l * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
            var f = p ? o.width * 0.5 : o.width - FR.Chart.LegendGlyph.PADDING_GAP - l;
            if (!this.forwardButton) {
                this.forwardButton = new FR.Chart.LegendButton(o.x + a, o.y + m, FR.Chart.Constants.TOP);
                this.forwardButton.isDisable = false
            } else {
                this.forwardButton.initButtonBounds(o.x + a, o.y + m)
            }
            if (!this.backButton) {
                this.backButton = new FR.Chart.LegendButton(o.x + f, o.y + m, FR.Chart.Constants.BOTTOM);
                this.backButton.isDisable = true
            } else {
                this.backButton.initButtonBounds(o.x + f, o.y + m)
            }
        }
        var e = true;
        for (var b = 0; b < this.items.length; b++) {
            var k = this.items[b].prefferedSize(this.font);
            if (this._isNoEnough4ItemInLeftAndRight(h, k, o)) {
                if (this.useButton && this.startItemIndex === 0 && e) {
                    this.endItemIndex = b - 1;
                    e = false
                }
                this.items[b].bounds = null
            } else {
                if (b >= this.startItemIndex && b <= this.endItemIndex) {
                    var n = o.x + g - FR.Chart.LegendGlyph.PADDING_GAP + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    var m = o.y + h - FR.Chart.LegendGlyph.PADDING_GAP + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    if (k.width <= d) {
                        this._refresItemBounds(b, n, m, k)
                    } else {
                        var j = new FR.Chart.Dimension2D(d, k.height);
                        this._refresItemBounds(b, n, m, j);
                        this.items[b].drawInCutOrNot = true
                    }
                    h += k.height + FR.Chart.LegendGlyph.ROW_COL_GAP
                } else {
                    this.items[b].bounds = null
                }
            }
        }
    }, _checkIsUseButton4LeftAndRight: function (d) {
        var g = false;
        var e = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        for (var b = 0; b < this.items.length; b++) {
            var a = this.items[b].prefferedSize(this.font);
            if (this._isNoEnough4ItemInLeftAndRight(e, a, d)) {
                g = true;
                break
            } else {
                e += a.height + FR.Chart.LegendGlyph.ROW_COL_GAP
            }
        }
        if (g) {
            var c = this.maxLabelWidth;
            var f = this._getMinButtonWidth4LeftAndRight();
            g = c > f
        }
        return g
    }, _getMinButtonWidth4LeftAndRight: function () {
        return FR.Chart.LegendButton.TOP_WIDTH * 2 + FR.Chart.LegendGlyph.PADDING_GAP * 2
    }, _preLegendDimLeftAndRight4Mobile: function (e) {
        this._initMaxLegendWidth4DrawisCut(e);
        var c = 0;
        var f = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var d = f;
        for (var b = 0; b < this.items.length; b++) {
            var a = this.items[b].prefferedSize(this.font);
            if (this._isNoEnough4ItemInLeftAndRight(f, a, e)) {
                if (f + FR.Chart.LegendGlyph.ROW_COL_GAP + a.height / 2 > e.height) {
                    f -= a.height + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    f += a.height / 2 - FR.Chart.LegendGlyph.PADDING_GAP
                } else {
                    f += a.height / 2 - FR.Chart.LegendGlyph.PADDING_GAP
                }
            } else {
                c = Math.max(c, FR.Chart.LegendGlyph.PADDING_GAP * 2 + a.width);
                f += a.height + FR.Chart.LegendGlyph.ROW_COL_GAP
            }
            d += a.height + FR.Chart.LegendGlyph.ROW_COL_GAP
        }
        this.moveAllLength = f;
        if (d > f) {
            this.moveBarLength = f * (f / d)
        }
        this._checkScroll4Mobile();
        return new FR.Chart.Dimension2D(Math.min(Math.round(c), this.maxLabelWidth), Math.round(f))
    }, _preLegendDimLeftAndRight: function (j) {
        var b = this._checkIsUseButton4LeftAndRight(j);
        this.useButton = b;
        this._initMaxLegendWidth4DrawisCut(j);
        var e = 0;
        var f = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var a = false;
        for (var c = 0; c < this.items.length; c++) {
            var g = this.items[c].prefferedSize(this.font);
            if (this._isNoEnough4ItemInLeftAndRight(f, g, j)) {
                var h = FR.Chart.LegendButton.RIGHT_WIDTH;
                var d = 4;
                if (!a && b) {
                    if (f + d + h > j.height) {
                        f -= g.height + FR.Chart.LegendGlyph.ROW_COL_GAP;
                        f += d + h
                    } else {
                        f += d + h
                    }
                    a = true
                }
            } else {
                e = Math.max(e, FR.Chart.LegendGlyph.PADDING_GAP * 2 + g.width);
                f += g.height + FR.Chart.LegendGlyph.ROW_COL_GAP
            }
        }
        if (b) {
            e = Math.max(e, this._getMinButtonWidth4LeftAndRight())
        }
        return new FR.Chart.Dimension2D(Math.min(Math.round(e), this.maxLabelWidth), Math.round(f))
    }, _initMaxLegendWidth4DrawisCut: function (b) {
        if (b) {
            if (this._isInTopAndBottom()) {
                if (this.useButton) {
                    this.maxLabelWidth = b.width - this._getPreButtonWidth() - FR.Chart.LegendGlyph.ROW_COL_GAP
                } else {
                    this.maxLabelWidth = b.width
                }
            } else {
                this.maxLabelWidth = b.width * FR.Chart.LegendGlyph.MAX_LEFT_WIDTH
            }
            var a = FR.Chart.GraphHelper.stringDimension(FR.Chart.LegendGlyph.TWO_FONT_AND_MORE, this.font, 0).width;
            this.drawInCutOrNot = a > this.maxLabelWidth - FR.Chart.LegendGlyph.PADDING_GAP * 2 - this.font.size / 2 - FR.Chart.LegendGlyph.ROW_COL_GAP
        }
    }, _refresItemBounds: function (b, a, d, c) {
        if (this.items[b]) {
            this.items[b].bounds = new FR.Chart.Bounds(a, d, c.width, c.height);
            this.items[b].drawInCutOrNot = this.drawInCutOrNot
        }
    }, _isInTopAndBottom: function () {
        return (this.position == FR.Chart.Constants.TOP || this.position == FR.Chart.Constants.BOTTOM)
    }, _isNotEnough4ItemInTopAndBottom: function (c, a, b) {
        return parseInt(c + a.width + FR.Chart.LegendGlyph.ROW_COL_GAP) > b.width
    }, _isNoEnough4ItemInLeftAndRight: function (c, a, b) {
        return parseInt(c + a.height + FR.Chart.LegendGlyph.ROW_COL_GAP) > b.height
    }, _refreshItemWithForwardButton: function () {
        var a = this._calInt4ItemWithLegendBoundsForward();
        if (a > 0) {
            this.endItemIndex = Math.min(this.startItemIndex - 1, this.items.length);
            this.startItemIndex = Math.max(this.endItemIndex - a + 1, 0)
        }
        this._checkLegendButton()
    }, _getPreButtonWidth: function () {
        var a = 0;
        if (this.useButton) {
            a = FR.Chart.LegendButton.RIGHT_WIDTH * 2 + FR.Chart.LegendGlyph.ROW_COL_GAP
        }
        return a
    }, _calInt4ItemWithLegendBoundsForward: function () {
        var b = 0;
        if (this.startItemIndex === 0) {
            return 0
        }
        var a = 0;
        while (true) {
            b = this._checkStartValueCount(a, this.startItemIndex);
            if (b === 0 || b + a == this.startItemIndex || b + a > this.startItemIndex) {
                break
            } else {
                a += b
            }
        }
        return b
    }, _checkLegendButton: function () {
        var b = this._calInt4ItemWithLegendBoundsForward();
        var a = this._calInt4ItemWithLegendBoundsBack();
        this.forwardButton.isDisable = this.startItemIndex > 0 && b > 0;
        this.backButton.isDisable = this.endItemIndex < this.items.length - 1 && a > 0
    }, _refreshItemWithBackButton: function () {
        var a = this._calInt4ItemWithLegendBoundsBack();
        if (a > 0) {
            this.startItemIndex = Math.min(this.endItemIndex + 1, this.items.length);
            this.endItemIndex = Math.min(this.startItemIndex + a - 1, this.items.length)
        }
        this._checkLegendButton()
    }, _calInt4ItemWithLegendBoundsBack: function () {
        return this._checkStartValueCount(this.endItemIndex + 1, this.items.length)
    }, _checkStartValueCount: function (b, a) {
        var d = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var g = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
        var f = false;
        var e = 0;
        for (var h = b; h < a; h++) {
            var c = this.items[h].prefferedSize(this.font);
            if (this._isInTopAndBottom()) {
                if (this._isNotEnough4ItemInTopAndBottom(d + this._getPreButtonWidth(), c, this.bounds)) {
                    if (h == b) {
                        d += c.width + FR.Chart.LegendGlyph.ROW_COL_GAP;
                        e++;
                        continue
                    } else {
                        if (!f) {
                            f = true;
                            d = FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP;
                            if (this._isNotEnough4ItemInTopAndBottom(d + this._getPreButtonWidth(), c, this.bounds)) {
                                e++;
                                break
                            } else {
                                d += c.width + FR.Chart.LegendGlyph.ROW_COL_GAP;
                                e++
                            }
                        } else {
                            if (d == FR.Chart.LegendGlyph.PADDING_GAP * 2 - FR.Chart.LegendGlyph.ROW_COL_GAP) {
                                e++
                            }
                            break
                        }
                    }
                } else {
                    d += c.width + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    e++
                }
            } else {
                if (this._isNoEnough4ItemInLeftAndRight(g, c, this.bounds)) {
                    break
                } else {
                    g += c.height + FR.Chart.LegendGlyph.ROW_COL_GAP;
                    e++
                }
            }
        }
        return e
    }, onPress: function (a, c) {
        var b = this.getBounds();
        if (a.y < b.y || a.x > b.x + b.width) {
            return
        }
        if (this.useButton) {
            this.forwardButton.onPress = false;
            this.backButton.onPress = false;
            if (this.forwardButton) {
                if (this.forwardButton.containsPoint(a.x, a.y) && this.forwardButton.isDisable) {
                    this.forwardButton.onPress = true;
                    return
                }
            }
            if (this.backButton) {
                if (this.backButton.containsPoint(a.x, a.y) && this.backButton.isDisable) {
                    this.backButton.onPress = true;
                    return
                }
            }
        }
    }, onClick: function (a, f) {
        var e = this.getBounds();
        if (a.y < e.y || a.x > e.x + e.width) {
        }
        if (!(this.bounds && this.bounds.getBounds2D().containsPoint(a.x, a.y))) {
            return
        }
        if (this.useButton) {
            if (this.forwardButton && this.forwardButton.bounds && this.forwardButton.isDisable) {
                if (this.forwardButton.containsPoint(a.x, a.y)) {
                    this._refreshItemWithForwardButton();
                    f.needRefresh = true;
                    f.needAnimateRefresh = false;
                    return
                }
            }
            if (this.backButton && this.backButton.bounds && this.backButton.isDisable) {
                if (this.backButton.containsPoint(a.x, a.y)) {
                    this._refreshItemWithBackButton();
                    f.needRefresh = true;
                    f.needAnimateRefresh = false;
                    return
                }
            }
        }
        if (this.items) {
            for (var c = 0; c < this.items.length; c++) {
                if (!this.items[c].getBounds()) {
                    continue
                }
                var g = this.items[c].prefferedSize(this.font);
                var d = new FR.Chart.Bounds(this.items[c].getBounds().x, this.items[c].getBounds().y, g.width, g.height);
                if (d && d.containsPoint(a.x, a.y) && c < this.seriesList.length) {
                    var b = this.items[c].disable;
                    this.items[c].disable = !b;
                    if (f._chartGlyph && f._chartGlyph.hasCombineGlyph()) {
                        f.needRefresh = true;
                        this._changeCombineGlyphStatus(c, f)
                    } else {
                        f.needRefresh = true;
                        f.needRefreshLabel = true;
                        this._changeLegendStatus(this.seriesList, c);
                        if (f._chartGlyph) {
                            f._chartGlyph.plotGlyph.createHotTooltip()
                        }
                    }
                    return
                }
            }
        }
    }, _changeCombineGlyphStatus: function (b) {
        for (var d = 0; d < this.seriesList.length; d++) {
            var g = this.seriesList[d];
            for (var c = 0, f = g.points.length; c < f; c++) {
                var a = g.points[c];
                if (a.combineGlyph && a.combineGlyph.plotGlyph) {
                    var e = a.combineGlyph.plotGlyph;
                    this._changeLegendStatus(e.dataSeries, b)
                }
            }
        }
    }, _changeLegendStatus: function (b, a) {
        if (b && b[a]) {
            if (b[a].paintState >= FR.Chart.ChartPaintConstants.STATE_ENABLE) {
                b[a].paintState = FR.Chart.ChartPaintConstants.STATE_DISAPPEAR
            } else {
                if (b[a].paintState <= FR.Chart.ChartPaintConstants.STATE_UNENABLE) {
                    b[a].paintState = FR.Chart.ChartPaintConstants.STATE_APPEAR
                }
            }
        }
    }, drawOnPress: function (a) {
        if (this.bounds) {
            if (this.backButton && this.backButton.onPress) {
                this.backButton.drawOnPress(a)
            }
            if (this.forwardButton && this.forwardButton.onPress) {
                this.forwardButton.drawOnPress(a)
            }
        }
    }, _checkScroll4Mobile: function () {
        this.isScroll = this.moveBarLength > 0
    }, _drawMoveBarInPressing: function (b) {
        if (this.legendPressing && this.moveBarLength && this.moveBarLength > 0) {
            if (!b) {
                return
            }
            b.save();
            var d = 2.5;
            var c = 5;
            if (this._isInTopAndBottom()) {
                var a = new FR.Chart.RoundBounds(this.startItemX4Mobile, 0, this.moveBarLength, c, d, d);
                b.fillStyle = "rgba(51, 51, 51, 0.6)";
                a.paint(b)
            } else {
                var a = new FR.Chart.RoundBounds(this.bounds.width - c, this.startItemY4Mobile, c, this.moveBarLength, d, d);
                b.fillStyle = "rgba(51, 51, 51, 0.6)";
                a.paint(b)
            }
            b.restore()
        }
    }, doOnMove: function (b, a) {
        if (this.bounds && this.backButton && this.forwardButton) {
            if (this.backButton) {
                this.backButton.draw4OnMove(b)
            }
            if (this.forwardButton) {
                this.forwardButton.draw4OnMove(b)
            }
        }
        if (this.onmoveitem) {
            this.onmoveitem.doOnMove(b, a)
        }
    }, findOnMoveGlyph: function (a, c) {
        if (!(this.bounds && this.bounds.getBounds2D().containsPoint(a.x, a.y))) {
            return
        }
        this.findOnMoveLegendButtonGlyph(a, c);
        if (c._hasfound) {
            return
        }
        this.onmoveitem = null;
        if (this.items) {
            for (var b = 0; b < this.items.length; b++) {
                this.items[b].findOnMoveGlyph(a, c);
                if (c._hasfound) {
                    this.items[b].font = this.font;
                    this.onmoveitem = this.items[b];
                    c._lastHover = this;
                    break
                }
            }
        }
        if (this.moveBarLength > 0) {
            c._lastHover = c._lastHover || this;
            c._hasfound = true;
            c._draggingTarget = this
        }
    }, findOnMoveLegendButtonGlyph: function (a, b) {
        if (this.useButton) {
            this.forwardButton.onMove = false;
            this.backButton.onMove = false;
            if (this.forwardButton) {
                if (this.forwardButton.containsPoint(a.x, a.y) && this.forwardButton.isDisable) {
                    this.forwardButton.onMove = true;
                    b.cursor = ChartHandler.POINTER;
                    b._hasfound = true;
                    b._lastHover = this;
                    return
                }
            }
            if (this.backButton) {
                if (this.backButton.containsPoint(a.x, a.y) && this.backButton.isDisable) {
                    this.backButton.onMove = true;
                    b.cursor = ChartHandler.POINTER;
                    b._hasfound = true;
                    b._lastHover = this
                }
            }
        }
    }, move4Mobile: function (c, a, b) {
        var d = c;
        if (this._isInTopAndBottom()) {
            this.startItemX4Mobile -= a.x - d.x;
            this.startItemX4Mobile = Math.min(this.startItemX4Mobile, this.moveAllLength - this.moveBarLength);
            this.startItemX4Mobile = Math.max(this.startItemX4Mobile, 0)
        } else {
            this.startItemY4Mobile -= a.y - d.y;
            this.startItemY4Mobile = Math.min(this.startItemY4Mobile, this.moveAllLength - this.moveBarLength);
            this.startItemY4Mobile = Math.max(this.startItemY4Mobile, 0)
        }
        b.translate(this.bounds.x, this.bounds.y);
        this._drawMoveBarInPressing(b);
        b.translate(-this.bounds.x, -this.bounds.y);
        event.refreshLegend = true
    }, onDragStart: function (a, c) {
        var b = this.getBounds();
        if (a.y < b.y || a.x > b.x + b.width) {
            return
        }
        if (this.bounds.containsPoint(a.x, a.y)) {
            c._draggingTarget = this
        }
    }, onDragEnd: function (a, b) {
    }, onDrag: function () {
    }, synchronizeLegendColorWithSeries: function (b, d) {
        if (d) {
            var c = FR.Chart.ChartUtils.createFillColorArray(b, d.length);
            for (var a = 0; a < this.items.length; a++) {
                var e = this.items[a].lineMarkerIcon;
                if (e.background.backgroundType == "ColorBackground") {
                    e.background.color = c[a]
                }
                if (e.marker && e.marker.background && e.marker.background == "ColorBackground") {
                    e.marker.background.color = c[a]
                }
            }
        }
    }
});
$.extend(FR.Chart.LegendGlyph, {
    PADDING_GAP: 4,
    ROW_COL_GAP: 5,
    MAX_LEFT_WIDTH: 0.28,
    TWO_FONT_AND_MORE: FR.i18nText("Chart-Chart_Name") + FR.Chart.Constants.ESP
});
FR.Chart.DataSheetGlyph = FR.extend(FR.Chart.RectangleGlyph, {
    initConstants: function (c) {
        c = c || {};
        this.font = c.font == undefined ? null : new FR.Chart.FRFont(c.font);
        this.format = c.format;
        this.items = null;
        if (c.items) {
            this.items = [];
            var b = c.items;
            for (var a = 0; a < b.length; a++) {
                this.items[a] = new FR.Chart.LegendItem(b[a])
            }
        }
        FR.Chart.DataSheetGlyph.superclass.initConstants.apply(this, [c]);
        this.seriesList = [];
        this.beginX = 0;
        this.unitLength = 0;
        this.seriesRowHeight = 0;
        this.endLegendWidth = 0;
        this.cateRowCout = 1;
        this.tooltipLabelBoundsList = [];
        this.tooltipLabelList = [];
        this.PADDING_GAP = 4;
        this.MAX_CATE_LINE = 4
    }, getCategoryCount: function () {
        var a = 0;
        if (this.seriesList[0]) {
            a = this.seriesList[0].points.length
        }
        return a
    }, getFont: function () {
        return this.font == null ? new FR.Chart.FRFont() : this.font
    }, getTextAttr: function () {
        var a = new FR.Chart.TextAttr();
        a.frFont = this.getFont();
        return a
    }, setUnitLength: function (a) {
        this.unitLength = a
    }, getPrefferedSize: function (b) {
        if (this.seriesList.length < 1) {
            return new FR.Chart.Dimension2D()
        }
        this._initSeriesRowHeightAndEndLegendWidth(b);
        var d = this.getMaxCateString(b) || "";
        var a = this.getCharNumber(this.getTextAttr(), this.unitLength);
        if (a === 0) {
            this.cateRowCout = 1
        } else {
            var c = Math.max(Math.ceil(d.length / a), 1);
            this.cateRowCout = Math.min(this.MAX_CATE_LINE, c)
        }
        return new FR.Chart.Dimension2D(this.endLegendWidth + this.PADDING_GAP * 2, (this.seriesRowHeight + this.PADDING_GAP * 2) * (this.seriesList.length) + this.cateRowCout * this.seriesRowHeight + this.PADDING_GAP * 2)
    }, _initSeriesRowHeightAndEndLegendWidth: function (d) {
        this.seriesRowHeight = Number.MIN_VALUE;
        var c = Number.MIN_VALUE;
        var a = d.getBounds().width / 4;
        for (var b = 0; b < this.seriesList.length; b++) {
            var e = null;
            if (this.items != null && this.items.length >= this.seriesList.length) {
                e = this.items[b].prefferedSize(this.getFont())
            } else {
                e = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(this.seriesList[b].seriesName, this.getTextAttr())
            }
            if (e.width > c) {
                c = Math.min(e.width, a)
            }
            if (e.height > this.seriesRowHeight) {
                this.seriesRowHeight = e.height
            }
        }
        this.endLegendWidth = c
    }, getMaxCateString: function (d) {
        var c = d.plotGlyph.getCategoryCount();
        var a = new FR.Chart.Dimension2D();
        var g = "";
        for (var b = 0; b < c; b++) {
            var e = this.seriesList[0].points[b].categoryName;
            var f = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(e, this.getTextAttr());
            if (f.width > a.width) {
                a = f;
                g = e
            }
        }
        return g
    }, doLayout: function (b) {
        if (b instanceof FR.Chart.CategoryPlotGlyph) {
            var a = b.xAxisGlyph.position;
            if (a == FR.Chart.Constants.TOP || a == FR.Chart.Constants.BOTTOM) {
                this.beginX = b.xAxisGlyph.getBounds().x;
                this.unitLength = b.xAxisGlyph.getBounds().width / b.getCategoryCount();
                this.getBounds().width = this.beginX + b.xAxisGlyph.axisLength - this.getBounds().x
            } else {
                this.beginX = b.yAxisGlyph.getBounds().x;
                this.unitLength = (this.getBounds().x + this.getBounds().width - this.beginX) / b.getCategoryCount();
                this.getBounds().width = this.beginX + b.yAxisGlyph.axisLength - this.getBounds().x
            }
        } else {
            if (b instanceof FR.Chart.StockPlotGlyph) {
                this.beginX = b.xAxisGlyph.getBounds().x;
                this.unitLength = b.xAxisGlyph.unitLength;
                this.getBounds().width = this.beginX + b.xAxisGlyph.axisLength - this.getBounds().x
            }
        }
        this.crossValue = b.xAxisGlyph.getCrossValue();
        this.arrowValue = b.xAxisGlyph.getArrowValue()
    }, findOnMoveGlyph: function (a, e) {
        if (!this.tooltipLabelBoundsList || this.tooltipLabelBoundsList.length === 0) {
            return
        }
        var d = this.getBounds();
        if (a.y < d.y || a.x > d.x + d.width) {
            return
        }
        if (this.items) {
            for (var b = 0; b < this.items.length; b++) {
                this.items[b].findOnMoveGlyph(a, e);
                if (e._hasfound) {
                    var c = this.items[b];
                    if (c.fontColor) {
                        this.toolTipBackground = FR.Chart.ColorBackground.getInstance(c.fontColor)
                    } else {
                        if (c.lineMarkerIcon) {
                            this.toolTipBackground = c.lineMarkerIcon.background
                        }
                    }
                    break
                }
            }
        }
        this.tooltip = null;
        for (var b = 0; b < this.tooltipLabelBoundsList.length;
             b++) {
            if (this.tooltipLabelBoundsList[b] && this.tooltipLabelBoundsList[b].containsPoint(a.x, a.y)) {
                this.tooltip = this.tooltipLabelList[b];
                e._hasfound = true;
                e._lastHover = this;
                return
            }
        }
    }, doOnMove: function (b, a) {
        FR.Chart.Tooltip.dataPointTip(b, this.tooltip, a, this.toolTipBackground)
    }, getCharNumber: function (a, d) {
        if (isNaN(d) || !a || !a.frFont) {
            return 0
        }
        var b = a.frFont.size;
        var c = parseInt(d / b);
        return isNaN(c) ? 0 : c
    }, _drawSeries: function (a, c) {
        if (this.items != null && this.items.length >= this.seriesList.length) {
            var d = this.seriesRowHeight * this.cateRowCout + this.PADDING_GAP * 2;
            for (var b = 0; b < this.seriesList.length; b++) {
                this.items[b].bounds = new FR.Chart.Bounds(c.x + this.PADDING_GAP, c.y + (this.seriesRowHeight + this.PADDING_GAP * 2) * b + d + this.PADDING_GAP, this.endLegendWidth, this.seriesRowHeight);
                this.items[b].draw(a, this.getFont());
                this.tooltipLabelList.push(this.items[b].label);
                this.tooltipLabelBoundsList.push(this.items[b].bounds)
            }
        }
    }, _drawCategory: function (r, a) {
        var s = this.getTextAttr();
        var p = this.getCharNumber(s, this.unitLength);
        if (p <= 0) {
            return
        }
        var c = "";
        var d = this.seriesRowHeight * this.cateRowCout + this.PADDING_GAP * 2;
        var k = new FR.Chart.Dimension2D(0, 0);
        for (var f = 0; f < this.getCategoryCount() && f < this.arrowValue; f++) {
            var g = f - this.crossValue;
            if (g < 0) {
                continue
            }
            var e = this.seriesList[0].points[f].categoryName || "";
            var b = parseInt(e.length / p);
            var q = this.beginX + g * this.unitLength;
            if (b < this.MAX_CATE_LINE) {
                for (var l = 0; l < this.MAX_CATE_LINE; l++) {
                    var h = Math.min((l + 1) * p, e.length);
                    c = e.substring(l * p, h);
                    k = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, s);
                    FR.Chart.TextUtils.drawLabelWithNoRotation(r, c, s, new FR.Chart.Bounds(q + (this.unitLength - k.width) / 2, a.y + (this.seriesRowHeight - k.height) / 2 + l * this.seriesRowHeight + this.PADDING_GAP, k.width, k.height));
                    if (h === e.length) {
                        break
                    }
                }
            } else {
                this.tooltipLabelList.push(e);
                this.tooltipLabelBoundsList.push(new FR.Chart.Bounds(q, a.y, this.unitLength, d));
                for (var l = 0; l < this.MAX_CATE_LINE - 1; l++) {
                    c = e.substring(l * p, (l + 1) * p);
                    k = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(c, s);
                    FR.Chart.TextUtils.drawLabelWithNoRotation(r, c, this.getTextAttr(), new FR.Chart.Bounds(q + (this.unitLength - k.width) / 2, a.y + (this.seriesRowHeight - k.height) / 2 + l * this.seriesRowHeight + this.PADDING_GAP, k.width, k.height))
                }
                var m = this._getEllipsisDim();
                var o = q + (this.unitLength - m.width) / 2;
                var n = a.y + (this.seriesRowHeight - m.height) / 2 + 3 * this.seriesRowHeight + this.PADDING_GAP;
                this._drawEllipsis(r, o, n)
            }
        }
    }, _drawValues: function (t, a) {
        var c = this.seriesRowHeight * this.cateRowCout + this.PADDING_GAP * 2;
        var l = this.getTextAttr();
        for (var g = 0; g < this.seriesList.length; g++) {
            var f = this.seriesList[g];
            for (var e = 0; e < this.getCategoryCount() && e < this.arrowValue; e++) {
                var b = f.points[e];
                var d = e - this.crossValue;
                if (d < 0 || b.valueIsNull) {
                    continue
                }
                var s = b.valueByUnit + "";
                if (b instanceof FR.Chart.DataPoint4Stock) {
                    s = b.values[4] + ""
                }
                if (this.format) {
                    s = FR.contentFormat(s, this.format)
                }
                var q = this.beginX + d * this.unitLength;
                var p = a.y + (this.seriesRowHeight + this.PADDING_GAP * 2) * g + c;
                var h = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(s, l);
                if (h.width <= this.unitLength) {
                    FR.Chart.TextUtils.drawLabelWithNoRotation(t, s, l, new FR.Chart.Bounds(q + (this.unitLength - h.width) / 2, p + this.PADDING_GAP, h.width, h.height))
                } else {
                    this.tooltipLabelList.push(s);
                    var n = new FR.Chart.Bounds(q, p, this.unitLength, this.seriesRowHeight + this.PADDING_GAP * 2);
                    this.tooltipLabelBoundsList.push(n);
                    var r = this._getEllipsisDim();
                    var o = q + (this.unitLength - r.width) / 2;
                    var m = p + this.PADDING_GAP;
                    this._drawEllipsis(t, o, m)
                }
            }
        }
    }, _getEllipsisDim: function () {
        if (!this.ellipsisDim) {
            this.ellipsisDim = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(FR.Chart.Constants.ESP, this.getTextAttr())
        }
        return this.ellipsisDim
    }, _drawEllipsis: function (b, a, d) {
        var c = this._getEllipsisDim();
        FR.Chart.TextUtils.drawLabelWithNoRotation(b, FR.Chart.Constants.ESP, this.getTextAttr(), new FR.Chart.Bounds(a, d, c.width, c.height))
    }, _newLine: function (c, a, f, d, e) {
        var b = new FR.Chart.Line2D(new FR.Chart.Point2D(a, f), new FR.Chart.Point2D(d, e));
        FR.Chart.GraphHelper.dealLine4JSDraw(b);
        FR.Chart.GraphHelper.draw(c, b, FR.Chart.Constants.LINE_THIN)
    }, draw: function (b) {
        if (this.seriesList.length < 1) {
            return
        }
        b.strokeStyle = "black";
        var a = this.getBounds();
        var f = this.seriesRowHeight * this.cateRowCout + this.PADDING_GAP * 2;
        var e = a.x;
        var d = a.y + f;
        this._newLine(b, e, d, e, a.y + a.height);
        this._newLine(b, e, a.y + a.height, e + a.width, a.y + a.height);
        this._newLine(b, a.x + a.width, a.y, a.x + a.width, a.y + a.height);
        this._newLine(b, this.beginX, a.y, a.x + a.width, a.y);
        for (var c = this.beginX;
             c < a.x + a.width; c += this.unitLength) {
            this._newLine(b, c, a.y, c, a.y + a.height)
        }
        for (var c = 0; c < this.seriesList.length; c++) {
            var g = a.y + f + (this.seriesRowHeight + this.PADDING_GAP * 2) * c;
            this._newLine(b, a.x, g, a.x + a.width, g)
        }
        this._drawSeries(b, a);
        this._drawCategory(b, a);
        this._drawValues(b, a)
    }
});

function ChartHandler(a, G, L) {
    var s = a[0];
    var f = this;
    this._chartGlyph = G;
    this._chartGlyph.handler = this;
    this._backgroundGlyph = L;
    this.getTooltipDiv = function () {
        return u
    };
    var u = null;
    var b = null;
    var C = null;
    var t = null;
    var d = false;
    var r = false;
    var D = null;
    var m = false;
    var x = null;
    var J = false;
    var j = false;
    var B = false;
    var q = 'url("' + FR.servletURL + '?op=resource&resource=/com/fr/web/cursor/cursor_drag_hand.cur"),auto';
    var H = 'url("' + FR.servletURL + '?op=resource&resource=/com/fr/web/cursor/cursor_hand.cur"),auto';

    function I() {
        if (s.addEventListener) {
            s.addEventListener("click", M);
            s.addEventListener("mousemove", h);
            s.addEventListener("mousedown", p);
            s.addEventListener("mouseup", c);
            s.addEventListener("mouseleave", k);
            s.addEventListener("DOMMouseScroll", y)
        } else {
            s.attachEvent("onclick", M);
            s.attachEvent("onmousemove", h);
            s.attachEvent("onmouseleave", k);
            s.attachEvent("onmousedown", p);
            s.attachEvent("onmouseup", c);
            s.attachEvent("onmousewheel", y)
        }
        s.onmousewheel = y;
        u = document.createElement("div");
        u.onselectstart = function () {
            return false
        };
        s.appendChild(u)
    }

    function M(O) {
        j = false;
        u.style.display = "none";
        clearTimeout(b);
        clearTimeout(C);
        if (f._backgroundGlyph) {
            var N = v(O);
            f._backgroundGlyph.doOnClick(N)
        }
        f.needRefresh = false;
        f.needAnimateRefresh = true;
        f.needRefreshLabel = false;
        f.hyperlink = null;
        f.toNext = false;
        f.returnBack = false;
        if (!t) {
            return
        }
        if (t && t.onClick && !d) {
            var N = v(O);
            t.onClick(N, f);
            if (t.dataPoint4Map) {
                f.hyperlink = t.dataPoint4Map.hyperlink;
                f.toNext = true
            }
        }
        o(O);
        if (f.toNext) {
            e(t)
        } else {
            if (f.returnBack) {
                i()
            }
        }
        if (f.needRefresh) {
            if (f.needRefreshLabel && f._chartGlyph.plotGlyph) {
                f._chartGlyph.plotGlyph.refreshDataPointLabel()
            }
            if (f.needAnimateRefresh) {
                n()
            } else {
                E()
            }
        }
    }

    function e(N) {
        N = FR.pick(N.dataPoint4Map, N);
        f._chartGlyph.layerToDataPointNext(N, f);
        if (!FR.Browser.isIE()) {
            w()
        }
    }

    function i() {
        f._chartGlyph.returnBackToLayer();
        w()
    }

    function o(N) {
        if (f.hyperlink) {
            FR.doHyperlink(N, (new Function("return " + f.hyperlink))(), true)
        }
    }

    function h(S) {
        if (S.preventDefault) {
            S.preventDefault()
        }
        j = true;
        var N = v(S);
        if (f._backgroundGlyph) {
            var Q = f._backgroundGlyph.doOnMove(N);
            if (Q) {
                clearTimeout(b);
                clearTimeout(C);
                var O = f._chartGlyph.getOnMoveCtx();
                O._tooltipDiv = u;
                FR.Chart.Tooltip.dataPointTip(O, Q, {x: N.x, y: N.y + 30})
            } else {
                g()
            }
        }
        var P = FR.Browser.isIE8Before();
        f._chartGlyph.clearOnMoveCtx();
        if (f._mouseStyle == "hand") {
            s.style.cursor = H
        } else {
            if (f._mouseStyle == "drag") {
                s.style.cursor = q
            } else {
                if (f._mouseStyle == "arrow") {
                    s.style.cursor = "e-resize"
                } else {
                    if (x && x.isScroll) {
                        s.style.cursor = "move"
                    } else {
                        if (m && t && t.clickable && !d) {
                            s.style.cursor = "pointer"
                        } else {
                            s.style.cursor = "default"
                        }
                    }
                }
            }
        }
        S._mouseStyle = f._mouseStyle;
        var O = f._chartGlyph.getOnMoveCtx();
        var R = f._chartGlyph.plotGlyph;
        if (x && J) {
            if (x.jsType) {
                if (x.jsType == "DataSeries") {
                    R.onSeriesDrag(D, N, O, x)
                }
            } else {
                if (x.onDrag) {
                    x.onDrag(D, N, O, S, P);
                    if (!!S.zoomRefresh) {
                        E()
                    }
                }
            }
        } else {
            A(N);
            O._tooltipDiv = u;
            if (t) {
                clearTimeout(b);
                clearTimeout(C);
                if (t.doOnMove) {
                    if (FR.equals(t.jsType, "controlBar")) {
                        u.style.display = "none"
                    }
                    t.doOnMove(O, N, R, f._chartGlyph.getMapOnMoveCtx())
                }
            } else {
                g()
            }
            f._chartGlyph.doOnMove(N)
        }
        K(N)
    }

    function g() {
        clearTimeout(b);
        clearTimeout(C);
        b = setTimeout(function () {
            u.style.opacity = 0
        }, 400);
        C = setTimeout(function () {
            u.style.display = "none"
        }, 800)
    }

    function K(P) {
        if (!r) {
            return
        }
        if (f._chartGlyph == undefined || f._chartGlyph.plotGlyph == undefined) {
            return
        }
        var O = f._chartGlyph.plotGlyph;
        if (O.isSupportZoom() && O.bounds.containsPoint(D.x, D.y)) {
            var N = O.setCurrentOffset(P.x - D.x, P.y - D.y);
            if (N) {
                f._chartGlyph.clearAll();
                f._chartGlyph.clearOnMoveCtx();
                f._chartGlyph.draw(FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL);
                B = true
            }
        }
    }

    function F() {
        if (B) {
            B = false;
            if (f._chartGlyph == undefined || f._chartGlyph.plotGlyph == undefined) {
                return
            }
            var N = f._chartGlyph.plotGlyph;
            if (N.isSupportZoom()) {
                N.setTotalOffset();
                t = null
            }
        }
    }

    function k(N) {
        N = N || window.event;
        if (J && x) {
            if (x.jsType && x.jsType == "DataSeries") {
                f._chartGlyph.plotGlyph.onDragMouseOut(x);
                f._chartGlyph.plotGlyph.refreshDataPointLabel();
                f._chartGlyph.refreshLegendLabel();
                f._chartGlyph.clearOnMoveCtx();
                n()
            }
        } else {
            f._chartGlyph.clearOnMoveCtx()
        }
        g();
        s.style.cursor = "default";
        r = false;
        J = false;
        j = false;
        x = null;
        F()
    }

    function y(P) {
        j = false;
        P = P || window.event;
        if (!f._chartGlyph || !f._chartGlyph.plotGlyph) {
            return
        }
        var N = v(P);
        var Q = f._chartGlyph.plotGlyph;
        if (Q.isSupportZoom() && Q.bounds.containsPoint(N.x, N.y)) {
            var O = true;
            if (P.wheelDelta) {
                if (P.wheelDelta < 0) {
                    O = Q.setZoom(0.1)
                } else {
                    O = Q.setZoom(-0.1)
                }
            } else {
                if (P.detail) {
                    if (P.detail < 0) {
                        O = Q.setZoom(0.1)
                    } else {
                        O = Q.setZoom(-0.1)
                    }
                }
            }
            if (O && !FR.Browser.isIE8Before()) {
                f._chartGlyph.clearAll();
                f._chartGlyph.clearOnMoveCtx();
                f._chartGlyph.draw(FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL);
                P.returnValue = false
            }
        } else {
            P.returnValue = true
        }
    }

    function A(N) {
        f._hasfound = false;
        f._lastHover = null;
        f._isPlotAreaHover = false;
        f._draggingTarget = null;
        f._isMouseDown = r;
        f._isMouseMoving = j;
        f._mouseStyle = "";
        f.needRefresh = false;
        f._chartGlyph.findOnMoveGlyph(N, f);
        t = f._lastHover;
        m = f._hasfound;
        d = f._isPlotAreaHover;
        if (FR.Chart.GraphHelper.isDrawingEnd) {
            x = f._draggingTarget;
            if (f.needRefresh) {
                E()
            }
        }
    }

    function p(N) {
        if (N.preventDefault) {
            N.preventDefault()
        }
        D = v(N);
        r = true;
        j = false;
        A(D);
        l(D)
    }

    function c(O) {
        s.style.cursor = "default";
        z(O);
        j = false;
        r = false;
        f._chartGlyph.clearOnMoveCtx();
        F();
        var N = v(O);
        A(N)
    }

    function l(N) {
        if (r && t && x) {
            J = true;
            if (x.makeSureDragFocus) {
                x.makeSureDragFocus(N)
            }
            if (x && x.jsType) {
                if (x.jsType == "DataSeries") {
                    f._chartGlyph.reDrawPlotGlyphNoAnimate();
                    f._chartGlyph.plotGlyph.onDragStart(f._chartGlyph.getOnMoveCtx(), x)
                }
            } else {
                E()
            }
        }
    }

    function z(N) {
        var O = v(N);
        if (D && (Math.abs(O.x - D.x) > 1 || Math.abs(O.y - D.y) > 1)) {
            if (x && x.onDragEnd) {
                x.onDragEnd(D, O);
                E();
                t = null
            } else {
                if (x && x.jsType && x.jsType == "DataSeries") {
                    f.needRefresh = false;
                    f._chartGlyph.plotGlyph.onSeriesDragEnd(x, D, O, f);
                    f._chartGlyph.refreshLegendLabel();
                    if (f.needRefresh) {
                        w()
                    } else {
                        E()
                    }
                    t = null
                }
            }
        } else {
            if (x && x.paintState == FR.Chart.ChartPaintConstants.STATE_TRANSPARENT) {
                x.paintState = FR.Chart.ChartPaintConstants.STATE_ENABLE;
                E()
            }
        }
        J = false;
        x = null
    }

    function w() {
        if (f.needRefresh) {
            n()
        }
    }

    function E() {
        f._chartGlyph.clearAll();
        f._chartGlyph.plotGlyph.refreshAxisGlyph();
        f._chartGlyph.draw(FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL)
    }

    function n() {
        f._chartGlyph.clearAll();
        f._chartGlyph.plotGlyph.refreshAxisGlyph();
        f._chartGlyph.draw(FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE)
    }

    function v(P) {
        var O = P;
        if (P.targetTouches && P.targetTouches.length > 0) {
            O = P.targetTouches[0]
        } else {
            if (P && P.touches) {
                if (P.touches.length > 0) {
                    O = P.touches[0]
                } else {
                    if (P.changedTouches && P.changedTouches.length > 0) {
                        O = P.changedTouches[0]
                    }
                }
            }
        }
        var U = {x: 0, y: 0};
        var T = 1;
        U.x += O.clientX;
        U.y += O.clientY;
        var S = a.offset();
        U.x -= S.left;
        U.y -= S.top;
        var N = N;
        var Q = undefined;
        if (!FR.BIDezi) {
            if (N) {
                Q = N
            } else {
                if (O.view && O.view.contentPane) {
                    Q = O.view.contentPane
                } else {
                    if (FR.Browser.isIE()) {
                        try {
                            Q = window.parent.contentPane
                        } catch (R) {
                            Q = null
                        }
                    }
                }
            }
            if (Q && Q.zoom) {
                T = Q.zoom
            }
        }
        U.x = U.x / T;
        U.y = U.y / T;
        return U
    }

    I();
    return f
}

$.extend(ChartHandler, {
    POINTER: "pointer",
    AUTO: "auto",
    DRAG: 'url("' + FR.servletURL + '?op=resource&resource=/com/fr/web/cursor/cursor_drag_hand.cur"),auto',
    HAND: 'url("' + FR.servletURL + '?op=resource&resource=/com/fr/web/cursor/cursor_hand.cur"),auto'
});
$.extend(ChartHandler.prototype, {
    reStart: function (a) {
        this._chartGlyph = a;
        this._chartGlyph.handler = this
    }, doRefresh: function () {
        this._chartGlyph.clearAll();
        this._chartGlyph.plotGlyph.refreshAxisGlyph();
        this._chartGlyph.draw(FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE)
    }
});
FR.Chart.TooltipString = FR.extend(FR.Chart.ChartJsInit, {
    initConstants: function (a) {
        a = a || {};
        this.value = a.value || "";
        this.font = new FR.Chart.FRFont(a.font);
        this.height = 0;
        this.width = 0;
        this.newLine = false;
        this.rightAlign = false
    }, formatValue: function (a) {
        var b = /^-?(\d*\.\d*)$/;
        if (b.exec(a)) {
            this.value = a;
            this.font.fontName = "Century Gothic";
            return
        }
        b = /^-?(\d*\.\d*)%$/;
        if (b.exec(a)) {
            this.value = parseFloat(a) + "%";
            this.font.fontName = "Century Gothic";
            return
        }
        b = /^[￥$]-?(\d*\.\d*)$/;
        if (b.exec(a)) {
            this.value = a.substring(0, 1) + parseFloat(a.substring(1, a.length));
            this.font.fontName = "Century Gothic";
            return
        }
        if (!isNaN(a)) {
            this.value = parseFloat(a);
            this.font.fontName = "Century Gothic";
            return
        } else {
            this.value = a;
            this.font.fontName = "Microsoft YaHei"
        }
    }
});
FR.Chart.Tooltip = {
    LEFTGAP: 6,
    TOPGAP: 6,
    ROUNDGAP: 6,
    STEP: 20,
    DEFAULT_CSS_TEXT: "position:absolute;border-style:solid;white-space:nowrap;z-Index:10;opacity:1;font-family:Microsoft YaHei;font-size:12px;line-height:17px;padding:6px;border-width:2px;",
    drawAxisTooltip: function (b, c) {
        if (c.tooltips) {
            var e = FR.Chart.GraphHelper.calculateTooltipDimension(c.tooltips);
            var a = 0, f = 0;
            if (c.pos == FR.Chart.Constants.LEFT) {
                a = c.point.x + e.width + this.LEFTGAP * 2;
                f = c.point.y + e.height + this.TOPGAP * 2
            } else {
                if (c.pos == FR.Chart.Constants.RIGHT) {
                    a = c.point.x;
                    f = c.point.y + e.height + this.TOPGAP * 2
                } else {
                    if (c.pos == FR.Chart.Constants.BOTTOM) {
                        a = c.point.x + e.width + this.LEFTGAP * 2;
                        f = c.point.y
                    } else {
                        if (c.pos == FR.Chart.Constants.TOP) {
                            a = c.point.x + e.width + this.LEFTGAP * 2;
                            f = c.point.y + e.height + this.TOPGAP * 2
                        }
                    }
                }
            }
            a = a - e.width - this.LEFTGAP * 2;
            f = f - e.height - this.TOPGAP * 2;
            var d = new FR.Chart.Bounds(a, f, e.width + this.LEFTGAP * 2, e.height + this.TOPGAP * 2);
            FR.Chart.Tooltip._drawWithCanvas(b, c.tooltips, d, "rgb(230,230,230)", 1)
        }
    },
    dataPointTip: function (a, c, e, b) {
        if (c) {
            var d = this._calculateTooltipTextDimension(c);
            e = new FR.Chart.Point2D((e.x - d.width) < 0 ? 0 : e.x - d.width, (e.y - d.height) < 0 ? 0 : e.y - d.height);
            FR.Chart.Tooltip._drawWithDiv(a, c, e, "white", b)
        }
    },
    dataPointTip4Point: function (a, f, h, d, g, c, b) {
        if (a && f) {
            var e = FR.Chart.Tooltip._dealTooltipPos(f, h, d, c);
            g = FR.Chart.Tooltip._getBorderBackground(d, g);
            FR.Chart.Tooltip._drawWithDiv(a, f, e, b, g)
        }
    },
    dataPointTip4Series: function (h, i, e, d, f, c, g, b) {
        if (i && h) {
            var a = FR.Chart.Tooltip._dealTooltipPos(i, e, d, c);
            f = FR.Chart.Tooltip._getBorderBackground(d, f);
            FR.Chart.Tooltip._draw4Series(h, i, a, g, f, b)
        }
    },
    _getBorderBackground: function (b, a) {
        if (b && b.marker) {
            return b.marker.background
        } else {
            if (a) {
                return a
            }
        }
        return null
    },
    _calculateTooltipTextDimension: function (e) {
        var b = document.getElementsByTagName("body")[0];
        var d = document.createElement("div");
        d.innerHTML = e;
        d.style.cssText = this.DEFAULT_CSS_TEXT + "visibility:hidden;";
        b.appendChild(d);
        var c = d.offsetWidth;
        var a = d.offsetHeight;
        b.removeChild(d);
        return new FR.Chart.Dimension2D(c, a)
    },
    _dealTooltipPos: function (j, i, e, b) {
        var c = this._calculateTooltipTextDimension(j);
        var a = new FR.Chart.Bounds(i.x, i.y, c.width, c.height);
        var h = b.bounds;
        if (!e || !h) {
            return
        }
        if (e.shape || (e.jsType && FR.equals(e.jsType, "bubble"))) {
            a = e.getTooltipBounds4Shape(a, h)
        } else {
            var g, f;
            var d;
            if (e.bounds) {
                d = e.bounds
            } else {
                if (e.marker) {
                    d = new FR.Chart.Bounds(e.marker.x, e.marker.y, e.marker.size, e.marker.size)
                }
            }
            g = d.x + d.width;
            if (g + a.width > h.x + h.width) {
                g = d.x - a.width
            }
            if (g < h.x) {
                g = Math.max(h.x, h.x + h.width - a.width)
            }
            f = d.y + d.height;
            if (f + a.height > h.y + h.height) {
                f = d.y - a.height
            }
            a = new FR.Chart.Bounds(g, f, a.width, a.height)
        }
        return new FR.Chart.Point2D(a.x, Math.max(a.y, h.y))
    },
    doTrendLineTooltip: function (j, e, h) {
        if (e && e.length > 0) {
            if (!j) {
                return
            }
            j.save();
            j.strokeStyle = "rgb(128,128,128)";
            var b = 0;
            for (var c = 0; c < e.length; c++) {
                var d = FR.Chart.TextUtils.calculateTextDimensionWithNoRotation(e[c].text);
                e[c].dim = d;
                b += d.width + this.LEFTGAP * 2
            }
            var f = h.width / 2 - b / 2;
            for (var c = 0; c < e.length; c++) {
                var g = e[c].dim;
                var a = new FR.Chart.Bounds(f, 0, g.width + this.LEFTGAP * 2, g.height + this.TOPGAP * 2);
                FR.Chart.Tooltip._drawWithCanvas(j, e[c].text, a, "white", 1, e[c].lineColor);
                f += a.width
            }
            j.restore()
        }
    },
    _drawWithDiv: function (j, e, f, i, g) {
        if (j._tooltipDiv) {
            var h = j._tooltipDiv;
            h.innerHTML = e;
            h.style.cssText = this._getCssText(f, i, g);
            if (j._hyperlink) {
                var c = this._calculateTooltipTextDimension(e);
                var b = FR.servletURL + "?op=resource&resource=/com/fr/chart/base/mobilelink.png";
                var d = c.width - 25;
                var a = "background:url(" + b + ") no-repeat " + d + "px 5px";
                if (i == "black") {
                    a += " #000000;" + "filter:alpha(opacity=50);" + "background-color:rgba(0,0,0,0.5);"
                } else {
                    a += " #FFFFFF;" + "filter:alpha(opacity=75);" + "background-color:rgba(255,255,255,0.75);"
                }
                h.style.cssText += a
            }
        }
    },
    _drawWithCanvas: function (c, b, e, d, a, f) {
        FR.Chart.Tooltip._drawBack(c, e, d, a, f);
        FR.Chart.PaintUtils.paintTooltip(c, b, e.x + this.LEFTGAP, e.y, d)
    },
    _getCssText: function (d, g, e) {
        var i = "rgb(85,85,85)";
        if (e && e.color) {
            i = e.color
        }
        var b = "border-color:" + i + ";";
        if (i.startWith("rgba")) {
            var h = FR.Chart.Color.rgb2Hex(i);
            if (h) {
                b = "border-color:" + h.hex + ";" + "filter:alpha(opacity=" + h.alpha + ");" + b
            }
        }
        var a;
        var c = "black";
        if (g == "black") {
            a = "background-color:#000000;" + "filter:alpha(opacity=50);" + "background-color:rgba(0,0,0,0.5);";
            c = "white"
        } else {
            a = "background-color:#FFFFFF;" + "filter:alpha(opacity=75);" + "background-color:rgba(255,255,255,0.75);"
        }
        var f = "left " + 0.4 + "s," + "top " + 0.4 + "s," + "opacity " + 0.4 + "s;";
        return this.DEFAULT_CSS_TEXT + a + b + "left:" + d.x + "px;" + "top:" + d.y + "px;" + "border-radius:" + 5 + "px;" + "-moz-border-radius:" + 5 + "px;" + "-webkit-border-radius:" + 5 + "px;" + "-o-border-radius:" + 5 + "px;" + "transition:" + f + "-moz-transition:" + f + "-webkit-transition:" + f + "-o-transition:" + f + "color:" + c + ";" + "display:block;" + "box-shadow:2px 2px 2px rgba(0,0,0,0.25);"
    },
    _draw4Series: function (c, b, e, d, g, a) {
        if (c._tooltipDiv) {
            var f = c._tooltipDiv;
            f.style.cssText = this._getCssText(e, d, g);
            f.innerHTML = b
        }
    },
    _drawBack: function (c, e, d, a, f) {
        var b = new FR.Chart.RoundBounds(e.x, e.y, e.width, e.height, 5, 5);
        if (!c) {
            return
        }
        c.save();
        c.fillStyle = d;
        c.globalAlpha = 0.75;
        if (d == "black") {
            c.globalAlpha = 0.5
        }
        b.paint(c);
        c.globalAlpha = 1;
        c.lineWidth = a;
        if (f && f.color) {
            f.draw(c, b);
            c.strokeStyle = f.color
        } else {
            c.strokeStyle = "rgb(85,85,85)";
            b.draw(c)
        }
        b.draw(c);
        c.restore()
    }
};
FR.SimpleChart = FR.extend(FR.Widget, {
    type: "simplechart", _init: function () {
        FR.SimpleChart.superclass._init.apply(this, arguments);
        var d = this.options;
        this.curChart = null;
        this.chartArray = [];
        this.width = d.chartWidth || 0;
        this.height = d.chartHeight || 0;
        if (this.width <= 0 || this.height <= 0) {
            return
        }
        this.isNeedRefreshButton = !!d.isNeedRefreshButton;
        var a = d.selectedIndex == undefined ? 0 : d.selectedIndex;
        this.selectedIndex = a;
        if (this.element) {
            this.element.css("position", "relative").css("width", this.width + "px").css("height", this.height + "px")
        }
        this.isNeedBackgroundGlyph = false;
        if ((d && d.items && d.items.length > 1) || this.isNeedRefreshButton) {
            this.isNeedBackgroundGlyph = true
        }
        FR.Chart.WebUtils._installChart(this, this.options.chartpainter_id_web_change_selected);
        this.changeChartImage(a);
        var b = window.onunload;
        var c = this;
        if (typeof window.onunload != "function") {
            window.onunload = function () {
                c.simpleUnbind(c)
            }
        } else {
            window.onunload = function () {
                b();
                c.simpleUnbind(c)
            }
        }
    }, simpleUnbind: function () {
        this.width = null;
        this.height = null;
        this.curChart = null;
        for (var a = 0;
             a < this.chartArray.length; a++) {
            this.chartArray[a] = null
        }
        this.chartArray = null;
        FR.Chart.WebUtils.chartDelete();
        if ($.browser.msie) {
            if (CollectGarbage) {
                CollectGarbage()
            }
        }
    }, resize: function (e, b) {
        this.width = e || this.width;
        this.height = b || this.height;
        var a = this.selectedIndex;
        if (this.curChart.chartType == "div") {
            if (this.curChart.chartWidth != this.width || this.curChart.chartHeight != this.height) {
                var d = FR.Chart.WebUtils._getChartIDAndIndex(this.options.items[a].simpleChartInShowID);
                var f = FR.ChartManager[d[0]];
                this.curChart.css("width", this.width).css("height", this.height);
                f[a].resize(this.width, this.height);
                this.curChart.chartWidth = this.width;
                this.curChart.chartHeight = this.height
            }
            var c = FR.Chart.WebUtils.getChart(this.options.items[a].simpleChartInShowID);
            if (c) {
                c.refresh()
            }
        } else {
            if (this.curChart.chartWidth != this.width || this.curChart.chartHeight != this.height) {
                this.curChart.css("width", this.width).css("height", this.height);
                this.curChart.chartWidth = this.width;
                this.curChart.chartHeight = this.height
            }
        }
    }, getChartItems: function () {
        return this.options.items
    }, changeChartImage: function (o) {
        if (o < 0 || o >= this.options.items.length) {
            return
        }
        if (this.selectedIndex != o) {
            this.selectedIndex = o;
            var j = FR.SessionMgr.getSessionID();
            if (j) {
                FR.ajax({
                    type: "POST",
                    url: FR.servletURL,
                    data: {
                        op: "chart",
                        cmd: "change_selected",
                        selectedValue: o,
                        sessionID: j,
                        chartpainter_id_web_change_selected: this.options.chartpainter_id_web_change_selected
                    },
                    async: false,
                    complete: function (r) {
                    }
                })
            }
        }
        if (!this.chartArray[o]) {
            var e = this.options.items[o].url;
            var f = "Chart__" + this.options.items[o].simpleChartInShowID;
            var i = this.options.items[o].isJS;
            if (i) {
                var g = this.width;
                var p = this.height;
                var d = $("<div>");
                d.attr("id", f);
                d.appendTo(this.element);
                d.css("position", "relative").css("background-color", "transparent").css("width", g).css("height", p).css("left", 0).css("top", 0).css("onselectstart", false).css("userinteractionenabled", "no");
                this.element.append(d.html());
                var m = this.options.items[o].beforeInit;
                if (m) {
                    (new Function("return " + m))()(d[0])
                }
                var n = this;
                FR.ajax({
                    type: "GET",
                    dataType: "json",
                    url: FR.servletURL + e,
                    data: {__time: new Date().getTime()},
                    success: function (s) {
                        if (s.requiredJS) {
                            for (var r = 0;
                                 r < s.requiredJS.length; r++) {
                                FR.$defaultImport(s.requiredJS[r], "js")
                            }
                        }
                        if (s.wrapperName) {
                            if ($.browser.mozilla) {
                                setTimeout(function () {
                                    new window[s.wrapperName](s, d)
                                }, 200)
                            } else {
                                new window[s.wrapperName](s, d)
                            }
                        }
                    }
                });
                this.chartArray[o] = d;
                this.chartArray[o].chartType = "div";
                this.chartArray[o].chartWidth = g;
                this.chartArray[o].chartHeight = p
            } else {
                var h = $("<img src='" + e + "'/>").css("width", this.width).css("height", this.height).css("border-width", 0).attr("idx", o).css("position", "relative").css("top", 0).css("left", 0);
                if ($.browser.msie) {
                    var q = $("<div>");
                    this.chartArray[o] = h.appendTo(q)
                } else {
                    this.chartArray[o] = h.appendTo(this.element)
                }
                this.chartArray[o].chartType = "img";
                this.chartArray[o].chartWidth = this.width;
                this.chartArray[o].chartHeight = this.height;
                if (this.options.items[o].usemap && this.options.items[o].mapHtml) {
                    this.chartArray[o].attr("usemap", this.options.items[o].usemap);
                    if ($.browser.msie) {
                        q.append(this.options.items[o].mapHtml)
                    } else {
                        this.element.append(this.options.items[o].mapHtml)
                    }
                }
                if ($.browser.msie) {
                    this.element.append(q.html());
                    this.chartArray[o] = $("img[idx='" + o + "']", this.element)
                }
                if (this.isNeedBackgroundGlyph) {
                    var c = new FR.Chart.BackgroundGlyph(this.element, this.getChartItems(), this.selectedIndex, this.isNeedRefreshButton, {
                        width: this.width,
                        height: this.height
                    });
                    c.init4MouseHandler();
                    c.chartWidget = this
                }
            }
        }
        this.chartArray[o].idxNumber = o;
        if (this.curChart) {
            if (this.curChart.idxNumber == o) {
                if (this.curChart.chartType == "div") {
                    if (this.curChart.chartWidth != this.width || this.curChart.chartHeight != this.height) {
                        var b = FR.Chart.WebUtils._getChartIDAndIndex(this.options.items[o].simpleChartInShowID);
                        var a = FR.ChartManager[b[0]];
                        a[o].resize(this.width, this.height);
                        this.curChart.chartWidth = this.width;
                        this.curChart.chartHeight = this.height
                    }
                    var k = FR.Chart.WebUtils.getChart(this.options.items[o].simpleChartInShowID);
                    if (k) {
                        k.refresh()
                    }
                }
                return
            } else {
                if (this.curChart.chartWidth != this.width || this.curChart.chartHeight != this.height) {
                    this.curChart.css("width", this.width).css("height", this.height);
                    this.curChart.chartWidth = this.width;
                    this.curChart.chartHeight = this.height
                }
            }
        }
        var l = this.chartArray[o];
        if (this.curChart) {
            if (this.curChart.chartType == "div") {
                this.curChart.css("display", "none");
                if (l.chartType == "div") {
                    l.css("width", this.width + "px").css("height", this.height + "px").css("display", "");
                    this.curChart = l;
                    if (this.curChart.isNotFirstShow) {
                        if (this.curChart.chartWidth != this.width || this.curChart.chartHeight != this.height) {
                            var b = FR.Chart.WebUtils._getChartIDAndIndex(this.options.items[o].simpleChartInShowID);
                            var a = FR.ChartManager[b[0]];
                            a[o].resize(this.width, this.height);
                            this.curChart.chartWidth = this.width;
                            this.curChart.chartHeight = this.height
                        }
                        var k = FR.Chart.WebUtils.getChart(this.options.items[o].simpleChartInShowID);
                        if (k) {
                            k.refresh()
                        }
                    } else {
                        this.curChart.isNotFirstShow = true
                    }
                } else {
                    l.css("width", this.width).css("height", this.height).css("display", "").css({opacity: 0}).animate({opacity: 1}, 150, function () {
                        this.curChart = l
                    }.createDelegate(this))
                }
            } else {
                this.curChart.css("display", "none");
                if (l.chartType == "div") {
                    l.css("width", this.width + "px").css("height", this.height + "px").css("display", "");
                    this.curChart = l;
                    if (this.curChart.isNotFirstShow) {
                        if (this.curChart.chartWidth != this.width || this.curChart.chartHeight != this.height) {
                            var b = FR.Chart.WebUtils._getChartIDAndIndex(this.options.items[o].simpleChartInShowID);
                            var a = FR.ChartManager[b[0]];
                            a[o].resize(this.width, this.height);
                            this.curChart.chartWidth = this.width;
                            this.curChart.chartHeight = this.height
                        }
                        var k = FR.Chart.WebUtils.getChart(this.options.items[o].simpleChartInShowID);
                        if (k) {
                            k.refresh()
                        }
                    } else {
                        this.curChart.isNotFirstShow = true
                    }
                } else {
                    l.css("width", this.width).css("height", this.height).css("display", "").css({opacity: 0}).animate({opacity: 1}, 150, function () {
                        this.curChart = l
                    }.createDelegate(this))
                }
            }
        } else {
            if (l.chartType == "div") {
                l.isNotFirstShow = true;
                this.curChart = l
            } else {
                l.css({opacity: 1});
                this.curChart = l
            }
        }
    }
});
$.shortcut("simplechart", FR.SimpleChart);
(function (a) {
    FR.ChartWidget = FR.extend(FR.Widget, {
        _init: function () {
            FR.ChartWidget.superclass._init.apply(this, arguments);
            this.loadData();
            this._init4Style()
        }, _init4Style: function () {
            this._initBackGround();
            var b = this.options.border;
            if (b) {
                this.element.css("border-style", b.type);
                this.element.css("border-color", b.color);
                this.element.css("border-width", b.width);
                this.element.css("border-radius", b.borderRadius)
            }
        }, _initBackGround: function () {
            if (!this.options.widgetBackground) {
                return
            }
            var b = this.options.widgetOpacity;
            if (!b) {
                FR.setBackground(this.element, this.options.widgetBackground, this.element.height());
                return
            }
            this.$background = a("<div class='widgetBackground'></div>");
            this.$background.css("filter", "alpha(opacity=" + b * 100 + ")");
            this.$background.css("opacity", b);
            FR.setBackground(this.$background, this.options.widgetBackground, this.element.height());
            this.$background.css("position", "absolute");
            this.$background.prependTo(this.element)
        }, loadData: function () {
            var b = this.options;
            if (b.width && b.height) {
                this.element.width(b.width);
                this.element.height(b.height);
                this.reload()
            }
        }, setSource: function (b) {
            this.options.dependPara = b;
            this.reload()
        }, getDependence: function () {
            if (this.options.dependPara) {
                var c = this.options.dependPara;
                c.width = this.options.width;
                c.height = this.options.height;
                delete this.options.dependPara;
                return c
            }
            var c = {};
            if (FR.isArray(this.options.valueDependence)) {
                for (var b = 0; b < this.options.valueDependence.length; b++) {
                    var d = this.options.valueDependence[b];
                    var e = this.options.form.resolveVariable(d);
                    if (e != "fr_primitive" && e != null) {
                        c[d.toUpperCase()] = e
                    }
                }
            }
            return {para: c, width: this.options.width, height: this.options.height}
        }, reload: function () {
            if (!this.options.width || !this.options.height) {
                return
            }
            var c = new Date();
            this.lastResizeTime = c;
            var b = this;
            setTimeout(function () {
                if (c == b.lastResizeTime) {
                    delete b.lastResizeTime;
                    var h = b.getDependence();
                    if (FR.equals(b.oldDependence, h)) {
                        return
                    }
                    b.oldDependence = h;
                    var d = {};
                    for (var e in h.para) {
                        var g = h.para[e];
                        if (e.startWith("$")) {
                            e = e.substring(1)
                        }
                        g = FR.encodePrecentPlus(g);
                        if (g == undefined) {
                            g = null
                        }
                        d[e] = g
                    }
                    var f = FR.buildServletUrl({
                        op: "fr_form",
                        cmd: "form_getsource",
                        sessionID: b.options.form.sessionID,
                        __chartsourcename__: b.options.widgetName,
                        __chartsize__: {width: b.options.width, height: b.options.height}
                    });
                    FR.ajax({
                        url: f, type: "POST", data: {__parameters__: FR.jsonEncode(d)}, beforeSend: function () {
                            FR.HtmlLoader.loadingEffect({el: a(".content-container"), show: true})
                        }, complete: function (j, i) {
                            if (!j.responseText) {
                                return
                            }
                            if (i == "success") {
                                b.chart = FR.jsonDecode(j.responseText);
                                if (b.chart.length === 0) {
                                    b.element.html(j.responseText);
                                    return
                                }
                                b.addChartComp();
                                FR.HtmlLoader.loadingEffect({el: a(".content-container")})
                            }
                        }
                    })
                }
            }, 100)
        }, addChartComp: function () {
            if (!this.chart) {
                return
            }
            this.chartWidget = FR.createWidget(this.chart);
            this.element.empty();
            if (this.$background) {
                this.$background.css({width: this.element.width(), height: this.element.height()});
                this.$background.appendTo(this.element)
            }
            this.chartWidget.element.appendTo(this.element)
        }, reset: function () {
            this.reload()
        }, doResize: function (c) {
            if (this.options.width == c.width && this.options.height == c.height) {
                return
            }
            var d = new Date();
            this.lastResizeTime = d;
            var b = this;
            setTimeout(function () {
                if (d == b.lastResizeTime) {
                    delete b.lastResizeTime;
                    if (!(FR.Browser.isIE && FR.Browser.isIE8Before()) && b.options.border) {
                        b.element.parent().css("box-shadow", b.options.border.borderStyle)
                    }
                    if (c.width) {
                        b.options.width = c.width;
                        b.element.width(c.width)
                    }
                    if (c.height) {
                        b.options.height = c.height;
                        b.element.height(c.height)
                    }
                    if (b.chartWidget) {
                        b.chartWidget.resize(c.width, c.height)
                    } else {
                        b.reload()
                    }
                }
            }, 100)
        }
    });
    a.shortcut("chartwidget", FR.ChartWidget)
})(jQuery);
FineChart = function (a, b) {
    this.chartID = a.chartID || "test";
    this.canvasCount = a.canvasCount || 3;
    this.actionModel = a.actionModel || "0";
    this.width = a.width || b.width();
    this.height = a.height || b.height();
    this.sheetIndex = a.sheetIndex || 0;
    this.ecName = a.ecName || "";
    this.actionTime = a.actionTime || 1000;
    this.chartAttr = a.chartAttr;
    this.chartConfig = a;
    this.isVanCharts = FR.pick(a.isVanCharts, false);
    if (FR.Chart.ChartUtils.isIE6Before()) {
        this.actionModel = FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL
    }
    this.ctxs = null;
    this.canvass = null;
    this.autoRefreshTime = a.autoRefreshTime || 0;
    if (a.interaction && a.interaction.autoRefresh) {
        this.autoRefreshTime = a.interaction.autoRefresh
    }
    this.dependence = a.dependence || "";
    this.dom = b;
    b.fineChart = this;
    this._init(a, b)
};
$.extend(FineChart.prototype, {
    _init: function (a, c) {
        this._updateCanvas(c);
        var b = new FR.Chart.ChartGlyph(this.chartAttr);
        b.parentDiv = c[0];
        b.bounds = new FR.Chart.Bounds(0, 0, this.width, this.height);
        this.backgroundGlyph = this._createBackgroundGlyph();
        this.handler = new ChartHandler(c, b, this.backgroundGlyph);
        this.chartGlyph = b;
        FR.Chart.WebUtils._installChart(this, this.chartID)
    }, _updateCanvas: function (d) {
        this._createChartWithID(d);
        this.ctxs = [];
        this.canvass = [];
        for (var c = 0; c < this.canvasCount; c++) {
            var b = document.getElementById(this.chartID + "" + c);
            if (!b) {
                continue
            }
            var a = b.getContext("2d");
            FR.Chart.ChartUtils.retinaOptimization(b, a, this.width, this.height);
            this.ctxs[this.ctxs.length] = a;
            this.canvass[this.canvass.length] = b
        }
    }, _createBackgroundGlyph: function () {
        var b = FR.Chart.WebUtils.getChartWidget(this.chartID);
        if (b && b.isNeedBackgroundGlyph) {
            var c = b.getChartItems();
            var f = b.isNeedRefreshButton;
            var a = b.selectedIndex;
            var d = {width: this.width, height: this.height};
            var e = new FR.Chart.BackgroundGlyph(this.dom, c, a, f, d);
            e.chartWidget = b;
            return e
        }
    }, _createChartWithID: function (c) {
        var a = this.canvasCount;
        for (var b = 0; b < a; b++) {
            this._createCanvas(this.chartID, b, c, b == a - 1)
        }
    }, _createCanvas: function (c, b, e, d) {
        var a = $("<canvas>").attr("id", c + b).css("width", this.width + "px").css("height", this.height + "px").css("position", "absolute").css("left", 0).css("top", 0);
        if (d) {
            a.css("z-index", b)
        }
        a.appendTo(e);
        if (window.G_vmlCanvasManager) {
            window.G_vmlCanvasManager.initElement(a[0])
        }
    }, inits: function () {
        this.resize(this.width, this.height);
        this.chartGlyph.ctxs = this.ctxs;
        this._dealWithDependence();
        this.chartGlyph.draw(this.actionModel, this.actionTime);
        this._autoRefresh()
    }, resize: function (c, a) {
        if (c) {
            this.width = c
        }
        if (a) {
            this.height = a
        }
        if (this.dom) {
            this.dom.css("width", this.width + "px").css("height", this.height + "px")
        }
        if (this.ctxs && this.canvass && this.ctxs.length == this.canvass.length) {
            for (var b = 0, d = this.ctxs.length;
                 b < d; b++) {
                FR.Chart.ChartUtils.retinaOptimization(this.canvass[b], this.ctxs[b], this.width, this.height)
            }
        }
        if (this.chartGlyph) {
            this.chartGlyph.bounds = new FR.Chart.Bounds(0, 0, this.width, this.height);
            if (this.chartGlyph.legendGlyph) {
                this.chartGlyph.legendGlyph.resetLegendWhenResize()
            }
        }
        if (this.backgroundGlyph) {
            this.backgroundGlyph.resize(c, a)
        }
    }, _dealWithDependence: function () {
        if (!window.contentPane || !window.contentPane.curLGP) {
            return
        }
        var a = this.dependence;
        var b = window.contentPane.curLGP.form;
        if (FR.isArray(a) && b) {
            $.each(a, function (c, f) {
                var e = b.getWidgetByName(f);
                var d = FR.Events.STOPEDIT;
                if (e instanceof FR.ComboBoxEditor || e instanceof FR.CheckBoxEditor || e instanceof FR.DateTimeEditor) {
                    d = FR.Events.AFTEREDIT
                } else {
                    if (e instanceof FR.RadioButton || e instanceof FR.CheckBox || e instanceof FR.ListEditor) {
                        d = FR.Events.CLICK
                    } else {
                        if (e instanceof FR.RadioGroup || e instanceof FR.CheckBoxGroup) {
                            d = FR.Events.STATECHANGE
                        }
                    }
                }
                if (e != null) {
                    e.on(d, function () {
                        var g = {};
                        for (var j = 0; j < a.length; j++) {
                            var h = (a[j].indexOf("$") === 0) ? a[j].substr(1) : a[j];
                            g[h] = b.getWidgetByName(a[j]).getValue()
                        }
                        this.dealChartAjax(g)
                    })
                }
            })
        }
    }, _autoRefresh: function () {
        var a = this.autoRefreshTime || 0;
        if (a < 2) {
            return
        }
        var b = this;
        this.autoRefreshID = setInterval(function () {
            b._dealAuto()
        }, a * 1000)
    }, _chartRelated: function (e) {
        for (var c = 0; c < e.length; c++) {
            var f = FR.Chart.WebUtils._getChartIDAndIndex(e[c].id);
            var d = FR.ChartManager[f[0]];
            if (d && d[f[1]]) {
                var a = e[c].chartAttr;
                var b = e[c].actionModel;
                d[f[1]].changeData(a, b || 0)
            }
        }
    }, _dealAuto: function () {
        if (this.isVanCharts) {
            this._dealAuto4Plugin()
        } else {
            this._dealAuto4Report()
        }
    }, _dealAuto4Plugin: function () {
        if (this.chartGlyph && this.chartGlyph.dataDefinition) {
            var d = this.chartGlyph.dataDefinition;
            if (d.dataSource === "remote") {
                this.changeTableData()
            }
        } else {
            var c = this.width || 0;
            var a = this.height || 0;
            var b = this;
            if (FR.servletURL) {
                FR.ajax({
                    type: "GET",
                    url: FR.servletURL + "?op=chartrelate",
                    data: {
                        cmd: "chart_refresh",
                        sessionID: FR.SessionMgr.getSessionID(),
                        chartWidth: c,
                        chartHeight: a,
                        __time: new Date().getTime()
                    },
                    dataType: "json",
                    success: function (g) {
                        var j = g.relateChartList;
                        var l = FR.Chart.WebUtils._getChartIDAndIndex(b.chartID);
                        var h = FR.ChartManager[l[0]];
                        for (var f = 0; f < j.length; f++) {
                            var k = FR.Chart.WebUtils._getChartIDAndIndex(j[f].chartID);
                            if (h && h[k[1]]) {
                                var e = j[f].chartAttr;
                                h[l[1]].changeData(e, "0")
                            }
                        }
                    }
                })
            }
        }
    }, _dealAuto4Report: function () {
        var c = FR.cjkEncode(this.chartID);
        var f = this.width || 0;
        var b = this.height || 0;
        var e = this;
        var d = this.sheetIndex;
        var a = this.ecName;
        if (FR.servletURL) {
            FR.ajax({
                type: "GET",
                url: FR.servletURL + "?op=chartauto",
                data: {
                    cmd: "chart_auto_refresh",
                    sessionID: FR.SessionMgr.getSessionID(),
                    chartID: c,
                    chartWidth: f,
                    chartHeight: b,
                    sheetIndex: d,
                    ecName: a,
                    __time: new Date().getTime()
                },
                dataType: "json",
                success: function (g) {
                    e._chartRelated(g.relateChartList)
                }
            })
        }
    }, dealChartAjax: function (a) {
        var e = {
            "sessionID": FR.SessionMgr.getSessionID(),
            "chartID": FR.cjkEncode(this.chartID),
            "chartWidth": this.width || 0,
            "chartHeight": this.height || 0,
            "sheetIndex": this.sheetIndex,
            "ecName": this.ecName,
            "__time": new Date().getTime()
        };
        a = a || {};
        for (var b in a) {
            var d = a[b];
            if (b.startWith("$")) {
                b = b.substring(1)
            }
            d = FR.encodePrecentPlus(d);
            if (d == undefined) {
                d = null
            }
            e[b] = d
        }
        var c = this;
        FR.ajax({
            type: "POST",
            url: FR.servletURL + "?op=chartlink&cmd=refresh_relate_data",
            data: e,
            dataType: "json",
            success: function (f) {
                c._chartRelated(f.relateChartList)
            }
        })
    }, dataRefresh: function () {
        this._dealAuto4Report()
    }, getGis: function () {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            return this.chartGlyph.plotGlyph.map
        }
    }, setTitleVisible: function (a) {
        if (this.chartGlyph && this.chartGlyph.titleGlyph) {
            this.chartGlyph.titleGlyph.visible = FR.pick(a, false);
            this.refreshWithoutAnimation()
        }
    }, setTitleContent: function (a) {
        if (this.chartGlyph && this.chartGlyph.titleGlyph) {
            this.chartGlyph.titleGlyph.text = FR.pick(a, "");
            this.refreshWithoutAnimation()
        }
    }, getTitleContent: function () {
        if (this.chartGlyph && this.chartGlyph.titleGlyph) {
            return this.chartGlyph.titleGlyph.text
        }
        return ""
    }, setLegendVisible: function (a) {
        if (this.chartGlyph && this.chartGlyph.legendGlyph) {
            this.chartGlyph.legendGlyph.visible = FR.pick(a, false);
            this.refreshWithoutAnimation()
        }
    }, setSeriesInvisible: function (f) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            var e = this.chartGlyph.plotGlyph;
            var g = this.chartGlyph.legendGlyph;
            var d = e.dataSeries;
            f = f || [];
            for (var c = 0; c < d.length; c++) {
                var b = d[c];
                var h = FR.Chart.ChartPaintConstants.STATE_ENABLE;
                var a = false;
                if (FR.Chart.ChartUtils.inArray(f, c)) {
                    h = FR.Chart.ChartPaintConstants.STATE_UNENABLE;
                    a = true
                }
                b.paintState = h;
                if (g && g.items) {
                    g.items[c].disable = a
                }
            }
        }
        this.refresh()
    }, setLabelVisible: function (d) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            var c = this.chartGlyph.plotGlyph;
            var b = c.dataSeries;
            if (b) {
                for (var a = 0; a < b.length; a++) {
                    b[a].shouldDrawLable = d
                }
            }
        }
        this.refreshWithoutAnimation()
    }, setLabelValue: function () {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            var c = this.chartGlyph.plotGlyph;
            var a = c.getDataPointByPara(arguments);
            if (a) {
                var b = arguments[arguments.length - 1];
                a.setCustomLabel(b, c)
            }
        }
        this.refreshWithoutAnimation()
    }, setAnimationEnable: function (a) {
        this.actionModel = a ? FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE : FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL
    }, setAutoRefresh: function (a) {
        clearInterval(this.autoRefreshID);
        this.autoRefreshTime = a;
        this._autoRefresh()
    }, clearAlertLine: function () {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            var b = this.chartGlyph.plotGlyph;

            function a(c) {
                if (c && c.alertValueList) {
                    c.alertValueList = []
                }
            }

            a(b.xAxisGlyph);
            a(b.yAxisGlyph);
            a(b.secondAxisGlyph)
        }
        this.refresh()
    }, addAlertLine: function (b, h, e, g, i) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            var c = this.chartGlyph.plotGlyph;
            var a = c.yAxisGlyph;
            if (i) {
                a = c.getSecondValueAxisGlyph()
            }
            if (a && a.alertValueList) {
                var d = new FR.Chart.ChartAlertValue();
                a.alertValueList.push(d);
                var f = FR.Chart.Position[g];
                if (a.position == FR.Chart.Constants.TOP || a.position == FR.Chart.Constants.BOTTOM) {
                    if (f == FR.Chart.Constants.TOP) {
                        f = FR.Chart.Constants.RIGHT
                    } else {
                        f = FR.Chart.Constants.LEFT
                    }
                }
                d.alertContent = b;
                d.formula = h;
                d.attrLineColor.seriesColor = e;
                d.alertPosition = f
            }
        }
    }, setZoom: function (b) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph && this.chartGlyph.plotGlyph.xAxisGlyph) {
            var a = this.chartGlyph.plotGlyph.xAxisGlyph;
            a.isZoom = b;
            if (b) {
                this.chartGlyph.initDemoPlotGlyphIfNeed(this.chartAttr)
            } else {
                this.chartGlyph.preChartGlyph = null
            }
            this.refreshWithoutAnimation()
        }
    }, setAxisTooltipEnable: function (a) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            this.chartGlyph.plotGlyph.interactiveAxisTooltip = a
        }
    }, setTooltipEnable: function (a) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            this.chartGlyph.plotGlyph.isTooltipEnable = a
        }
    }, setDraggable: function (a) {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            var d = this.chartGlyph.plotGlyph;
            var c = d.dataSeries;
            for (var b = 0; b < c.length; b++) {
                c[b].seriesDragEnable = a
            }
        }
    }, sort: function (a) {
        if (a == null || a == undefined) {
            a = true
        }
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            this.chartGlyph.plotGlyph.sort(a);
            this.refresh()
        }
    }, refresh: function () {
        if (FR.Browser.isIE8Before()) {
            this.dom.empty();
            this._updateCanvas(this.dom);
            this.chartGlyph.ctxs = this.ctxs;
            if (this.backgroundGlyph) {
                this.backgroundGlyph.initBackgroundCtx(this.dom)
            }
        }
        this._refreshWithAnimationPara(this.actionModel)
    }, refreshWithoutAnimation: function () {
        this._refreshWithAnimationPara(FR.Chart.ChartPaintConstants.ACTION_MODEL_NULL)
    }, refreshWithAnimation: function () {
        this._refreshWithAnimationPara(FR.Chart.ChartPaintConstants.ACTION_MODEL_CHANGE)
    }, _refreshWithAnimationPara: function (a) {
        if (this.chartGlyph) {
            this.chartGlyph.clearAll();
            this.chartGlyph.draw(a || FR.Chart.ChartPaintConstants.ACTION_MODEL_DEFAULT)
        }
    }, hasNextLayer: function () {
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            return this.chartGlyph.plotGlyph.hasNextLayer()
        }
    }, setTooltipValue: function () {
        var a = [];
        for (var b = 0; b < arguments.length; b++) {
            a.push(arguments[b])
        }
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            return this.chartGlyph.plotGlyph.setTooltipValue(a)
        }
    }, triggerTooltip: function () {
        var a = [];
        for (var b = 0; b < arguments.length; b++) {
            a.push(arguments[b])
        }
        if (this.chartGlyph && this.chartGlyph.plotGlyph) {
            return this.chartGlyph.plotGlyph.triggerTooltip(a, this.chartGlyph)
        }
    }, changeTableData: function () {
        if (this.chartGlyph) {
            var b = this.chartGlyph.ctxs;
            var c = this.chartGlyph.bounds;
            var d = this.chartGlyph.parentDiv;
            var a = this.chartGlyph;
            this.chartGlyph = new FR.Chart.ChartGlyph();
            this.chartGlyph.setOption(this.chartConfig);
            this.chartGlyph.setLastGlyph(a);
            this.chartGlyph.parentDiv = d;
            this.chartGlyph.bounds = c;
            this.chartGlyph.ctxs = b;
            this.chartGlyph.clearAll();
            this.dom.unbind();
            this.handler.reStart(this.chartGlyph);
            this.chartGlyph.draw(this.actionModel)
        }
    }, changeData: function (b, d) {
        if (this.chartGlyph) {
            var c = this.chartGlyph.ctxs;
            var e = this.chartGlyph.bounds;
            var f = this.chartGlyph.parentDiv;
            if (this.chartGlyph.plotGlyph) {
                this.chartGlyph.plotGlyph.stopDataPointLabel()
            }
            var a = this.chartGlyph;
            this.chartGlyph = new FR.Chart.ChartGlyph(b);
            this.chartGlyph.setLastGlyph(a);
            this.chartGlyph.parentDiv = f;
            this.chartGlyph.bounds = e;
            this.chartGlyph.ctxs = c;
            this.chartGlyph.clearAll();
            this.dom.unbind();
            this.handler.reStart(this.chartGlyph);
            if (d == null || d == undefined || d < 0 || d > 2) {
                d = FR.Chart.ChartPaintConstants.ACTION_MODEL_DEFAULT
            }
            this.chartGlyph.draw(d)
        }
    }, setZoomScale: function (d) {
        if (this.chartGlyph && this.chartGlyph.preChartGlyph) {
            var c = this.chartGlyph.preChartGlyph;
            var a = c.xAxisGlyph.getOriginalArrowValue() - c.xAxisGlyph.getOriginalCrossValue();
            var b = parseInt(d * a);
            c.xAxisGlyph.zoomBackward = 0;
            c.xAxisGlyph.zoomForward = 0;
            c.xAxisGlyph.onZoomBarRightDown(b);
            c.initDragBar(c.xAxisGlyph)
        }
        this.refreshWithoutAnimation()
    }, changeZoom: function (a) {
        if (this.chartGlyph && this.chartGlyph.preChartGlyph) {
            this.chartGlyph.preChartGlyph.isScroll = a
        }
    }
});